"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.verseObjectsToString = exports.subSelectionsFromSubquote = exports.selectionsFromQuoteAndVerseObjects = exports.selectionsFromQuoteAndString = exports.referenceIdsFromBcvQuery = exports.normalizeString = exports.getRegexForWord = exports.getPrecedingText = exports.getPrecedingOccurrences = exports.getCurrentOccurrenceFromPrecedingText = exports.generateSelection = exports.flattenVerseObjects = void 0;
var _stringPunctuationTokenizer = require("string-punctuation-tokenizer");
var _xregexp = _interopRequireDefault(require("xregexp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * The function will find the quote in the verse object
 * @param {string} quote - The orignal quote to find
 * @param {object} verseObjects - verse ojects to search
 * @param {number} occurrence - The occurrence to match
 * @returns {[]} - The quotes we found
 */
var selectionsFromQuoteAndVerseObjects = function selectionsFromQuoteAndVerseObjects(_ref) {
  var verseObjects = _ref.verseObjects,
    quote = _ref.quote,
    occurrence = _ref.occurrence,
    _ref$chapter = _ref.chapter,
    chapter = _ref$chapter === void 0 ? 100 : _ref$chapter,
    _ref$verses = _ref.verses,
    verses = _ref$verses === void 0 ? [100] : _ref$verses;
  if (occurrence === undefined || occurrence === 0) {
    return [];
  }
  var selections = [];
  if (quote && verseObjects.length > 0 && verses.length > 0) {
    if (verses.length > 1) {
      var _verseObjects = verseObjects.reduce(function (prev, curr) {
        return [].concat(_toConsumableArray(prev), _toConsumableArray(curr));
      }, []);
      var string = verseObjectsToString(_verseObjects);
      selections = selectionsFromQuoteAndString({
        quote: quote,
        string: string,
        occurrence: occurrence
      });
      var newSelections = [];
      for (var id = 0; id < selections.length; id++) {
        var sel = _objectSpread({}, selections[id]);
        for (var index = 0; index < verseObjects.length; index++) {
          var tmpSelections = selectionsFromQuoteAndVerseObjects({
            quote: sel.text,
            verseObjects: verseObjects[index],
            occurrence: -1,
            reference: {
              chapter: chapter,
              verse: verses[index]
            }
          });
          if (tmpSelections.length === 0) {
            continue;
          }
          if (sel.occurrence > tmpSelections[0].occurrences) {
            sel.occurrence -= tmpSelections[0].occurrences;
          } else {
            newSelections.push({
              text: sel.text,
              occurrence: sel.occurrence,
              reference: {
                chapter: parseInt(chapter),
                verse: parseInt(verses[index])
              },
              occurrences: tmpSelections[0].occurrences
            });
            break;
          }
        }
      }
      selections = [].concat(newSelections);
    } else {
      var _string = verseObjectsToString(verseObjects);
      selections = selectionsFromQuoteAndString({
        quote: quote,
        string: _string,
        occurrence: occurrence
      }).map(function (el) {
        return _objectSpread(_objectSpread({}, el), {}, {
          reference: {
            chapter: parseInt(chapter),
            verse: parseInt(verses[0])
          }
        });
      });
    }
  }
  return selections.map(function (el) {
    return el.occurrences === 0 ? 0 : el.occurrence > el.occurrences ? 0 : el.occurrences;
  }).includes(0) ? [] : selections;
};
exports.selectionsFromQuoteAndVerseObjects = selectionsFromQuoteAndVerseObjects;
var referenceIdsFromBcvQuery = function referenceIdsFromBcvQuery(bcvQuery) {
  var resArray = [];
  if (bcvQuery !== null && bcvQuery !== void 0 && bcvQuery.book) {
    Object.entries(bcvQuery === null || bcvQuery === void 0 ? void 0 : bcvQuery.book).forEach(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
        bookKey = _ref3[0],
        ch = _ref3[1].ch;
      Object.entries(ch).forEach(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
          chNum = _ref5[0],
          v = _ref5[1].v;
        Object.entries(v).forEach(function (_ref6) {
          var _ref7 = _slicedToArray(_ref6, 1),
            vNum = _ref7[0];
          resArray.push("".concat(chNum, ":").concat(vNum));
        });
      });
    });
  }
  return resArray;
};

/**
 * @description flatten verse objects from nested format to flat array
 * @param {array} verseObjects - source array of nested verseObjects
 * @param {array} flat - output array that will be filled with flattened verseObjects
 */
exports.referenceIdsFromBcvQuery = referenceIdsFromBcvQuery;
var flattenVerseObjects = function flattenVerseObjects(verseObjects) {
  var flat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var _verseObjects = _toConsumableArray(verseObjects);
  while (_verseObjects.length > 0) {
    var object = _verseObjects.shift();
    if (object) {
      if (object.type === 'milestone') {
        // get children of milestone
        var _flat = flattenVerseObjects(object.children);
        _flat.forEach(function (_object) {
          return flat.push(_object);
        });
      } else {
        flat.push(object);
      }
    }
  }
  return flat;
};
exports.flattenVerseObjects = flattenVerseObjects;
var verseObjectsToString = function verseObjectsToString(verseObjects) {
  var flattenedVerseObjects = flattenVerseObjects(verseObjects);
  var string = flattenedVerseObjects.map(function (verseObject) {
    return verseObject.text;
  }).join(' ');
  return string;
};

/**
 * The function will find the quote inside the string
 * @param {string} quote - The orignal quote to find
 * @param {string} string - orignal text to search
 * @param {number} occurrence - The occurrence to match
 * @returns {[]} - The quotes we found
 */
exports.verseObjectsToString = verseObjectsToString;
var selectionsFromQuoteAndString = function selectionsFromQuoteAndString(_ref8) {
  var quote = _ref8.quote,
    rawString = _ref8.string,
    occurrence = _ref8.occurrence;
  var string = normalizeString(rawString);
  // Calculate hasAmpersand before normalizing quote.
  var _subquotes = quote.replace(/( ?… ?)+/g, ' & '); //replace elipse with '&'
  var subquotes = _subquotes.split('&').map(normalizeString); // разбиваем по амперсанду строку на подстроки
  var selections = []; // массив со словами которые надо подсветить
  var hasAmpersand = subquotes.length > 1; // есть ли амперсанд

  if (hasAmpersand && occurrence === -1) {
    // с амперсандом нельзя подсвечивать все возможные варианты (непонятно почему так, вроде же можно сделать (хотя теперь понятно, ниже идет подсчет, вхождений, если будет амперсанд, то будет сложнее регулярку написать)), нужен какой-то конкретный
    return [];
  }
  if (occurrence === -1) {
    // если нужны все вхождения то
    // считаем количество вхождений в стихе и делаем так, типа они написаны через амперсанд, подстроки
    quote = normalizeString(quote); // чистим цитату от лишнего
    var occurrences = getPrecedingOccurrences(string, quote);
    subquotes = new Array(occurrences).fill(quote);
  }
  var precedingText = ''; // это текст который до слова, нужен только для амперсанда или -1
  var precedingOccurrences = 0; // это вроде количество предыдущих вхождений
  subquotes.forEach(function (subquote, index) {
    // этот код по большей части для нескольких слов через амперсанд
    // надо проверить, как он работает для одного слова и -1, слово и 2, несколько слов через &
    precedingOccurrences = getPrecedingOccurrences(precedingText, subquote); // считаем сколько раз слово встречалось в предыдущем тексте (работает только для &)
    // без амперсанда у нас будет 0
    var currentOccurrence = getCurrentOccurrenceFromPrecedingText(occurrence, index, precedingOccurrences); // количество, которое нам надо дальше, надо понять как его считать и почему у меня пишет 4 из трех
    precedingText = getPrecedingText(string, subquote, currentOccurrence, precedingOccurrences); // тут мы получаем текст, который до искомого слова шел
    var subSelections = subSelectionsFromSubquote({
      subquote: subquote,
      precedingText: precedingText,
      string: string
    });
    subSelections.forEach(function (subSelection) {
      return selections.push(subSelection);
    });
    /** Adding the previous subquote to account for repeated ampersand words i.e. Θεοῦ&Θεοῦ */
    precedingText += subquote; // добавляем искомое слово к тексту который был до слова
  });

  return selections;
};
exports.selectionsFromQuoteAndString = selectionsFromQuoteAndString;
var normalizeString = function normalizeString(string) {
  var normalized = tokenizer(string).join(' ');
  return normalized;
};
exports.normalizeString = normalizeString;
var tokenizer = function tokenizer(text) {
  return (0, _stringPunctuationTokenizer.tokenize)({
    text: text,
    greedy: true,
    normalize: true
  });
};

/**
 * This counts the number of subquotes in the string
 * @param {string} string - string we are searching in
 * @param {string} subquote - string we are searching for
 * @returns {number} number
 */
var getPrecedingOccurrences = function getPrecedingOccurrences(string, subquote) {
  if (!string || !subquote) {
    return 0;
  }
  var regex = getRegexForWord(subquote);
  var matches = _xregexp["default"].match(string, regex, 'all');
  var count = matches && matches.length || 0;
  return count;
};

/**
 * This function gets the correct amount of occurrences to provide the function getPrecedingText
 *
 * @param {number} occurrence - The occurrence of the subquote in the string
 * @param {number} index - The current index of the subquotes
 * @param {number} precedingOccurrences - The number of occurrences before the current subquote in the string
 */
exports.getPrecedingOccurrences = getPrecedingOccurrences;
var getCurrentOccurrenceFromPrecedingText = function getCurrentOccurrenceFromPrecedingText(occurrence, index, precedingOccurrences) {
  if (occurrence === -1 || index === 0) {
    return occurrence;
  } else {
    return precedingOccurrences + 1;
  }
};

/**
 *
 * @param {string} string - The entire string to use to find the preceding text
 * @param {string} subquote - The subquote to find the preceding text of
 * @param {number} occurrence - The occurrence of the string in the entire string
 * @param {number} index - The index of the subquote
 */
exports.getCurrentOccurrenceFromPrecedingText = getCurrentOccurrenceFromPrecedingText;
var getPrecedingText = function getPrecedingText(string, subquote, occurrence) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var regex = getRegexForWord(subquote);
  var splitString = _xregexp["default"].split(string, regex);
  if (occurrence === -1) {
    // вот еще один момент, возможно, из за которого неполучится использовать амперсанд и -1
    //Need every occurrence of the subquote
    //Using the index instead of the occurrence
    return splitString.slice(0, index + 1).join(subquote);
  } else {
    //Return the subquote at the specified occurrence
    //of the entire string
    return splitString.slice(0, occurrence).join(subquote);
  }
};
exports.getPrecedingText = getPrecedingText;
var subSelectionsFromSubquote = function subSelectionsFromSubquote(_ref9) {
  var subquote = _ref9.subquote,
    _precedingText = _ref9.precedingText,
    string = _ref9.string;
  //Splitting by tokenization here causes issues because we are still
  //comparing those characters at this level
  var selectedTokens = subquote.split(' '); // разбиваем искомую строку по словам
  var subSelections = [];
  selectedTokens.forEach(function (_selectedText) {
    // для каждого слова
    //Adding the preceding text from the subSelections to ensure that
    //Repeated words are accounted for
    var precedingTextInSubselections = subSelections.map(function (_ref10) {
      var text = _ref10.text;
      return text;
    }).join(' ');
    var subSelection = generateSelection({
      selectedText: _selectedText,
      precedingText: _precedingText + precedingTextInSubselections,
      entireText: string
    });
    subSelections.push(subSelection);
  });
  return subSelections;
};

/**
 * This function takes a search string and create a regex search string to match a whole word
 * @param {string} string - string to search for
 * @returns {RegExp} regex expression
 */
exports.subSelectionsFromSubquote = subSelectionsFromSubquote;
var getRegexForWord = function getRegexForWord(string) {
  var START_WORD_REGEX = '(?<=[\\s,.:;“"\'‘({]|^)';
  var END_WORD_REGEX = '(?=[\\s,.:;“"\'‘!?)}]|$)';
  var search = "".concat(START_WORD_REGEX).concat(string).concat(END_WORD_REGEX);
  var regex = (0, _xregexp["default"])(search, 'u');
  return regex;
};

/**
 * @description - generates a selection object from the selected text, precedingText and whole text
 * @param {String} selectedText - the text that is selected
 * @param {String} precedingText - the text that prescedes the selection
 * @param {String} entireText - the text that the selection should be in
 * @return {Object} - the selection object to be used
 */
exports.getRegexForWord = getRegexForWord;
var generateSelection = function generateSelection(_ref11) {
  var selectedText = _ref11.selectedText,
    precedingText = _ref11.precedingText,
    entireText = _ref11.entireText;
  // replace more than one contiguous space with a single one since HTML/selection only renders 1
  var _entireText = normalizeString(entireText);
  // Getting the occurrences before the current token
  var precedingTokens = tokenizer(precedingText);
  var precedingOccurrencesInPreviousString = precedingTokens.reduce(function (n, val) {
    return n + (val === selectedText);
  }, 0);
  // calculate this occurrence number by adding it to the preceding ones
  var occurrence = precedingOccurrencesInPreviousString + 1;
  // get the total occurrences from the verse
  var allTokens = tokenizer(_entireText);
  var allOccurrences = allTokens.reduce(function (n, val) {
    return n + (val === selectedText);
  }, 0);
  return {
    text: selectedText,
    occurrence: occurrence,
    occurrences: allOccurrences
  };
};
exports.generateSelection = generateSelection;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfc3RyaW5nUHVuY3R1YXRpb25Ub2tlbml6ZXIiLCJyZXF1aXJlIiwiX3hyZWdleHAiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0Iiwib2JqIiwiX19lc01vZHVsZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsImNhbGwiLCJuZXh0IiwiT2JqZWN0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImxlbmd0aCIsImVyciIsIkFycmF5IiwiaXNBcnJheSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImFyZ3VtZW50cyIsInNvdXJjZSIsImZvckVhY2giLCJrZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIl90eXBlb2YiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJOdW1iZXIiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJmcm9tIiwidGVzdCIsIml0ZXIiLCJsZW4iLCJhcnIyIiwic2VsZWN0aW9uc0Zyb21RdW90ZUFuZFZlcnNlT2JqZWN0cyIsIl9yZWYiLCJ2ZXJzZU9iamVjdHMiLCJxdW90ZSIsIm9jY3VycmVuY2UiLCJfcmVmJGNoYXB0ZXIiLCJjaGFwdGVyIiwiX3JlZiR2ZXJzZXMiLCJ2ZXJzZXMiLCJzZWxlY3Rpb25zIiwiX3ZlcnNlT2JqZWN0cyIsInJlZHVjZSIsInByZXYiLCJjdXJyIiwiY29uY2F0Iiwic3RyaW5nIiwidmVyc2VPYmplY3RzVG9TdHJpbmciLCJzZWxlY3Rpb25zRnJvbVF1b3RlQW5kU3RyaW5nIiwibmV3U2VsZWN0aW9ucyIsImlkIiwic2VsIiwiaW5kZXgiLCJ0bXBTZWxlY3Rpb25zIiwidGV4dCIsInJlZmVyZW5jZSIsInZlcnNlIiwib2NjdXJyZW5jZXMiLCJwYXJzZUludCIsIm1hcCIsImVsIiwiaW5jbHVkZXMiLCJleHBvcnRzIiwicmVmZXJlbmNlSWRzRnJvbUJjdlF1ZXJ5IiwiYmN2UXVlcnkiLCJyZXNBcnJheSIsImJvb2siLCJlbnRyaWVzIiwiX3JlZjIiLCJfcmVmMyIsImJvb2tLZXkiLCJjaCIsIl9yZWY0IiwiX3JlZjUiLCJjaE51bSIsInYiLCJfcmVmNiIsIl9yZWY3Iiwidk51bSIsImZsYXR0ZW5WZXJzZU9iamVjdHMiLCJmbGF0Iiwic2hpZnQiLCJ0eXBlIiwiX2ZsYXQiLCJjaGlsZHJlbiIsIl9vYmplY3QiLCJmbGF0dGVuZWRWZXJzZU9iamVjdHMiLCJ2ZXJzZU9iamVjdCIsImpvaW4iLCJfcmVmOCIsInJhd1N0cmluZyIsIm5vcm1hbGl6ZVN0cmluZyIsIl9zdWJxdW90ZXMiLCJyZXBsYWNlIiwic3VicXVvdGVzIiwic3BsaXQiLCJoYXNBbXBlcnNhbmQiLCJnZXRQcmVjZWRpbmdPY2N1cnJlbmNlcyIsImZpbGwiLCJwcmVjZWRpbmdUZXh0IiwicHJlY2VkaW5nT2NjdXJyZW5jZXMiLCJzdWJxdW90ZSIsImN1cnJlbnRPY2N1cnJlbmNlIiwiZ2V0Q3VycmVudE9jY3VycmVuY2VGcm9tUHJlY2VkaW5nVGV4dCIsImdldFByZWNlZGluZ1RleHQiLCJzdWJTZWxlY3Rpb25zIiwic3ViU2VsZWN0aW9uc0Zyb21TdWJxdW90ZSIsInN1YlNlbGVjdGlvbiIsIm5vcm1hbGl6ZWQiLCJ0b2tlbml6ZXIiLCJ0b2tlbml6ZSIsImdyZWVkeSIsIm5vcm1hbGl6ZSIsInJlZ2V4IiwiZ2V0UmVnZXhGb3JXb3JkIiwibWF0Y2hlcyIsInhyZSIsIm1hdGNoIiwiY291bnQiLCJzcGxpdFN0cmluZyIsIl9yZWY5IiwiX3ByZWNlZGluZ1RleHQiLCJzZWxlY3RlZFRva2VucyIsIl9zZWxlY3RlZFRleHQiLCJwcmVjZWRpbmdUZXh0SW5TdWJzZWxlY3Rpb25zIiwiX3JlZjEwIiwiZ2VuZXJhdGVTZWxlY3Rpb24iLCJzZWxlY3RlZFRleHQiLCJlbnRpcmVUZXh0IiwiU1RBUlRfV09SRF9SRUdFWCIsIkVORF9XT1JEX1JFR0VYIiwic2VhcmNoIiwiX3JlZjExIiwiX2VudGlyZVRleHQiLCJwcmVjZWRpbmdUb2tlbnMiLCJwcmVjZWRpbmdPY2N1cnJlbmNlc0luUHJldmlvdXNTdHJpbmciLCJ2YWwiLCJhbGxUb2tlbnMiLCJhbGxPY2N1cnJlbmNlcyJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9zcnJjbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b2tlbml6ZSB9IGZyb20gJ3N0cmluZy1wdW5jdHVhdGlvbi10b2tlbml6ZXInO1xuaW1wb3J0IHhyZSBmcm9tICd4cmVnZXhwJztcblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBmaW5kIHRoZSBxdW90ZSBpbiB0aGUgdmVyc2Ugb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcXVvdGUgLSBUaGUgb3JpZ25hbCBxdW90ZSB0byBmaW5kXG4gKiBAcGFyYW0ge29iamVjdH0gdmVyc2VPYmplY3RzIC0gdmVyc2Ugb2plY3RzIHRvIHNlYXJjaFxuICogQHBhcmFtIHtudW1iZXJ9IG9jY3VycmVuY2UgLSBUaGUgb2NjdXJyZW5jZSB0byBtYXRjaFxuICogQHJldHVybnMge1tdfSAtIFRoZSBxdW90ZXMgd2UgZm91bmRcbiAqL1xuZXhwb3J0IGNvbnN0IHNlbGVjdGlvbnNGcm9tUXVvdGVBbmRWZXJzZU9iamVjdHMgPSAoe1xuICB2ZXJzZU9iamVjdHMsXG4gIHF1b3RlLFxuICBvY2N1cnJlbmNlLFxuICBjaGFwdGVyID0gMTAwLFxuICB2ZXJzZXMgPSBbMTAwXSxcbn0pID0+IHtcbiAgaWYgKG9jY3VycmVuY2UgPT09IHVuZGVmaW5lZCB8fCBvY2N1cnJlbmNlID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGxldCBzZWxlY3Rpb25zID0gW107XG4gIGlmIChxdW90ZSAmJiB2ZXJzZU9iamVjdHMubGVuZ3RoID4gMCAmJiB2ZXJzZXMubGVuZ3RoID4gMCkge1xuICAgIGlmICh2ZXJzZXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgX3ZlcnNlT2JqZWN0cyA9IHZlcnNlT2JqZWN0cy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IFsuLi5wcmV2LCAuLi5jdXJyXSwgW10pO1xuICAgICAgY29uc3Qgc3RyaW5nID0gdmVyc2VPYmplY3RzVG9TdHJpbmcoX3ZlcnNlT2JqZWN0cyk7XG4gICAgICBzZWxlY3Rpb25zID0gc2VsZWN0aW9uc0Zyb21RdW90ZUFuZFN0cmluZyh7IHF1b3RlLCBzdHJpbmcsIG9jY3VycmVuY2UgfSk7XG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb25zID0gW107XG4gICAgICBmb3IgKGxldCBpZCA9IDA7IGlkIDwgc2VsZWN0aW9ucy5sZW5ndGg7IGlkKyspIHtcbiAgICAgICAgY29uc3Qgc2VsID0geyAuLi5zZWxlY3Rpb25zW2lkXSB9O1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdmVyc2VPYmplY3RzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHRtcFNlbGVjdGlvbnMgPSBzZWxlY3Rpb25zRnJvbVF1b3RlQW5kVmVyc2VPYmplY3RzKHtcbiAgICAgICAgICAgIHF1b3RlOiBzZWwudGV4dCxcbiAgICAgICAgICAgIHZlcnNlT2JqZWN0czogdmVyc2VPYmplY3RzW2luZGV4XSxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IC0xLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiB7IGNoYXB0ZXIsIHZlcnNlOiB2ZXJzZXNbaW5kZXhdIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRtcFNlbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbC5vY2N1cnJlbmNlID4gdG1wU2VsZWN0aW9uc1swXS5vY2N1cnJlbmNlcykge1xuICAgICAgICAgICAgc2VsLm9jY3VycmVuY2UgLT0gdG1wU2VsZWN0aW9uc1swXS5vY2N1cnJlbmNlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogc2VsLnRleHQsXG4gICAgICAgICAgICAgIG9jY3VycmVuY2U6IHNlbC5vY2N1cnJlbmNlLFxuICAgICAgICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICAgICAgICBjaGFwdGVyOiBwYXJzZUludChjaGFwdGVyKSxcbiAgICAgICAgICAgICAgICB2ZXJzZTogcGFyc2VJbnQodmVyc2VzW2luZGV4XSksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9jY3VycmVuY2VzOiB0bXBTZWxlY3Rpb25zWzBdLm9jY3VycmVuY2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbnMgPSBbLi4ubmV3U2VsZWN0aW9uc107XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHZlcnNlT2JqZWN0c1RvU3RyaW5nKHZlcnNlT2JqZWN0cyk7XG4gICAgICBzZWxlY3Rpb25zID0gc2VsZWN0aW9uc0Zyb21RdW90ZUFuZFN0cmluZyh7XG4gICAgICAgIHF1b3RlLFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIG9jY3VycmVuY2UsXG4gICAgICB9KS5tYXAoKGVsKSA9PiAoe1xuICAgICAgICAuLi5lbCxcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgY2hhcHRlcjogcGFyc2VJbnQoY2hhcHRlciksXG4gICAgICAgICAgdmVyc2U6IHBhcnNlSW50KHZlcnNlc1swXSksXG4gICAgICAgIH0sXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWxlY3Rpb25zXG4gICAgLm1hcCgoZWwpID0+XG4gICAgICBlbC5vY2N1cnJlbmNlcyA9PT0gMCA/IDAgOiBlbC5vY2N1cnJlbmNlID4gZWwub2NjdXJyZW5jZXMgPyAwIDogZWwub2NjdXJyZW5jZXNcbiAgICApXG4gICAgLmluY2x1ZGVzKDApXG4gICAgPyBbXVxuICAgIDogc2VsZWN0aW9ucztcbn07XG5cbmV4cG9ydCBjb25zdCByZWZlcmVuY2VJZHNGcm9tQmN2UXVlcnkgPSAoYmN2UXVlcnkpID0+IHtcbiAgY29uc3QgcmVzQXJyYXkgPSBbXTtcbiAgaWYgKGJjdlF1ZXJ5Py5ib29rKSB7XG4gICAgT2JqZWN0LmVudHJpZXMoYmN2UXVlcnk/LmJvb2spLmZvckVhY2goKFtib29rS2V5LCB7IGNoIH1dKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhjaCkuZm9yRWFjaCgoW2NoTnVtLCB7IHYgfV0pID0+IHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXModikuZm9yRWFjaCgoW3ZOdW1dKSA9PiB7XG4gICAgICAgICAgcmVzQXJyYXkucHVzaChgJHtjaE51bX06JHt2TnVtfWApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXNBcnJheTtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIGZsYXR0ZW4gdmVyc2Ugb2JqZWN0cyBmcm9tIG5lc3RlZCBmb3JtYXQgdG8gZmxhdCBhcnJheVxuICogQHBhcmFtIHthcnJheX0gdmVyc2VPYmplY3RzIC0gc291cmNlIGFycmF5IG9mIG5lc3RlZCB2ZXJzZU9iamVjdHNcbiAqIEBwYXJhbSB7YXJyYXl9IGZsYXQgLSBvdXRwdXQgYXJyYXkgdGhhdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGZsYXR0ZW5lZCB2ZXJzZU9iamVjdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXR0ZW5WZXJzZU9iamVjdHMgPSAodmVyc2VPYmplY3RzLCBmbGF0ID0gW10pID0+IHtcbiAgbGV0IF92ZXJzZU9iamVjdHMgPSBbLi4udmVyc2VPYmplY3RzXTtcbiAgd2hpbGUgKF92ZXJzZU9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG9iamVjdCA9IF92ZXJzZU9iamVjdHMuc2hpZnQoKTtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdtaWxlc3RvbmUnKSB7XG4gICAgICAgIC8vIGdldCBjaGlsZHJlbiBvZiBtaWxlc3RvbmVcbiAgICAgICAgY29uc3QgX2ZsYXQgPSBmbGF0dGVuVmVyc2VPYmplY3RzKG9iamVjdC5jaGlsZHJlbik7XG4gICAgICAgIF9mbGF0LmZvckVhY2goKF9vYmplY3QpID0+IGZsYXQucHVzaChfb2JqZWN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0LnB1c2gob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZsYXQ7XG59O1xuXG5leHBvcnQgY29uc3QgdmVyc2VPYmplY3RzVG9TdHJpbmcgPSAodmVyc2VPYmplY3RzKSA9PiB7XG4gIGNvbnN0IGZsYXR0ZW5lZFZlcnNlT2JqZWN0cyA9IGZsYXR0ZW5WZXJzZU9iamVjdHModmVyc2VPYmplY3RzKTtcbiAgY29uc3Qgc3RyaW5nID0gZmxhdHRlbmVkVmVyc2VPYmplY3RzLm1hcCgodmVyc2VPYmplY3QpID0+IHZlcnNlT2JqZWN0LnRleHQpLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbi8qKlxuICogVGhlIGZ1bmN0aW9uIHdpbGwgZmluZCB0aGUgcXVvdGUgaW5zaWRlIHRoZSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdW90ZSAtIFRoZSBvcmlnbmFsIHF1b3RlIHRvIGZpbmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSBvcmlnbmFsIHRleHQgdG8gc2VhcmNoXG4gKiBAcGFyYW0ge251bWJlcn0gb2NjdXJyZW5jZSAtIFRoZSBvY2N1cnJlbmNlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyB7W119IC0gVGhlIHF1b3RlcyB3ZSBmb3VuZFxuICovXG5leHBvcnQgY29uc3Qgc2VsZWN0aW9uc0Zyb21RdW90ZUFuZFN0cmluZyA9ICh7XG4gIHF1b3RlLFxuICBzdHJpbmc6IHJhd1N0cmluZyxcbiAgb2NjdXJyZW5jZSxcbn0pID0+IHtcbiAgbGV0IHN0cmluZyA9IG5vcm1hbGl6ZVN0cmluZyhyYXdTdHJpbmcpO1xuICAvLyBDYWxjdWxhdGUgaGFzQW1wZXJzYW5kIGJlZm9yZSBub3JtYWxpemluZyBxdW90ZS5cbiAgbGV0IF9zdWJxdW90ZXMgPSBxdW90ZS5yZXBsYWNlKC8oID/igKYgPykrL2csICcgJiAnKTsgLy9yZXBsYWNlIGVsaXBzZSB3aXRoICcmJ1xuICBsZXQgc3VicXVvdGVzID0gX3N1YnF1b3Rlcy5zcGxpdCgnJicpLm1hcChub3JtYWxpemVTdHJpbmcpOyAvLyDRgNCw0LfQsdC40LLQsNC10Lwg0L/QviDQsNC80L/QtdGA0YHQsNC90LTRgyDRgdGC0YDQvtC60YMg0L3QsCDQv9C+0LTRgdGC0YDQvtC60LhcbiAgbGV0IHNlbGVjdGlvbnMgPSBbXTsgLy8g0LzQsNGB0YHQuNCyINGB0L4g0YHQu9C+0LLQsNC80Lgg0LrQvtGC0L7RgNGL0LUg0L3QsNC00L4g0L/QvtC00YHQstC10YLQuNGC0YxcbiAgY29uc3QgaGFzQW1wZXJzYW5kID0gc3VicXVvdGVzLmxlbmd0aCA+IDE7IC8vINC10YHRgtGMINC70Lgg0LDQvNC/0LXRgNGB0LDQvdC0XG5cbiAgaWYgKGhhc0FtcGVyc2FuZCAmJiBvY2N1cnJlbmNlID09PSAtMSkge1xuICAgIC8vINGBINCw0LzQv9C10YDRgdCw0L3QtNC+0Lwg0L3QtdC70YzQt9GPINC/0L7QtNGB0LLQtdGH0LjQstCw0YLRjCDQstGB0LUg0LLQvtC30LzQvtC20L3Ri9C1INCy0LDRgNC40LDQvdGC0YsgKNC90LXQv9C+0L3Rj9GC0L3QviDQv9C+0YfQtdC80YMg0YLQsNC6LCDQstGA0L7QtNC1INC20LUg0LzQvtC20L3QviDRgdC00LXQu9Cw0YLRjCAo0YXQvtGC0Y8g0YLQtdC/0LXRgNGMINC/0L7QvdGP0YLQvdC+LCDQvdC40LbQtSDQuNC00LXRgiDQv9C+0LTRgdGH0LXRgiwg0LLRhdC+0LbQtNC10L3QuNC5LCDQtdGB0LvQuCDQsdGD0LTQtdGCINCw0LzQv9C10YDRgdCw0L3QtCwg0YLQviDQsdGD0LTQtdGCINGB0LvQvtC20L3QtdC1INGA0LXQs9GD0LvRj9GA0LrRgyDQvdCw0L/QuNGB0LDRgtGMKSksINC90YPQttC10L0g0LrQsNC60L7QuS3RgtC+INC60L7QvdC60YDQtdGC0L3Ri9C5XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKG9jY3VycmVuY2UgPT09IC0xKSB7XG4gICAgLy8g0LXRgdC70Lgg0L3Rg9C20L3RiyDQstGB0LUg0LLRhdC+0LbQtNC10L3QuNGPINGC0L5cbiAgICAvLyDRgdGH0LjRgtCw0LXQvCDQutC+0LvQuNGH0LXRgdGC0LLQviDQstGF0L7QttC00LXQvdC40Lkg0LIg0YHRgtC40YXQtSDQuCDQtNC10LvQsNC10Lwg0YLQsNC6LCDRgtC40L/QsCDQvtC90Lgg0L3QsNC/0LjRgdCw0L3RiyDRh9C10YDQtdC3INCw0LzQv9C10YDRgdCw0L3QtCwg0L/QvtC00YHRgtGA0L7QutC4XG4gICAgcXVvdGUgPSBub3JtYWxpemVTdHJpbmcocXVvdGUpOyAvLyDRh9C40YHRgtC40Lwg0YbQuNGC0LDRgtGDINC+0YIg0LvQuNGI0L3QtdCz0L5cbiAgICBjb25zdCBvY2N1cnJlbmNlcyA9IGdldFByZWNlZGluZ09jY3VycmVuY2VzKHN0cmluZywgcXVvdGUpO1xuICAgIHN1YnF1b3RlcyA9IG5ldyBBcnJheShvY2N1cnJlbmNlcykuZmlsbChxdW90ZSk7XG4gIH1cbiAgbGV0IHByZWNlZGluZ1RleHQgPSAnJzsgLy8g0Y3RgtC+INGC0LXQutGB0YIg0LrQvtGC0L7RgNGL0Lkg0LTQviDRgdC70L7QstCwLCDQvdGD0LbQtdC9INGC0L7Qu9GM0LrQviDQtNC70Y8g0LDQvNC/0LXRgNGB0LDQvdC00LAg0LjQu9C4IC0xXG4gIGxldCBwcmVjZWRpbmdPY2N1cnJlbmNlcyA9IDA7IC8vINGN0YLQviDQstGA0L7QtNC1INC60L7Qu9C40YfQtdGB0YLQstC+INC/0YDQtdC00YvQtNGD0YnQuNGFINCy0YXQvtC20LTQtdC90LjQuVxuICBzdWJxdW90ZXMuZm9yRWFjaCgoc3VicXVvdGUsIGluZGV4KSA9PiB7XG4gICAgLy8g0Y3RgtC+0YIg0LrQvtC0INC/0L4g0LHQvtC70YzRiNC10Lkg0YfQsNGB0YLQuCDQtNC70Y8g0L3QtdGB0LrQvtC70YzQutC40YUg0YHQu9C+0LIg0YfQtdGA0LXQtyDQsNC80L/QtdGA0YHQsNC90LRcbiAgICAvLyDQvdCw0LTQviDQv9GA0L7QstC10YDQuNGC0YwsINC60LDQuiDQvtC9INGA0LDQsdC+0YLQsNC10YIg0LTQu9GPINC+0LTQvdC+0LPQviDRgdC70L7QstCwINC4IC0xLCDRgdC70L7QstC+INC4IDIsINC90LXRgdC60L7Qu9GM0LrQviDRgdC70L7QsiDRh9C10YDQtdC3ICZcbiAgICBwcmVjZWRpbmdPY2N1cnJlbmNlcyA9IGdldFByZWNlZGluZ09jY3VycmVuY2VzKHByZWNlZGluZ1RleHQsIHN1YnF1b3RlKTsgLy8g0YHRh9C40YLQsNC10Lwg0YHQutC+0LvRjNC60L4g0YDQsNC3INGB0LvQvtCy0L4g0LLRgdGC0YDQtdGH0LDQu9C+0YHRjCDQsiDQv9GA0LXQtNGL0LTRg9GJ0LXQvCDRgtC10LrRgdGC0LUgKNGA0LDQsdC+0YLQsNC10YIg0YLQvtC70YzQutC+INC00LvRjyAmKVxuICAgIC8vINCx0LXQtyDQsNC80L/QtdGA0YHQsNC90LTQsCDRgyDQvdCw0YEg0LHRg9C00LXRgiAwXG4gICAgY29uc3QgY3VycmVudE9jY3VycmVuY2UgPSBnZXRDdXJyZW50T2NjdXJyZW5jZUZyb21QcmVjZWRpbmdUZXh0KFxuICAgICAgb2NjdXJyZW5jZSxcbiAgICAgIGluZGV4LFxuICAgICAgcHJlY2VkaW5nT2NjdXJyZW5jZXNcbiAgICApOyAvLyDQutC+0LvQuNGH0LXRgdGC0LLQviwg0LrQvtGC0L7RgNC+0LUg0L3QsNC8INC90LDQtNC+INC00LDQu9GM0YjQtSwg0L3QsNC00L4g0L/QvtC90Y/RgtGMINC60LDQuiDQtdCz0L4g0YHRh9C40YLQsNGC0Ywg0Lgg0L/QvtGH0LXQvNGDINGDINC80LXQvdGPINC/0LjRiNC10YIgNCDQuNC3INGC0YDQtdGFXG4gICAgcHJlY2VkaW5nVGV4dCA9IGdldFByZWNlZGluZ1RleHQoXG4gICAgICBzdHJpbmcsXG4gICAgICBzdWJxdW90ZSxcbiAgICAgIGN1cnJlbnRPY2N1cnJlbmNlLFxuICAgICAgcHJlY2VkaW5nT2NjdXJyZW5jZXNcbiAgICApOyAvLyDRgtGD0YIg0LzRiyDQv9C+0LvRg9GH0LDQtdC8INGC0LXQutGB0YIsINC60L7RgtC+0YDRi9C5INC00L4g0LjRgdC60L7QvNC+0LPQviDRgdC70L7QstCwINGI0LXQu1xuICAgIGNvbnN0IHN1YlNlbGVjdGlvbnMgPSBzdWJTZWxlY3Rpb25zRnJvbVN1YnF1b3RlKHtcbiAgICAgIHN1YnF1b3RlLFxuICAgICAgcHJlY2VkaW5nVGV4dCxcbiAgICAgIHN0cmluZyxcbiAgICB9KTtcblxuICAgIHN1YlNlbGVjdGlvbnMuZm9yRWFjaCgoc3ViU2VsZWN0aW9uKSA9PiBzZWxlY3Rpb25zLnB1c2goc3ViU2VsZWN0aW9uKSk7XG4gICAgLyoqIEFkZGluZyB0aGUgcHJldmlvdXMgc3VicXVvdGUgdG8gYWNjb3VudCBmb3IgcmVwZWF0ZWQgYW1wZXJzYW5kIHdvcmRzIGkuZS4gzpjOtc6/4b+mJs6YzrXOv+G/piAqL1xuICAgIHByZWNlZGluZ1RleHQgKz0gc3VicXVvdGU7IC8vINC00L7QsdCw0LLQu9GP0LXQvCDQuNGB0LrQvtC80L7QtSDRgdC70L7QstC+INC6INGC0LXQutGB0YLRgyDQutC+0YLQvtGA0YvQuSDQsdGL0Lsg0LTQviDRgdC70L7QstCwXG4gIH0pO1xuICByZXR1cm4gc2VsZWN0aW9ucztcbn07XG5cbmV4cG9ydCBjb25zdCBub3JtYWxpemVTdHJpbmcgPSAoc3RyaW5nKSA9PiB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSB0b2tlbml6ZXIoc3RyaW5nKS5qb2luKCcgJyk7XG4gIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuY29uc3QgdG9rZW5pemVyID0gKHRleHQpID0+IHtcbiAgcmV0dXJuIHRva2VuaXplKHtcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBub3JtYWxpemU6IHRydWUsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGNvdW50cyB0aGUgbnVtYmVyIG9mIHN1YnF1b3RlcyBpbiB0aGUgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHdlIGFyZSBzZWFyY2hpbmcgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWJxdW90ZSAtIHN0cmluZyB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogQHJldHVybnMge251bWJlcn0gbnVtYmVyXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQcmVjZWRpbmdPY2N1cnJlbmNlcyA9IChzdHJpbmcsIHN1YnF1b3RlKSA9PiB7XG4gIGlmICghc3RyaW5nIHx8ICFzdWJxdW90ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IHJlZ2V4ID0gZ2V0UmVnZXhGb3JXb3JkKHN1YnF1b3RlKTtcbiAgY29uc3QgbWF0Y2hlcyA9IHhyZS5tYXRjaChzdHJpbmcsIHJlZ2V4LCAnYWxsJyk7XG4gIGNvbnN0IGNvdW50ID0gKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGgpIHx8IDA7XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBjb3JyZWN0IGFtb3VudCBvZiBvY2N1cnJlbmNlcyB0byBwcm92aWRlIHRoZSBmdW5jdGlvbiBnZXRQcmVjZWRpbmdUZXh0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG9jY3VycmVuY2UgLSBUaGUgb2NjdXJyZW5jZSBvZiB0aGUgc3VicXVvdGUgaW4gdGhlIHN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIHN1YnF1b3Rlc1xuICogQHBhcmFtIHtudW1iZXJ9IHByZWNlZGluZ09jY3VycmVuY2VzIC0gVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBiZWZvcmUgdGhlIGN1cnJlbnQgc3VicXVvdGUgaW4gdGhlIHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudE9jY3VycmVuY2VGcm9tUHJlY2VkaW5nVGV4dCA9IChcbiAgb2NjdXJyZW5jZSxcbiAgaW5kZXgsXG4gIHByZWNlZGluZ09jY3VycmVuY2VzXG4pID0+IHtcbiAgaWYgKG9jY3VycmVuY2UgPT09IC0xIHx8IGluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuIG9jY3VycmVuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWNlZGluZ09jY3VycmVuY2VzICsgMTtcbiAgfVxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBlbnRpcmUgc3RyaW5nIHRvIHVzZSB0byBmaW5kIHRoZSBwcmVjZWRpbmcgdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHN1YnF1b3RlIC0gVGhlIHN1YnF1b3RlIHRvIGZpbmQgdGhlIHByZWNlZGluZyB0ZXh0IG9mXG4gKiBAcGFyYW0ge251bWJlcn0gb2NjdXJyZW5jZSAtIFRoZSBvY2N1cnJlbmNlIG9mIHRoZSBzdHJpbmcgaW4gdGhlIGVudGlyZSBzdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc3VicXVvdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFByZWNlZGluZ1RleHQgPSAoc3RyaW5nLCBzdWJxdW90ZSwgb2NjdXJyZW5jZSwgaW5kZXggPSAwKSA9PiB7XG4gIGNvbnN0IHJlZ2V4ID0gZ2V0UmVnZXhGb3JXb3JkKHN1YnF1b3RlKTtcbiAgbGV0IHNwbGl0U3RyaW5nID0geHJlLnNwbGl0KHN0cmluZywgcmVnZXgpO1xuICBpZiAob2NjdXJyZW5jZSA9PT0gLTEpIHtcbiAgICAvLyDQstC+0YIg0LXRidC1INC+0LTQuNC9INC80L7QvNC10L3Rgiwg0LLQvtC30LzQvtC20L3Qviwg0LjQtyDQt9CwINC60L7RgtC+0YDQvtCz0L4g0L3QtdC/0L7Qu9GD0YfQuNGC0YHRjyDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0LDQvNC/0LXRgNGB0LDQvdC0INC4IC0xXG4gICAgLy9OZWVkIGV2ZXJ5IG9jY3VycmVuY2Ugb2YgdGhlIHN1YnF1b3RlXG4gICAgLy9Vc2luZyB0aGUgaW5kZXggaW5zdGVhZCBvZiB0aGUgb2NjdXJyZW5jZVxuICAgIHJldHVybiBzcGxpdFN0cmluZy5zbGljZSgwLCBpbmRleCArIDEpLmpvaW4oc3VicXVvdGUpO1xuICB9IGVsc2Uge1xuICAgIC8vUmV0dXJuIHRoZSBzdWJxdW90ZSBhdCB0aGUgc3BlY2lmaWVkIG9jY3VycmVuY2VcbiAgICAvL29mIHRoZSBlbnRpcmUgc3RyaW5nXG4gICAgcmV0dXJuIHNwbGl0U3RyaW5nLnNsaWNlKDAsIG9jY3VycmVuY2UpLmpvaW4oc3VicXVvdGUpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc3ViU2VsZWN0aW9uc0Zyb21TdWJxdW90ZSA9ICh7XG4gIHN1YnF1b3RlLFxuICBwcmVjZWRpbmdUZXh0OiBfcHJlY2VkaW5nVGV4dCxcbiAgc3RyaW5nLFxufSkgPT4ge1xuICAvL1NwbGl0dGluZyBieSB0b2tlbml6YXRpb24gaGVyZSBjYXVzZXMgaXNzdWVzIGJlY2F1c2Ugd2UgYXJlIHN0aWxsXG4gIC8vY29tcGFyaW5nIHRob3NlIGNoYXJhY3RlcnMgYXQgdGhpcyBsZXZlbFxuICBjb25zdCBzZWxlY3RlZFRva2VucyA9IHN1YnF1b3RlLnNwbGl0KCcgJyk7IC8vINGA0LDQt9Cx0LjQstCw0LXQvCDQuNGB0LrQvtC80YPRjiDRgdGC0YDQvtC60YMg0L/QviDRgdC70L7QstCw0LxcbiAgY29uc3Qgc3ViU2VsZWN0aW9ucyA9IFtdO1xuICBzZWxlY3RlZFRva2Vucy5mb3JFYWNoKChfc2VsZWN0ZWRUZXh0KSA9PiB7XG4gICAgLy8g0LTQu9GPINC60LDQttC00L7Qs9C+INGB0LvQvtCy0LBcbiAgICAvL0FkZGluZyB0aGUgcHJlY2VkaW5nIHRleHQgZnJvbSB0aGUgc3ViU2VsZWN0aW9ucyB0byBlbnN1cmUgdGhhdFxuICAgIC8vUmVwZWF0ZWQgd29yZHMgYXJlIGFjY291bnRlZCBmb3JcbiAgICBjb25zdCBwcmVjZWRpbmdUZXh0SW5TdWJzZWxlY3Rpb25zID0gc3ViU2VsZWN0aW9ucy5tYXAoKHsgdGV4dCB9KSA9PiB0ZXh0KS5qb2luKCcgJyk7XG4gICAgbGV0IHN1YlNlbGVjdGlvbiA9IGdlbmVyYXRlU2VsZWN0aW9uKHtcbiAgICAgIHNlbGVjdGVkVGV4dDogX3NlbGVjdGVkVGV4dCxcbiAgICAgIHByZWNlZGluZ1RleHQ6IF9wcmVjZWRpbmdUZXh0ICsgcHJlY2VkaW5nVGV4dEluU3Vic2VsZWN0aW9ucyxcbiAgICAgIGVudGlyZVRleHQ6IHN0cmluZyxcbiAgICB9KTtcblxuICAgIHN1YlNlbGVjdGlvbnMucHVzaChzdWJTZWxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHN1YlNlbGVjdGlvbnM7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBzZWFyY2ggc3RyaW5nIGFuZCBjcmVhdGUgYSByZWdleCBzZWFyY2ggc3RyaW5nIHRvIG1hdGNoIGEgd2hvbGUgd29yZFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIHN0cmluZyB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJucyB7UmVnRXhwfSByZWdleCBleHByZXNzaW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRSZWdleEZvcldvcmQgPSAoc3RyaW5nKSA9PiB7XG4gIGNvbnN0IFNUQVJUX1dPUkRfUkVHRVggPSAnKD88PVtcXFxccywuOjvigJxcIlxcJ+KAmCh7XXxeKSc7XG4gIGNvbnN0IEVORF9XT1JEX1JFR0VYID0gJyg/PVtcXFxccywuOjvigJxcIlxcJ+KAmCE/KX1dfCQpJztcbiAgY29uc3Qgc2VhcmNoID0gYCR7U1RBUlRfV09SRF9SRUdFWH0ke3N0cmluZ30ke0VORF9XT1JEX1JFR0VYfWA7XG4gIGNvbnN0IHJlZ2V4ID0geHJlKHNlYXJjaCwgJ3UnKTtcbiAgcmV0dXJuIHJlZ2V4O1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gLSBnZW5lcmF0ZXMgYSBzZWxlY3Rpb24gb2JqZWN0IGZyb20gdGhlIHNlbGVjdGVkIHRleHQsIHByZWNlZGluZ1RleHQgYW5kIHdob2xlIHRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RlZFRleHQgLSB0aGUgdGV4dCB0aGF0IGlzIHNlbGVjdGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlY2VkaW5nVGV4dCAtIHRoZSB0ZXh0IHRoYXQgcHJlc2NlZGVzIHRoZSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBlbnRpcmVUZXh0IC0gdGhlIHRleHQgdGhhdCB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBpblxuICogQHJldHVybiB7T2JqZWN0fSAtIHRoZSBzZWxlY3Rpb24gb2JqZWN0IHRvIGJlIHVzZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlU2VsZWN0aW9uID0gKHsgc2VsZWN0ZWRUZXh0LCBwcmVjZWRpbmdUZXh0LCBlbnRpcmVUZXh0IH0pID0+IHtcbiAgLy8gcmVwbGFjZSBtb3JlIHRoYW4gb25lIGNvbnRpZ3VvdXMgc3BhY2Ugd2l0aCBhIHNpbmdsZSBvbmUgc2luY2UgSFRNTC9zZWxlY3Rpb24gb25seSByZW5kZXJzIDFcbiAgY29uc3QgX2VudGlyZVRleHQgPSBub3JtYWxpemVTdHJpbmcoZW50aXJlVGV4dCk7XG4gIC8vIEdldHRpbmcgdGhlIG9jY3VycmVuY2VzIGJlZm9yZSB0aGUgY3VycmVudCB0b2tlblxuICBjb25zdCBwcmVjZWRpbmdUb2tlbnMgPSB0b2tlbml6ZXIocHJlY2VkaW5nVGV4dCk7XG4gIGxldCBwcmVjZWRpbmdPY2N1cnJlbmNlc0luUHJldmlvdXNTdHJpbmcgPSBwcmVjZWRpbmdUb2tlbnMucmVkdWNlKGZ1bmN0aW9uIChuLCB2YWwpIHtcbiAgICByZXR1cm4gbiArICh2YWwgPT09IHNlbGVjdGVkVGV4dCk7XG4gIH0sIDApO1xuICAvLyBjYWxjdWxhdGUgdGhpcyBvY2N1cnJlbmNlIG51bWJlciBieSBhZGRpbmcgaXQgdG8gdGhlIHByZWNlZGluZyBvbmVzXG4gIGxldCBvY2N1cnJlbmNlID0gcHJlY2VkaW5nT2NjdXJyZW5jZXNJblByZXZpb3VzU3RyaW5nICsgMTtcbiAgLy8gZ2V0IHRoZSB0b3RhbCBvY2N1cnJlbmNlcyBmcm9tIHRoZSB2ZXJzZVxuICBjb25zdCBhbGxUb2tlbnMgPSB0b2tlbml6ZXIoX2VudGlyZVRleHQpO1xuICBsZXQgYWxsT2NjdXJyZW5jZXMgPSBhbGxUb2tlbnMucmVkdWNlKGZ1bmN0aW9uIChuLCB2YWwpIHtcbiAgICByZXR1cm4gbiArICh2YWwgPT09IHNlbGVjdGVkVGV4dCk7XG4gIH0sIDApO1xuXG4gIHJldHVybiB7XG4gICAgdGV4dDogc2VsZWN0ZWRUZXh0LFxuICAgIG9jY3VycmVuY2U6IG9jY3VycmVuY2UsXG4gICAgb2NjdXJyZW5jZXM6IGFsbE9jY3VycmVuY2VzLFxuICB9O1xufTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQUFBLDJCQUFBLEdBQUFDLE9B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