"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jsonToUSFM = void 0;

var USFM = _interopRequireWildcard(require("./USFM"));

var _usfmToJson = require("./usfmToJson");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var params_ = {};
var wordMap_ = {};
var wordIgnore_ = [];
var milestoneMap_ = {};
var milestoneIgnore_ = [];
/**
 * @description checks if we need to add a newline if next object is not text or newline
 * @param {Object} nextObject - next object to be output
 * @return {String} either newline or empty string
 */

var needsNewLine = function needsNewLine(nextObject) {
  var retVal = '';

  if (nextObject && nextObject.tag === 'zaln') {
    retVal = '\n'; // prevent cramming of alignments together
  }

  return retVal;
};
/**
 * @description test if last character was newline (or return) char
 * @param {String} line - line to test
 * @return {boolean} true if newline
 */


var isLastCharNewLine = function isLastCharNewLine(line) {
  var lastChar = line ? line.substr(line.length - 1) : '';
  return lastChar === '\n';
};
/**
 * @description Takes in word json and outputs it as USFM.
 * @param {Object} wordObject - word in JSON
 * @param {Object} nextObject - next object to be output
 * @return {String} - word in USFM
 */


var generateWord = function generateWord(wordObject, nextObject) {
  var keys = Object.keys(wordObject);
  var attributes = [];
  var word = wordObject.text;

  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];

    if (!wordIgnore_.includes(key)) {
      var value = wordObject[key];

      if (wordMap_[key]) {
        // see if we should convert this key
        key = wordMap_[key];
      }

      var prefix = '';

      if (USFM.wordSpecialAttributes.includes(key)) {
        prefix = 'x-';
      }

      var attribute = prefix + key;

      if (value) {
        // add value only if set
        attribute += '="' + value + '"';
      }

      attributes.push(attribute);
    }
  }

  var attrOut = attributes.join(' ');

  if (attrOut) {
    attrOut = '|' + attrOut.trimLeft();
  }

  var line = '\\w ' + word + attrOut + '\\w*';
  return line;
};
/**
 * @description Takes in word json and outputs it as USFM.
 * @param {Object} phraseObject - word in JSON
 * @param {Object} nextObject - next object to be output
 * @return {String} - word in USFM
 */


var generatePhrase = function generatePhrase(phraseObject, nextObject) {
  var tag = phraseObject.tag || 'zaln';
  var markerTermination = '';

  if (typeof phraseObject.endTag === 'string') {
    markerTermination = phraseObject.endTag; // new format takes precidence

    delete phraseObject.endTag;
  } else {
    markerTermination = tag + '-e\\*'; // fall back to old generation method
  }

  var content = '';
  var milestoneType = phraseObject.type === 'milestone';

  if (milestoneType) {
    var keys = Object.keys(phraseObject);
    var attributes = [];

    for (var i = 0, len = keys.length; i < len; i++) {
      var key = keys[i];

      if (!milestoneIgnore_.includes(key)) {
        var value = phraseObject[key];

        if (milestoneMap_[key]) {
          // see if we should convert this key
          key = milestoneMap_[key];
        }

        var prefix = 'x-';
        var attribute = prefix + key + '="' + value + '"';
        attributes.push(attribute);
      }
    }

    content = '-s |' + attributes.join(' ').trimLeft() + '\\*';
  } else {
    var isUsfm3Milestone = USFM.markerIsMilestone(tag);

    if (isUsfm3Milestone) {
      if (phraseObject.attrib) {
        content = phraseObject.attrib;
      }

      content += "\\*";
    }

    if (phraseObject.text) {
      content += ' ' + phraseObject.text;
    }

    if (phraseObject.content) {
      content += ' ' + phraseObject.content;
    }
  }

  var line = '\\' + tag + content;
  /* eslint-disable no-use-before-define */

  line = objectToString(phraseObject.children, line);
  /* eslint-enable no-use-before-define */

  if (markerTermination) {
    line += '\\' + markerTermination + (phraseObject.nextChar || needsNewLine(nextObject));
  }

  return line;
};
/**
 * @description convert usfm marker to string
 * @param {object} usfmObject - usfm object to output
 * @param {object} nextObject - usfm object that will come next
 * @param {Boolean} noSpaceAfterTag - if true then do not put space after tag
 * @param {Boolean} noTermination - if true then do not add missing termination
 * @return {String} Text equivalent of marker.
 */


var usfmMarkerToString = function usfmMarkerToString(usfmObject) {
  var nextObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var noSpaceAfterTag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var noTermination = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var output = "";
  var content = usfmObject.text || usfmObject.content || "";
  var markerTermination = usfmObject.endTag; // new format takes precidence

  if (typeof markerTermination !== 'string' && USFM.markerTermination(usfmObject.tag) && !noTermination) {
    markerTermination = usfmObject.tag + '*'; // fall back to old generation method
  }

  if (usfmObject.tag) {
    output = '\\' + usfmObject.tag;

    if (usfmObject.number) {
      output += ' ' + usfmObject.number;
    }

    var firstChar = content.substr(0, 1);

    if (noSpaceAfterTag) {// no spacing
    } else if (usfmObject.attrib) {
      if (content) {
        output += ' ' + content;
      }

      if (usfmObject.tag.substr(-2) === '\\*') {
        // we need to apply attibute before \*
        output = output.substr(0, output.length - 2) + usfmObject.attrib + output.substr(-2);
      } else {
        output += usfmObject.attrib;
      }

      content = '';
    } else if (!markerTermination) {
      if (firstChar !== '' && firstChar !== '\n' && content !== ' \n') {
        // make sure some whitespace
        output += ' ';
      } else if (nextObject && usfmObject.tag && !content && // make sure some whitespace
      !usfmObject.nextChar && !['w', 'k', 'zaln'].includes(nextObject.tag)) {
        output += ' ';
      }
    } else if (firstChar !== ' ') {
      // if marker termination, make sure we have space
      output += ' ';
    }
  }

  if (content) {
    output += content;
  }

  if (markerTermination) {
    output += '\\' + markerTermination;
  }

  if (usfmObject.nextChar) {
    output += usfmObject.nextChar;
  }

  return output;
};
/**
 * determines if we are currently on a displayable line
 * @param {String} output - previous output
 * @return {boolean}
 */


var isOnDisplayableLine = function isOnDisplayableLine(output) {
  var isDisplayableLine = false;
  var pos = output.lastIndexOf('\\');

  if (pos >= 0) {
    var endSegment = output.substr(pos + 1);
    var parts = endSegment.split(' ');

    if (parts.length === 2 && parts[1] === '') {
      isDisplayableLine = USFM.markerDisplayable(parts[0]);
    }
  }

  return isDisplayableLine;
};
/**
 * @description adds word to the line and makes sure it has appropriate spacing
 * @param {String} text - to add
 * @param {String} output - string to add to
 * @return {String} updated output
 */


var addPhrase = function addPhrase(text, output) {
  var prefixNewLine = false;
  output = output || "";

  if (text) {
    prefixNewLine = false;
    var lastChar = output ? output.substr(output.length - 1) : '';

    if (params_.forcedNewLines) {
      if (lastChar === ' ') {
        if (!isOnDisplayableLine(output)) {
          output = output.substr(0, output.length - 1); // trim space

          prefixNewLine = true;
        }
      }
    }

    if (prefixNewLine) {
      text = '\n' + text;
    }

    output += text;
  }

  return output;
};
/**
 * check if text contains a paragraph marker.  Imprecise check just to save time before doing more extensive checking.
 * @param {string} text
 * @return {boolean}
 */


function hasParagraph(text) {
  var hasParagraph_ = false;

  if (text.includes('\\')) {
    // check if USFM markers in text
    var paragraphStarts = ['\\p', '\\m', '\\c', '\\n', '\\b'];

    for (var _i = 0, _paragraphStarts = paragraphStarts; _i < _paragraphStarts.length; _i++) {
      var mark = _paragraphStarts[_i];

      // check for paragraph markers
      if (text.includes(mark)) {
        hasParagraph_ = true;
        break;
      }
    }
  }

  return hasParagraph_;
}
/**
 * @description converts object to string and appends to line
 * @param {string|array|object} object - marker to print
 * @param {string} output - marker to print
 * @param {String|array|object} nextObject - optional object that is next entry.  Used to determine if we need to
 *                                add a space between current marker and following text
 * @return {String} Text equivalent of marker appended to output.
 */


var objectToString = function objectToString(object, output) {
  var nextObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!object || !Object.keys(object).length) {
    return output; // do not add to output
  }

  output = output || "";

  if (object.verseObjects) {
    // support new verse object format
    object = object.verseObjects;
  }

  if (Array.isArray(object)) {
    var _nextObject;

    for (var i = 0, len = object.length; i < len; i++) {
      var objectN = _nextObject ? _nextObject : object[i];
      _nextObject = i + 1 < object.length ? object[i + 1] : null;
      output = objectToString(objectN, output, _nextObject);
    }

    return output;
  }

  if (object.type === 'text') {
    var text = object.text || '';

    if (hasParagraph(text)) {
      // TODO: convert to JSON and back for clean up
      var verseObjects = (0, _usfmToJson.usfmToJSON)('\\v 1 ' + text, {
        chunk: true
      });
      var newText = jsonToUSFM(verseObjects).substr(5); // convert back to text and string out verse marker

      if (newText !== text) {
        console.log("text updated to ".concat(newText));
        text = newText;
      }
    }

    return output + text;
  }

  if (object.type === 'word') {
    // usfm word marker
    return addPhrase(generateWord(object, nextObject), output);
  }

  if (object.type === 'milestone' && object.endTag !== object.tag + '*') {
    // milestone type (phrase)
    return addPhrase(generatePhrase(object, nextObject), output);
  } else if (object.children && object.children.length) {
    return output + generatePhrase(object, nextObject);
  }

  if (object.type === 'paragraph') {
    var checkAhead = false; // if true need to check next object for leading text
    // paragraphs have no whitespace before a newline

    if (object.text) {
      if (object.text.endsWith('\n')) {
        var _text = object.text.substr(0, object.text.length - 1);

        object.text = "".concat(_text.trimRight(), "\n");
      } else if (object.text.trim() === '') {
        object.text = '';

        if (object.nextChar === ' ') {
          checkAhead = true;
        }
      }
    } else if (object.nextChar === ' ') {
      checkAhead = true;
    }

    if (checkAhead) {
      // if next is text object, trim leading spaces
      if (nextObject) {
        if (nextObject.type === 'text') {
          var _text2 = (nextObject.text || '').trimLeft();

          if (_text2) {
            nextObject.text = _text2;
          } else {
            // remove text object that is empty
            delete nextObject.text;
            delete nextObject.type;
            nextObject = null;
            delete object.nextChar;
          }
        }
      } else if (object.nextChar === ' ') {
        // if end of verse, remove space after paragraph
        delete object.nextChar;
      }
    }
  }

  if (object.tag) {
    // any other USFM marker tag
    return output + usfmMarkerToString(object, nextObject);
  }

  return output;
};
/**
 * @description Takes in verse json and outputs it as a USFM line array.
 * @param {String} verseNumber - number to use for the verse
 * @param {Array|Object} verseObjects - verse in JSON
 * @return {String} - verse in USFM
 */


var generateVerse = function generateVerse(verseNumber, verseObjects) {
  var verseText = objectToString(verseObjects);
  var object = {
    tag: 'v',
    number: verseNumber,
    text: verseText
  };
  return usfmMarkerToString(object);
};
/**
 * @description adds verse to lines array, makes sure there is a newline before verse
 * @param {Array} lines - array to add to
 * @param {String} verse - line to add
 * @return {Array} updated lines array
 */


var addVerse = function addVerse(lines, verse) {
  if (params_.forcedNewLines && lines && lines.length) {
    var lastLine = lines[lines.length - 1];

    if (!isLastCharNewLine(lastLine)) {
      // need to add newline
      var quoted = lastLine.indexOf('\n\\q') >= 0;

      if (!quoted) {
        // don't add newline before verse if quoted
        verse = '\n' + verse;
      }
    }
  }

  lines = lines.concat(verse);
  return lines;
};
/**
 * @description adds chapter to lines array, makes sure there is a newline before chapters
 * @param {Array} lines - array to add to
 * @param {Array} chapter - chapter lines to add
 * @return {Array} updated lines array
 */


var addChapter = function addChapter(lines, chapter) {
  if (lines && lines.length) {
    var lastLine = lines[lines.length - 1];

    if (!isLastCharNewLine(lastLine)) {
      // need to add newline
      if (chapter && chapter.length) {
        chapter[0] = '\n' + chapter[0]; // add newline to start of chapter
      }
    }
  }

  lines = lines.concat(chapter);
  return lines;
};
/**
 * get sorted list of verses. `front` will be first, the rest sorted alphabetically
 * @param {Array} verses - to sort
 * @return {string[]} sorted verses
 */


var sortVerses = function sortVerses(verses) {
  var sortedVerses = verses.sort(function (a, b) {
    var delta = parseInt(a, 10) - parseInt(b, 10);

    if (delta === 0) {
      // handle verse spans, unspanned verse first
      delta = a > b ? 1 : -1;
    }

    return delta;
  });
  return sortedVerses;
};
/**
 * get the last line and last character of that line
 * @param {Array} lines
 * @return {{lastLine: string, lastChar: string, position: number}} results
 */


function getLastLine(lines) {
  var position = lines.length - 1;
  var lastLine = lines.length ? lines[position] : "";
  var lastChar = lastLine ? lastLine.substr(lastLine.length - 1) : "";
  return {
    lastLine: lastLine,
    lastChar: lastChar,
    position: position
  };
}
/**
 * gets the last character of the last line and make sure it is a newline
 * @param {Array} lines
 */


function makeSureEndsWithNewLine(lines) {
  var _getLastLine = getLastLine(lines),
      lastChar = _getLastLine.lastChar,
      position = _getLastLine.position;

  if (lastChar && lastChar !== '\n') {
    // make sure newline at end
    lines[position] += '\n';
  }
}
/**
 * make sure paragraphs without text start a new line
 * @param {array} verseObjects
 * @param {array} lines
 */


function makeSureParagraphsAtEndHaveLineFeeds(verseObjects, lines) {
  if (verseObjects) {
    if (verseObjects.length > 0) {
      var lastPos = verseObjects.length - 1; // skip over empty objects

      while (lastPos > 0 && !Object.keys(verseObjects[lastPos]).length) {
        lastPos--;
      }

      var lastObject = verseObjects[lastPos];

      if (lastObject && lastObject.type === 'paragraph' && !(lastObject.text && lastObject.text.trim())) {
        makeSureEndsWithNewLine(lines);
      } else if (lastObject.children) {
        makeSureParagraphsAtEndHaveLineFeeds(lastObject.children, lines);
      }
    }
  }
}
/**
 * @description Takes in chapter json and outputs it as a USFM line array.
 * @param {String} chapterNumber - number to use for the chapter
 * @param {Object} chapterObject - chapter in JSON
 * @return {Array} - chapter in USFM lines/string
 */


var generateChapterLines = function generateChapterLines(chapterNumber, chapterObject) {
  var lines = [];
  lines.push('\\c ' + chapterNumber + '\n');

  if (chapterObject.front) {
    // handle front matter first
    var verseText = objectToString(chapterObject.front);
    lines = lines.concat(verseText);
    var frontVerseObjects = chapterObject.front;
    makeSureParagraphsAtEndHaveLineFeeds(frontVerseObjects.verseObjects, lines);
    delete chapterObject.front;
  }

  var verseNumbers = sortVerses(Object.keys(chapterObject));
  var verseLen = verseNumbers.length;

  for (var i = 0; i < verseLen; i++) {
    var verseNumber = verseNumbers[i]; // check if verse is inside previous line (such as \q)

    var _getLastLine2 = getLastLine(lines),
        lastLine = _getLastLine2.lastLine,
        lastChar = _getLastLine2.lastChar,
        position = _getLastLine2.position;

    if (lastChar && lastChar !== '\n' && lastChar !== ' ') {
      // do we need white space
      lines[position] = lastLine + ' ';
    }

    var verseObjects = chapterObject[verseNumber];
    var verseLine = generateVerse(verseNumber, verseObjects);
    lines = addVerse(lines, verseLine);
    makeSureParagraphsAtEndHaveLineFeeds(verseObjects.verseObjects, lines);
  }

  return lines;
};
/**
 * @description convert object to text and add to array.  Objects are terminated with newline
 * @param {array} output - array where text is appended
 * @param {Object} usfmObject - USFM object to convert to string
 */


var outputHeaderObject = function outputHeaderObject(output, usfmObject) {
  var noSpace = false;

  if (usfmObject.content) {
    var firstChar = usfmObject.content.substr(0, 1);
    noSpace = ['-', '*'].includes(firstChar) || usfmObject.content.substr(0, 2) === '\\*';
  }

  var text = usfmMarkerToString(usfmObject, null, noSpace, true);

  if (usfmObject.type === 'text' && typeof usfmObject.text === 'string') {
    text += '\n';
  } else if (usfmObject.tag) {
    text += '\n';
  }

  output.push(text);
};
/**
 * @description Goes through parameters and populates ignore lists and parameter maps
 *                for words and milestones
 */


var processParams = function processParams() {
  wordMap_ = params_.map ? params_.map : {};
  wordMap_.strongs = 'strong';
  wordIgnore_ = ['text', 'tag', 'type'];

  if (params_.ignore) {
    wordIgnore_ = wordIgnore_.concat(params_.ignore);
  }

  milestoneMap_ = params_.mileStoneMap ? params_.mileStoneMap : {};
  milestoneMap_.strongs = 'strong';
  milestoneIgnore_ = ['children', 'tag', 'type'];

  if (params_.mileStoneIgnore) {
    milestoneIgnore_ = milestoneIgnore_.concat(params_.mileStoneIgnore);
  }
};
/**
 * @description Takes in scripture json and outputs it as a USFM string.
 * @param {Object} json - Scripture in JSON
 * @param {Object} params - optional parameters like attributes to ignore.  Properties:
 *                    chunk {boolean} - if true then output is just a small piece of book
 *                    ignore (Array} - list of attributes to ignore on word objects
 *                    map {Object} - dictionary of attribute names to map to new name on word objects
 *                    mileStoneIgnore (Array} - list of attributes to ignore on milestone objects
 *                    mileStoneMap {Object} - dictionary of attribute names to map to new name on milestone objects
 *                    forcedNewLines (boolean} - if true then we add newlines before alignment tags, verses, words
 * @return {String} - Scripture in USFM
 */


var jsonToUSFM = function jsonToUSFM(json, params) {
  params_ = params || {}; // save current parameters

  processParams();
  var output = [];

  if (json.headers) {
    var _iterator = _createForOfIteratorHelper(json.headers),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var header = _step.value;
        outputHeaderObject(output, header);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  if (json.chapters) {
    var chapterNumbers = Object.keys(json.chapters);
    var chapterLen = chapterNumbers.length;

    for (var i = 0; i < chapterLen; i++) {
      var chapterNumber = chapterNumbers[i];
      var chapterObject = json.chapters[chapterNumber];
      var chapterLines = generateChapterLines(chapterNumber, chapterObject);
      output = addChapter(output, chapterLines);
    }
  }

  if (json.verses) {
    var verseNumbers = sortVerses(Object.keys(json.verses));
    var verseLen = verseNumbers.length;

    for (var _i2 = 0; _i2 < verseLen; _i2++) {
      var verseNumber = verseNumbers[_i2];
      var verseObjects = json.verses[verseNumber];
      var verse = generateVerse(verseNumber, verseObjects);
      output = addVerse(output, verse);
    }
  }

  return output.join('');
};

exports.jsonToUSFM = jsonToUSFM;