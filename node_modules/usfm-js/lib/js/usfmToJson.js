"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usfmToJSON = exports.getAlignmentFormat = exports.pushObject = exports.createUsfmObject = void 0;

var USFM = _interopRequireWildcard(require("./USFM"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable no-use-before-define,no-negated-condition,brace-style */

/**
 * @description for converting from USFM to json format.  Main method is usfmToJSON()
 */
var VERSE_SPAN_REGEX = /(^-\d+\s)/;
var NUMBER = /(\d+)/;
/**
 * @description - Finds all of the regex matches in a string
 * @param {String} string - the string to find matches in
 * @param {RegExp} regex - the RegExp to find matches with, must use global flag /.../g
 * @param {Boolean} lastLine - true if last line of file
 * @return {Array} - array of results
*/

var getMatches = function getMatches(string, regex, lastLine) {
  var matches = [];
  var match;

  if (string.match(regex)) {
    // check so you don't get caught in a loop
    while (match = regex.exec(string)) {
      // preserve white space
      var nextChar = null;
      var endPos = match.index + match[0].length;

      if (!lastLine && endPos >= string.length) {
        nextChar = "\n"; // save new line
      } else {
        var _char = string[endPos];

        if (_char === ' ') {
          nextChar = _char; // save space
        }
      }

      if (nextChar) {
        match.nextChar = nextChar;
      }

      matches.push(match);
    }
  }

  return matches;
};
/**
 * @description - Parses the marker that opens and describes content
 * @param {String} markerOpen - the string that contains the marker '\v 1', '\p', ...
 * @return {Object} - the object of tag and number if it exists
*/


var parseMarkerOpen = function parseMarkerOpen(markerOpen) {
  var object = {};

  if (markerOpen) {
    var regex = /(\+?\w+)\s*(\d*)/g;
    var matches = getMatches(markerOpen, regex, true);
    object = {
      tag: matches[0][1],
      number: matches[0][2]
    };
  }

  return object;
};
/**
 * @description - trim a leading space
 * @param {String} text - text to trim
 * @return {String} trimmed string
 */


var removeLeadingSpace = function removeLeadingSpace(text) {
  if (text && text.length > 1 && text[0] === " ") {
    text = text.substr(1);
  }

  return text;
};
/**
 * @description - Parses the word marker into word object
 * @param {object} state - holds parsing state information
 * @param {String} wordContent - the string to find the data/attributes
 * @param {null|Array} removePrefixOfX - array of attributes we want to remove the 'x-` prefix
 * @return {Object} - object of the word attributes
*/


var parseWord = function parseWord(state, wordContent) {
  var removePrefixOfX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var object = {};
  var wordParts = (wordContent || "").split('|');
  var word = removeLeadingSpace(wordParts[0]);
  var attributeContent = wordParts[1];
  object = {
    text: word,
    tag: 'w',
    type: 'word'
  };

  if (state.params["content-source"]) {
    object["content-source"] = state.params["content-source"];
  }

  if (attributeContent) {
    var regex = /([x-]*)([\w-]+)=['"](.*?)['"]/g;
    var matches = getMatches(attributeContent, regex, true);

    for (var i = 0, len = matches.length; i < len; i++) {
      var match = matches[i];
      var key = match[2];
      var xPrefix = match[1];

      if (xPrefix) {
        if (removePrefixOfX !== null && !removePrefixOfX.includes(key)) {
          // if this is not one of our attributes, leave the `x-` prefix
          key = xPrefix + key;
        }
      }

      if (key === "strongs" || key === "x-strong") {
        // fix invalid strong keys
        key = "strong";
      }

      if (state.params.map && state.params.map[key]) {
        // see if we should convert this key
        key = state.params.map[key];
      }

      var value = match[3];

      if (state.params.convertToInt && state.params.convertToInt.includes(key)) {
        value = parseInt(value, 10);
      }

      object[key] = value;
    }

    if (!matches.length) {
      object[attributeContent] = ""; // place holder for attribute with no value
    }
  }

  return object;
};
/**
 * @description - make a marker object that contains the text
 * @param {string} text - text to embed in object
 * @return {{content: *}} new text marker
 */


var makeTextMarker = function makeTextMarker(text) {
  return {
    content: text
  };
};
/**
 * @description create marker object from text
 * @param {String} text - text to put in marker
 * @return {object} new marker
 */


var createMarkerFromText = function createMarkerFromText(text) {
  return {
    open: text,
    tag: text
  };
};
/**
 * @description - Parses the line and determines what content is in it
 * @param {String} line - the string to find the markers and content
 * @param {Boolean} lastLine - true if last line of file
 * @return {Array} - array of objects that describe open/close and content
*/


var parseLine = function parseLine(line, lastLine) {
  var array = [];

  if (line.trim() === '') {
    if (!lastLine) {
      var object = makeTextMarker(line + '\n');
      array.push(object);
    }

    return array;
  }

  var regex = /([^\\]+)?\\(\+?\w+\s*\d*)(?!\w)\s*([^\\]+)?(\\\w\*)?/g;
  var matches = getMatches(line, regex, lastLine);

  if (matches.length && matches[0].index > 0) {
    // check for leading text
    var _object = makeTextMarker(line.substr(0, matches[0].index - 1));

    array.push(_object);
  }

  var lastObject = null;

  if (regex.exec(line)) {
    // normal formatting with marker followed by content
    for (var i = 0, len = matches.length; i < len; i++) {
      var match = matches[i];
      var orphan = match[1];

      if (orphan) {
        var _object3 = {
          content: orphan
        };
        array.push(_object3);
        match[0] = match[0].substr(orphan.length); // trim out orphan text

        match.index += orphan.length;
      }

      var open = match[2] ? match[2].trim() : undefined;
      var content = match[3] || undefined;
      var close = match[4] ? match[4].trim() : undefined;
      var marker = parseMarkerOpen(open);
      var _object2 = {
        open: open,
        tag: marker.tag,
        number: marker.number,
        content: content
      };
      var whiteSpaceInOpen = open !== match[2];

      if (whiteSpaceInOpen && !marker.number) {
        var shouldMatch = '\\' + open + (content ? ' ' + content : "");

        if (removeLeadingSpace(match[0]) !== shouldMatch) {
          // look for dropped inside white space
          var endMatch = match.index + match[0].length;
          var lineLength = line.length;
          var runToEnd = endMatch >= lineLength;
          var startPos = open.length + 2;
          var endPos = match[0].indexOf(match[3], startPos);

          if (endPos < 0) {
            if (!runToEnd) {
              if (match[0] === '\\' + match[2]) {
                _object2.nextChar = ' ';
              }
            } else {
              endPos = startPos;
              startPos--;
            }
          }

          var prefix = endPos >= 0 && match[0].substring(startPos, endPos);

          if (prefix) {
            _object2.content = prefix + (content || "");
          }
        }
      }

      if (marker.number && !USFM.markerSupportsNumbers(marker.tag)) {
        // this tag doesn't have number, move to content
        delete _object2.number;
        var newContent = void 0;
        var tagPos = match[0].indexOf(marker.tag);

        if (tagPos >= 0) {
          newContent = match[0].substr(tagPos + marker.tag.length + 1);
        } else {
          newContent = marker.number + ' ' + (content || "");
        }

        _object2.content = newContent;
      }

      if (close) {
        if (_object2.content) {
          var pos = _object2.content.lastIndexOf(close);

          if (pos >= 0) {
            _object2.content = _object2.content.substring(0, pos);
          }
        }

        array.push(_object2);
        var closeTag = close.substr(1);
        _object2 = createMarkerFromText(closeTag);
      }

      if (match.nextChar) {
        _object2.nextChar = match.nextChar;
      }

      array.push(_object2);
      lastObject = _object2;
    } // check for leftover text at end of line


    if (matches.length) {
      var lastMatch = matches[matches.length - 1];

      var _endPos = lastMatch.index + lastMatch[0].length;

      if (_endPos < line.length) {
        var orphanText = line.substr(_endPos) + (lastLine ? '' : '\n');

        if (lastObject && lastObject.nextChar && lastObject.nextChar === ' ') {
          orphanText = orphanText.substr(1); // remove first space since already handled
        }

        var _object4 = makeTextMarker(orphanText);

        array.push(_object4);
      }
    }
  } else {
    // doesn't have a marker but may have content
    // this is considered an orphaned line
    var _object5 = makeTextMarker(line + (lastLine ? '' : '\n'));

    array.push(_object5);
  }

  return array;
};
/**
 * get top phrase if doing phrase (milestone)
 * @param {object} state - holds parsing state information
 * @return {object} location to add to phrase or null
 */


var getLastPhrase = function getLastPhrase(state) {
  if (state.phrase && state.phrase.length > 0) {
    return state.phrase[state.phrase.length - 1];
  }

  return null;
};
/**
 * @description - get location for chapter/verse, if location doesn't exist, create it.
 * @param {object} state - holds parsing state information
 * @return {array} location to place verse content
 */


var getSaveToLocation = function getSaveToLocation(state) {
  var saveTo = state.headers;
  var phrase = getLastPhrase(state);

  if (phrase !== null) {
    saveTo = phrase;
  } else if (state.params.chunk) {
    if (state.currentVerse) {
      if (!state.verses[state.currentVerse]) {
        state.verses[state.currentVerse] = [];
      }

      saveTo = state.verses[state.currentVerse];
    }
  } else if (state.currentChapter) {
    if (!state.currentVerse) {
      state.currentVerse = 'front';
    }

    if (!state.chapters[state.currentChapter][state.currentVerse]) {
      state.chapters[state.currentChapter][state.currentVerse] = [];
    }

    saveTo = state.chapters[state.currentChapter][state.currentVerse];
  }

  return saveTo;
};
/**
 * @description - create a USFM object from marker
 * @param {object} marker - object that contains usfm marker
 * @param {boolean} noNext - if true, then ignore nextChar
 * @return {{tag: *}} USFM object
 */


var createUsfmObject = function createUsfmObject(marker) {
  var noNext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (typeof marker === 'string') {
    return {
      type: "text",
      text: marker
    };
  }

  var output = marker;
  var tag = marker.tag;
  var content = marker.content || marker.text;
  var tagProps = USFM.USFM_PROPERTIES[tag];
  var type = USFM.propType(tagProps);
  var isText = true;

  if (tag) {
    isText = USFM.propDisplayable(tagProps);

    if (type === 'milestone' && tag.indexOf('-s') < 0) {
      // verify that it actually is a milestone
      type = '';
    }

    if (type) {
      output.type = type;
    }
  } else {
    // default to text type
    output.type = "text";
  }

  if (marker.number) {
    if (!USFM.markerSupportsNumbers(tag)) {
      // handle rare case that parser places part of content as number
      var newContent = marker.number;

      if (content) {
        newContent += ' ' + content;
      }

      content = newContent;
      delete output.number;
    }
  } else {
    delete output.number;
  }

  if (noNext) {
    delete output.nextChar;
  } else if (marker.nextChar) {
    if (content) {
      content += marker.nextChar;
      delete output.nextChar;
    }
  }

  delete output.content;
  delete output.text;

  if (content) {
    output[isText ? 'text' : 'content'] = content;
  }

  delete output.open;
  delete output.close;
  return output;
};
/**
 * @description push usfm object to array, and concat strings of last array item is also string
 * @param {object} state - holds parsing state information
 * @param {array} saveTo - location to place verse content
 * @param {object|string} usfmObject - object that contains usfm marker, or could be raw text
 */


exports.createUsfmObject = createUsfmObject;

var pushObject = function pushObject(state, saveTo, usfmObject) {
  if (!Array.isArray(saveTo)) {
    var phrase = getLastPhrase(state);

    if (phrase === null) {
      var isNestedMarker = state.nested.length > 0;

      if (isNestedMarker) {
        // if this marker is nested in another marker, then we need to add to content as string
        var last = state.nested.length - 1;
        var contentKey = USFM.markerContentDisplayable(usfmObject.tag) ? 'text' : 'content';
        var lastObject = state.nested[last];
        var output = lastObject[contentKey];

        if (typeof usfmObject === "string") {
          output += usfmObject;
        } else {
          output += '\\' + usfmObject.tag;
          var content = usfmObject.text || usfmObject.content;

          if (content) {
            if (content[0] !== ' ') {
              output += ' ';
            }

            output += content;
          }
        }

        lastObject[contentKey] = output;
        return;
      }
    } else {
      saveTo = phrase;
    }
  }

  if (typeof usfmObject === "string") {
    // if raw text, convert to object
    if (usfmObject === '') {
      // skip empty strings
      return;
    }

    usfmObject = createUsfmObject(usfmObject);
  }

  saveTo = Array.isArray(saveTo) ? saveTo : getSaveToLocation(state);

  if (saveTo.length && usfmObject.type === "text") {
    // see if we can append to previous string
    var lastPos = saveTo.length - 1;
    var _lastObject = saveTo[lastPos];

    if (_lastObject.type === "text") {
      _lastObject.text += usfmObject.text;
      return;
    }
  }

  saveTo.push(usfmObject);
};
/**
 * @description test if last character was newline (or return) char
 * @param {String} line - line to test
 * @return {boolean} true if newline
 */


exports.pushObject = pushObject;

var isLastCharNewLine = function isLastCharNewLine(line) {
  var lastChar = line ? line.substr(line.length - 1) : '';
  var index = ['\n', '\r'].indexOf(lastChar);
  return index >= 0;
};
/**
 * @description test if next to last character is quote
 * @param {String} line - line to test
 * @return {boolean} true if newline
 */


var isNextToLastCharQuote = function isNextToLastCharQuote(line) {
  var nextToLastChar = line && line.length >= 2 ? line.substr(line.length - 2, 1) : '';
  var index = ["'", '"', '“'].indexOf(nextToLastChar);
  return index >= 0;
};

var isAlignmentMarker = function isAlignmentMarker(lastObject) {
  return lastObject && lastObject.tag && ["k", "w", "zaln"].includes(lastObject.tag);
};
/**
 * @description - see if two similar alignment markers crammed together
 * @param {object} lastObject - previous object
 * @param {String} currentTag - usfm tag of current marker.
 * @return {Boolean} - true if two similar markers crammed together
 */


var crammedMarkers = function crammedMarkers(lastObject, currentTag) {
  var crammed = lastObject && isAlignmentMarker(lastObject) && lastObject.tag === currentTag;
  return crammed;
};
/**
 * get last element of an array or null
 * @param {Array} array
 * @return {null|object}
 */


var getLast = function getLast(array) {
  if (Array.isArray(array) && array.length) {
    var lastItem = array[array.length - 1];
    return lastItem;
  }

  return null;
};
/**
 * @description - remove previous new line from text
 * @param {object} state - holds parsing state information
 * @param {String} currentTag - usfm tag of current marker.
 * @param {Boolean} endTag - if true then this is an end marker
 */


var removeLastNewLine = function removeLastNewLine(state) {
  var currentTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var endTag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var saveTo = getSaveToLocation(state);
  var replaceWithSpace = false;
  var lastObject = getLast(saveTo);

  if (lastObject) {
    if (lastObject.nextChar === '\n') {
      if (!state.newAlignFormat) {
        delete lastObject.nextChar;

        if (crammedMarkers(lastObject, currentTag)) {
          replaceWithSpace = true;
        }
      }
    } else if (lastObject.text) {
      var text = lastObject.text;

      if (isLastCharNewLine(text)) {
        if (text.length === 1) {
          saveTo.pop();
          lastObject = getLast(saveTo);
        } else {
          lastObject.text = text.substr(0, text.length - 1);

          if (!state.newAlignFormat && lastObject.text === ' ' && USFM.markerDisplayable(lastObject.tag)) {
            lastObject.nextChar = lastObject.text;
            delete lastObject.text;
          }
        }

        replaceWithSpace = state.newAlignFormat || !endTag && crammedMarkers(lastObject, currentTag);
      }
    }
  }

  if (replaceWithSpace) {
    pushObject(state, null, ' ');
  }
};
/**
 * @description - remove previous new line from text
 * @param {object} state - holds parsing state information
 */


var handleWordWhiteSpace = function handleWordWhiteSpace(state) {
  var saveTo = getSaveToLocation(state);

  if (saveTo && saveTo.length) {
    var lastObject = saveTo[saveTo.length - 1];

    if (lastObject.nextChar === '\n') {
      if (!state.newAlignFormat) {
        lastObject.nextChar = ' ';
      }
    } else if (lastObject.text) {
      var text = lastObject.text;

      if (isLastCharNewLine(text)) {
        var startOfLine = saveTo.length === 1 && lastObject.text.length === 1;
        var removeNewLine = startOfLine || isNextToLastCharQuote(text);

        if (state.newAlignFormat) {
          if (lastObject.type === "text") {
            lastObject.text = text.substr(0, text.length - 1) + ' ';
          }
        } else if (removeNewLine) {
          if (text.length === 1) {
            saveTo.pop();
          } else {
            lastObject.text = text.substr(0, text.length - 1);
          }
        } else {
          // replace newline with space
          lastObject.text = text.substr(0, text.length - 1) + ' ';
        }
      }
    }
  }
};
/**
 * @description normalize the numbers in string by removing leading '0'
 * @param {string} text - number string to normalize
 * @return {string} normalized number string
 */


var stripLeadingZeros = function stripLeadingZeros(text) {
  while (text.length > 1 && text[0] === '0') {
    text = text.substr(1);
  }

  return text;
};
/**
 * check if object is an end marker
 * @param {object} marker - object to check
 * @return {{endMarker: (null|string), spannedUsfm: (boolean)}} return new values
 */


var checkForEndMarker = function checkForEndMarker(marker) {
  var spannedUsfm = false;
  var endMarker = null;
  var content = marker.content || "";
  var initialTag = marker.tag;
  var baseTag = marker.tag;

  if (baseTag.substr(baseTag.length - 1) === "*") {
    baseTag = baseTag.substr(0, baseTag.length - 1);
    endMarker = marker.tag;
  } else if (content.substr(0, 1) === '-') {
    var nextChar = content.substr(1, 1);

    if (nextChar === 's' || nextChar === 'e') {
      var trim = 2;
      marker.tag += content.substr(0, 2);
      endMarker = nextChar === 'e' ? marker.tag : null;
      baseTag += '-s';
      content = content.substr(trim);
      marker.content = content;
    }
  } else if (content.substr(0, 1) === '*') {
    var _trim = 1;
    var space = '';

    if (content.substr(_trim, 1) === ' ') {
      _trim++;
      space = ' ';
    }

    marker.tag += content.substr(0, 1);
    endMarker = marker.tag;
    content = content.substr(_trim);

    if (content) {
      content += marker.nextChar || '';
      delete marker.nextChar;
    }

    if (space) {
      if (content) {
        marker.endMarkerChar = space;
      } else {
        marker.nextChar = space;
      }
    }

    marker.content = content;
  }

  if (endMarker) {
    spannedUsfm = true;
  } else {
    var tagProps = USFM.USFM_PROPERTIES[baseTag];

    if (USFM.propStandalone(tagProps)) {
      endMarker = marker.tag;
      spannedUsfm = true;
    } else {
      var termination = USFM.propTermination(tagProps);

      if (termination) {
        spannedUsfm = true;

        if (initialTag + termination === marker.tag) {
          endMarker = marker.tag;
        }
      }
    }
  }

  return {
    endMarker: endMarker,
    spannedUsfm: spannedUsfm
  };
};
/**
 * checks if we are currently within a phrase and if it is non-displayable
 * @param {object} state - holds parsing state information
 * @return {boolean} true if phrase parent is non-displayable (e.g. a footnote)
 */


var isNonDisplayablePhraseParent = function isNonDisplayablePhraseParent(state) {
  var phraseParent = getPhraseParent(state);

  if (phraseParent) {
    if (!USFM.markerContentDisplayable(phraseParent.tag)) {
      return true;
    }
  }

  return false;
};
/**
 * @description - save the usfm object to specified place and handle nested data
 * @param {object} state - holds parsing state information
 * @param {object} marker - object that contains usfm marker
 */


var saveUsfmObject = function saveUsfmObject(state, marker) {
  var phraseParent = getPhraseParent(state);

  if (phraseParent) {
    if (!USFM.markerContentDisplayable(phraseParent.tag)) {
      var objectText = typeof marker === 'string' ? marker : markerToText(marker);
      phraseParent.content = (phraseParent.content || "") + objectText;
    } else if (phraseParent.attrib && !phraseParent.usfm3Milestone && typeof marker === 'string') {
      phraseParent.attrib += marker;
    } else {
      var saveTo = getLastPhrase(state);
      var usfmObject_ = createUsfmObject(marker);
      saveTo.push(usfmObject_);
    }
  } else if (state.nested.length > 0) {
    // is nested object
    pushObject(state, null, marker);
  } else {
    // not nested
    var _saveTo = getSaveToLocation(state);

    _saveTo.push(marker);
  }
};
/**
 * keeps nesting count if of same type
 * @param {object} state - holds parsing state information
 * @param {object} phraseParent - object adding to
 * @param {string} tag - tag for verseObject
 * @return {boolean} true if match
 */


var incrementPhraseNesting = function incrementPhraseNesting(state, phraseParent, tag) {
  if (phraseParent && phraseParent.tag === tag) {
    if (!phraseParent.nesting) {
      phraseParent.nesting = 0;
    }

    phraseParent.nesting++;
    return true;
  }

  return false;
};
/**
 * keeps nesting count if of same type
 * @param {object} state - holds parsing state information
 * @param {object} phraseParent - object adding to
 * @param {string} endTag - tag for verseObject
 * @return {{matchesParent: (boolean), count: (number)}} return new values
 */


var decrementPhraseNesting = function decrementPhraseNesting(state, phraseParent, endTag) {
  var matchesParent = false;
  var parts = endTag.split(' ');
  var endTagBase = parts[0] + (parts.length > 1 ? '\\*' : ''); // remove attributes

  var count = -1;

  if (phraseParent) {
    var terminations = USFM.markerTermination(phraseParent.tag);

    if (!terminations) {
      terminations = [];
    }

    if (terminations && !Array.isArray(terminations)) {
      terminations = [terminations];
    }

    var termination = null;

    for (var i = 0, len = terminations.length; i < len; i++) {
      termination = terminations[i];

      if (termination) {
        matchesParent = termination === endTagBase || phraseParent.tag + termination === endTagBase || phraseParent.tag.substr(0, phraseParent.tag.length - 2) + termination + '\\*' === endTagBase;

        if (matchesParent) {
          break;
        }
      }
    }

    if (!matchesParent && USFM.SPECIAL_END_TAGS[endTagBase] === phraseParent.tag) {
      matchesParent = true;
    }

    if (matchesParent) {
      count = phraseParent.nesting || 0;

      if (count) {
        phraseParent.nesting = --count;
      }

      if (!count) {
        delete phraseParent.nesting;
      }

      delete phraseParent.usfm3Milestone;
    }
  }

  return {
    matchesParent: matchesParent,
    count: count
  };
};
/**
 * get the last item that was saved
 * @param {object} state - holds parsing state information
 * @return {Object} last item
 */


var getLastItem = function getLastItem(state) {
  var last = getSaveToLocation(state);

  if (last && last.length) {
    last = last[last.length - 1];
  }

  return last;
};

var getToEndOfAttributes = function getToEndOfAttributes(content, pos, index, markers) {
  var endPos = content.indexOf('*', pos);

  while (endPos < 0) {
    // if attributes overflow to next line
    var nextLine = index + 1;

    if (nextLine >= markers.length) {
      break;
    }

    var nextMarker = markers[nextLine];

    if (!nextMarker.tag && nextMarker.content) {
      endPos = nextMarker.content.indexOf('*');

      if (endPos === 0) {
        // attributes are ended
        break;
      } else if (endPos < 0) {
        content += nextMarker.content;
        index = nextLine;
        endPos = content.indexOf('*', pos);
      } else {
        var nextContent = nextMarker.content.substr(endPos);

        if (nextMarker.content[endPos - 1] === '\\') {
          endPos--;
        }

        if (endPos > 0) {
          content += nextMarker.content.substr(0, endPos);
          nextMarker.content = nextContent;
        }

        break;
      }
    } else {
      break;
    }
  }

  return {
    content: content,
    index: index
  };
};
/**
 * mark the beginning of a spanned usfm
 * @param {object} state - holds parsing state information
 * @param {object} marker - verseObject to save
 * @param {string} tag - tag for verseObject
 * @param {number} index - current position in markers
 * @param {array} markers - parsed markers we are iterating through
 * @return {number} new index
 */


var startSpan = function startSpan(state, marker, tag, index, markers) {
  marker.tag = tag;
  var phraseParent = getPhraseParent(state);
  var tagProps = USFM.USFM_PROPERTIES[tag];
  var displayable = USFM.propDisplayable(tagProps);

  if (USFM.propUsfm3Milestone(tagProps)) {
    marker.usfm3Milestone = true;
  }

  if (USFM.propAttributes(tagProps)) {
    var contentKey = USFM.propDisplayable(tagProps) ? 'text' : 'content';
    var content = marker[contentKey];

    if (content) {
      var pos = content.indexOf('|');

      if (pos >= 0) {
        var __ret = getToEndOfAttributes(content, pos, index, markers);

        content = __ret.content;
        index = __ret.index;
        var foundContent = content.substr(0, pos).trim();

        if (!foundContent) {
          pos = 0;
        }

        marker.attrib = content.substr(pos);
        content = content.substr(0, pos);
      }

      if (content) {
        marker[contentKey] = content;
      }
    }

    if (!content) {
      delete marker[contentKey];
    }
  }

  if (phraseParent) {
    if (!USFM.markerContentDisplayable(phraseParent.tag)) {
      phraseParent.content = (phraseParent.content || "") + markerToText(marker);
      incrementPhraseNesting(state, phraseParent, tag);
      return index;
    }
  }

  if (displayable) {
    // we need to nest
    pushObject(state, null, marker);

    if (state.phrase === null) {
      state.phrase = []; // create new phrase stack

      state.phraseParent = marker;
    }

    state.phrase.push([]); // push new empty list onto phrase stack

    marker.children = getLastPhrase(state); // point to top of phrase stack
  } else {
    saveUsfmObject(state, marker);

    if (state.phrase === null) {
      state.phraseParent = getLastItem(state);
    }

    incrementPhraseNesting(state, marker, tag);
  }

  return index;
};
/**
 * get parent of current phrase
 * @param {object} state - holds parsing state information
 * @return {Object} parent
 */


var getPhraseParent = function getPhraseParent(state) {
  var parent = null;

  if (state.phrase !== null && state.phrase.length > 1) {
    parent = state.phrase[state.phrase.length - 2];
  }

  if (parent) {
    if (parent.length > 0) {
      parent = parent[parent.length - 1]; // get last in array
    } else {
      parent = null;
    }
  }

  if (!parent) {
    parent = state.phraseParent;
  }

  return parent;
};
/**
 * pop and return last phrase
 * @param {object} state - holds parsing state information
 * @return {object} last phrase
 */


var popPhrase = function popPhrase(state) {
  var last = null;

  if (state.phrase && state.phrase.length > 0) {
    state.phrase.pop(); // remove last phrases

    if (state.phrase.length <= 0) {
      state.phrase = null; // stop adding to phrases

      last = state.phraseParent;
      state.phraseParent = null;
    } else {
      last = getPhraseParent(state);
    }
  } else {
    state.phraseParent = null;
  }

  return last;
};
/**
 * end a spanned usfm
 * @param {object} state - holds parsing state information
 * @param {number} index - current position in markers
 * @param {array} markers - parsed markers we are iterating through
 * @param {string} endMarker - end marker for phrase
 * @param {boolean} header - if true then saving to header
 * @return {number} new index
 */


var endSpan = function endSpan(state, index, markers, endMarker) {
  var header = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var current = markers[index];
  var content = current.content;
  var phraseParent = getPhraseParent(state);
  var phraseParentProps = phraseParent && USFM.USFM_PROPERTIES[phraseParent.tag] || null;
  var parentContentDisplayable = USFM.propDisplayable(phraseParentProps);

  if (endMarker && USFM.propUsfm3Milestone(phraseParentProps)) {
    endMarker += "\\*";
  }

  if (!phraseParent || parentContentDisplayable) {
    popPhrase(state);

    if (phraseParent && endMarker) {
      if (phraseParent.children !== undefined && !phraseParent.children.length) {
        delete phraseParent.children; // remove unneeded empty children
      }

      while (phraseParent) {
        var tagBase = phraseParent.tag.split('-')[0];

        if (tagBase + '*' === endMarker || tagBase + '-e\\*' === endMarker) {
          // if this is the parent end
          phraseParent.endTag = endMarker;
          break;
        } else {
          phraseParent.endTag = "";
          phraseParent = getPhraseParent(state); // pop next

          popPhrase(state);
        }
      }
    }
  }

  var checkNext = USFM.markerStandalone(current.tag);
  var trimLength = 0;

  if (content) {
    var next = content[0];

    if (['\\', '-', '*'].includes(next)) {
      if (next === "*") {
        // check if content is part of milestone end
        trimLength = 1;
      } else if (content.substr(0, 2) === "\\*") {
        // check if content is part of milestone end
        trimLength = 2;
      } else if (content.substr(0, 4) === "-e\\*") {
        // check if content marker is part of milestone end
        trimLength = 4;
      } else if (content.substr(0, 3) === "-e*") {
        // check if content marker is part of milestone end
        trimLength = 3;
      } else if (content === "-e") {
        // check if content + next marker is part of milestone end
        trimLength = 2;
        checkNext = true;
      }

      if (trimLength) {
        if (content.substr(trimLength, 1) === '\n') {
          trimLength++;
        }

        content = content.substr(trimLength); // remove phrase end marker
      }
    }
  }

  if (content && USFM.markerHasEndAttributes(current.tag)) {
    if (phraseParent) {
      var parts = (phraseParent.endTag || "").split('\\*');
      endMarker = parts[0] + content + (parts.length > 1 ? '\\*' : '');
      phraseParent.endTag = endMarker;
      current.content = content = "";
    } else {
      current.attrib = content;
      current.content = content = "";
    }
  }

  var terminator = null;

  if (checkNext || !content && !current.nextChar && endMarker) {
    trimLength = 0;

    if (index + 1 < markers.length) {
      var nextItem = markers[index + 1];

      if (!nextItem.tag) {
        var nextContent = nextItem.content || '';

        if (nextContent.substr(0, 1) === "*") {
          // check if content is part of milestone end
          trimLength = 1;
        } else if (nextContent.substr(0, 2) === "\\*") {
          // check if content is part of milestone end
          trimLength = 2;
        }

        terminator = nextContent.substr(0, trimLength);

        if (current.attrib) {
          if (terminator.substr(0, 1) === '\\') {
            terminator = terminator.substr(1);
          }

          current.endTag = terminator;
        } else {
          if (!endMarker.includes(terminator)) {
            endMarker += terminator;
          }

          current.tag = endMarker;
        }

        var nextChar = nextContent.substr(trimLength, 1);

        if (nextChar === ' ' || nextChar === '\n') {
          if (!phraseParent) {
            trimLength++;
            current.nextChar = nextChar;
          }
        }

        if (trimLength) {
          content = '';
          nextContent = nextContent.substr(trimLength);
          nextItem.content = nextContent;
        }

        if (!nextContent) {
          index++;
        }
      }
    }
  }

  if (current && current.nextChar) {
    if (content) {
      content += current.nextChar;
      delete current.nextChar;
    }
  }

  if (phraseParent) {
    var endMarker_ = "\\" + endMarker;

    var _decrementPhraseNesti = decrementPhraseNesting(state, phraseParent, endMarker),
        matchesParent = _decrementPhraseNesti.matchesParent,
        count = _decrementPhraseNesti.count;

    var finishPhrase = matchesParent && count <= 0;

    if (!parentContentDisplayable) {
      var _nextChar = current && current.nextChar || '';

      if (content && _nextChar) {
        content += _nextChar;
        _nextChar = '';
      }

      _nextChar += current && current.endMarkerChar || '';

      if (!finishPhrase) {
        phraseParent.content = (phraseParent.content || "") + endMarker_ + _nextChar;
      } else {
        phraseParent.endTag = endMarker;

        if (_nextChar) {
          phraseParent.nextChar = _nextChar;
        }

        popPhrase(state);
      }
    } else if (finishPhrase) {
      // parent displayable and this finishes
      phraseParent.endTag = endMarker;

      var _nextChar2 = current && (current.nextChar || current.endMarkerChar);

      if (_nextChar2) {
        if (parentContentDisplayable) {
          content = _nextChar2 + (content || "");
        } else {
          phraseParent.nextChar = _nextChar2;
        }
      }
    }
  } else {
    // no parent, so will save end marker
    content = current;
  }

  if (content || !phraseParent) {
    saveUsfmObject(state, createUsfmObject(content, header));
  }

  return index;
};
/**
 * @description - adds usfm object to current verse and handles nested USFM objects
 * @param {object} state - holds parsing state information
 * @param {object} marker - object that contains usfm marker
 */


var addToCurrentVerse = function addToCurrentVerse(state, marker) {
  var tag = marker.tag;

  if (!tag) {
    pushObject(state, null, createUsfmObject(marker));
    return;
  }

  saveUsfmObject(state, createUsfmObject(marker));
};
/**
 * makes sure that phrases are terminated before we begin a new verse or chapter
 * @param {object} state - holds parsing state information
 */


var terminatePhrases = function terminatePhrases(state) {
  var phraseParent = getPhraseParent(state);

  while (phraseParent) {
    phraseParent.endTag = '';
    delete phraseParent.nesting;
    delete phraseParent.usfm3Milestone;
    phraseParent = popPhrase(state);
  }
};
/**
 * @description - process marker as a verse
 * @param {object} state - holds parsing state information
 * @param {object} marker - marker object containing content
 */


var parseAsVerse = function parseAsVerse(state, marker) {
  state.inHeader = false;
  terminatePhrases(state);
  state.nested = [];
  marker.content = marker.content || "";

  if (marker.nextChar === "\n") {
    marker.content += marker.nextChar;
  }

  state.currentVerse = stripLeadingZeros(marker.number); // check for verse span

  var spanMatch = VERSE_SPAN_REGEX.exec(marker.content);

  if (spanMatch) {
    state.currentVerse += spanMatch[0][0] + stripLeadingZeros(spanMatch[0].substr(1).trim());
    marker.content = marker.content.substr(spanMatch[0].length);
  }

  if (state.params.chunk && !state.onSameChapter) {
    if (state.verses[state.currentVerse]) {
      state.onSameChapter = true;
    } else {
      state.verses[state.currentVerse] = [];
      pushObject(state, null, marker.content);
    }
  } else if (state.chapters[state.currentChapter] && !state.onSameChapter) {
    // if the current chapter exists, not on same chapter, and there is content to store
    if (state.chapters[state.currentChapter][state.currentVerse]) {
      // If the verse already exists, then we are flagging as 'on the same chapter'
      state.onSameChapter = true;
    } else {
      pushObject(state, null, marker.content);
    }
  }
};
/**
 * @description - process marker as text
 * @param {object} state - holds parsing state information
 * @param {object} marker - marker object containing content
 */


var processAsText = function processAsText(state, marker) {
  if (state.currentChapter > 0 && marker.content) {
    if (getPhraseParent(state)) {
      saveUsfmObject(state, marker.content);
    } else {
      addToCurrentVerse(state, marker.content);
    }
  } else if (state.currentChapter === 0 && !state.currentVerse) {
    // if we haven't seen chapter yet, its a header
    pushObject(state, state.headers, createUsfmObject(marker));
  }

  if (state.params.chunk && state.currentVerse > 0 && marker.content) {
    if (!state.verses[state.currentVerse]) {
      state.verses[state.currentVerse] = [];
    }

    if (getPhraseParent(state)) {
      saveUsfmObject(state, marker.content);
    } else {
      pushObject(state, state.verses[state.currentVerse], marker.content);
    }
  }
};

var addTextField = function addTextField(text) {
  var results = "";

  if (text) {
    results = ' ' + text;
  }

  return results;
};
/**
 * @description - convert marker to text
 * @param {object} marker - object to convert to text
 * @param {boolean} noSpaceAfterTag - if true then don't add space after tag
 * @return {string} text representation of marker
 */


var markerToText = function markerToText(marker) {
  var noSpaceAfterTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!marker.tag) {
    return marker.text || marker.content;
  }

  var text = '\\' + marker.tag;

  if (marker.number) {
    text += " " + marker.number;
  }

  var content = marker.content || marker.text;

  if (noSpaceAfterTag) {
    text += content;
  } else {
    text += addTextField(content);
  }

  if (marker.attrib) {
    var dashPos = marker.tag.indexOf('-');
    var suffix = dashPos > 0 ? marker.tag.substr(dashPos + 1, 1) : '';
    var spannedTag = ['s', 'e'].includes(suffix);

    if (!content && (!suffix || !spannedTag)) {
      text += ' ';
    }

    text += marker.attrib;

    if (spannedTag) {
      text += '\\';
    }
  }

  if (marker.nextChar) {
    text += marker.nextChar;
  }

  return text;
};
/**
 * @description - process marker as a chapter
 * @param {object} state - holds parsing state information
 * @param {object} marker - marker object containing content
 */


var processAsChapter = function processAsChapter(state, marker) {
  state.inHeader = false;
  terminatePhrases(state);
  state.nested = [];
  state.currentChapter = stripLeadingZeros(marker.number);
  state.chapters[state.currentChapter] = {}; // resetting 'on same chapter' flag

  state.onSameChapter = false;
  state.currentVerse = 0;
};
/**
 * @description - see if verse number in content
 * @param {object} marker - marker object containing content
 */


var extractNumberFromContent = function extractNumberFromContent(marker) {
  var numberMatch = NUMBER.exec(marker.content);

  if (numberMatch) {
    marker.number = numberMatch[0];
    marker.content = marker.content.substr(numberMatch.length);
  }
};

var getVerseObjectsForChapter = function getVerseObjectsForChapter(currentChapter) {
  var outputChapter = {};

  for (var _i = 0, _Object$keys = Object.keys(currentChapter); _i < _Object$keys.length; _i++) {
    var verseNum = _Object$keys[_i];
    var verseObjects = currentChapter[verseNum];
    outputChapter[verseNum] = {
      verseObjects: verseObjects
    };
  }

  return outputChapter;
};

var getVerseObjectsForBook = function getVerseObjectsForBook(usfmJSON, state) {
  usfmJSON.chapters = {};

  for (var _i2 = 0, _Object$keys2 = Object.keys(state.chapters); _i2 < _Object$keys2.length; _i2++) {
    var chapterNum = _Object$keys2[_i2];
    var currentChapter = state.chapters[chapterNum];
    usfmJSON.chapters[chapterNum] = getVerseObjectsForChapter(currentChapter);
  }
};
/**
 * add marker to header
 * @param {object} state - holds parsing state information
 * @param {object} marker - marker object containing content
 */


var addHeaderMarker = function addHeaderMarker(state, marker) {
  var nextChar = marker.nextChar; // save nextChar

  var usfmObject = createUsfmObject(marker, true);

  if (nextChar !== undefined) {
    usfmObject.nextChar = nextChar; // add back in
  }

  var lastHeader = state.headers.length ? state.headers[state.headers.length - 1] : null;
  var lastNext = lastHeader ? lastHeader.nextChar : null;
  var appendToLast = lastHeader && lastNext !== '\n';

  if (appendToLast) {
    var markerContent = marker.content || marker.text || '';
    var noSpaceAfterTag = markerContent.substr(0, 1) === '*'; // special handling for end tags

    var key = lastHeader.text ? 'text' : 'content';
    var content = (lastHeader[key] || '') + (lastHeader.next || '') + markerToText(marker, noSpaceAfterTag);
    delete lastHeader.next;

    if (content.substr(-1) === '\n') {
      lastHeader.nextChar = '\n';
      content = content.substr(0, content.length - 1); // trim off
    }

    lastHeader[key] = content;
  } else {
    if (usfmObject.text && !usfmObject.nextChar && usfmObject.text.substr(-1) === '\n') {
      usfmObject.nextChar = '\n';
      usfmObject.text = usfmObject.text.substr(0, usfmObject.text.length - 1); // trim off
    }

    state.headers.push(usfmObject);
  }
};
/**
 * processes the marker checking for spans
 * @param {object} state - holds parsing state information
 * @param {object} marker - marker object containing content
 * @param {Number} i - current index in markers
 * @param {Array} markers - array of parsed markers
 * @return {Number} new index in markers
 */


var processMarkerForSpans = function processMarkerForSpans(state, marker, i, markers) {
  var _checkForEndMarker = checkForEndMarker(marker),
      endMarker = _checkForEndMarker.endMarker,
      spannedUsfm = _checkForEndMarker.spannedUsfm;

  if (!endMarker && USFM.markerHasSpecialEndTag(marker.tag)) {
    // check for one-off end markers
    var startMarker = USFM.markerHasSpecialEndTag(marker.tag);
    endMarker = marker.tag;
    marker.tag = startMarker;
    spannedUsfm = true;
  }

  if (endMarker) {
    // check for end marker
    if (spannedUsfm) {
      i = endSpan(state, i, markers, endMarker, state.inHeader);
    }
  } else if (spannedUsfm) {
    i = startSpan(state, createUsfmObject(marker), marker.tag, i, markers);
  } else {
    addToCurrentVerse(state, marker);
  }

  return i;
};
/**
 * clean of trailing newlines in headers since it is implicit
 * @param {object} state - holds parsing state information
 */


var cleanupHeaderNewLines = function cleanupHeaderNewLines(state) {
  for (var i = 0; i < state.headers.length; i++) {
    var header = state.headers[i];

    if (header.type === 'text') {
      header.text += header.nextChar || '';

      while (i + 1 < state.headers.length) {
        var headerNext = i + 1 < state.headers.length ? state.headers[i + 1] : {};

        if (headerNext.type === 'text') {
          header.text += headerNext.text + (headerNext.nextChar || '');
          state.headers.splice(i + 1, 1);
        } else {
          break;
        }
      }

      if (header.text.substr(-1) === '\n') {
        header.text = header.text.substr(0, header.text.length - 1);
      }
    }

    if (header && header.nextChar === '\n') {
      delete header.nextChar;
    }
  }
};
/**
 * process this as a general marker
 * @param {object} state - holds parsing state information
 * @param {Object} marker - current marker
 * @param {Number} index - current marker index
 * @param {Array} markers - array of all markers
 * @return {Number} updated index
 */


var processMarker = function processMarker(state, marker, index, markers) {
  if (state.currentChapter === 0 && !state.currentVerse) {
    // if we haven't seen chapter or verse yet, its a header
    state.inHeader = true;
    addHeaderMarker(state, marker);
  } else if (state.currentChapter || state.params.chunk && state.currentVerse) {
    index = processMarkerForSpans(state, marker, index, markers);
  }

  return index;
};
/**
 * find the Alignment Format level in content
 * @param {String} usfm - the raw usfm string
 * @param {object} state - holds parsing state information
 */


var getAlignmentFormat = function getAlignmentFormat(usfm, state) {
  var newAlignFormat = false;
  var alignmentRegex = /\\zaln-s([^\\]*)(\\[\\*]?)?/;
  var match = alignmentRegex.exec(usfm);

  if (!match) {
    // if no alignment markers, check for tWords markers
    var tWordsRegex = /\\k-s([^\\]*)(\\[\\*]?)?/;
    match = tWordsRegex.exec(usfm);
  }

  if (match && match[2]) {
    newAlignFormat = match[2] === "\\*";
  }

  state.newAlignFormat = newAlignFormat;
};
/**
 * check if first character is BOM, and if so then remove it
 * @param {string} text
 * @return {string}
 */


exports.getAlignmentFormat = getAlignmentFormat;

function removeBOM(text) {
  var firstChar = text[0];
  var BOM = "\uFEFF";
  var BOM2 = "\uFFFE";

  if (firstChar === BOM || firstChar === BOM2) {
    text = text.substr(1);
  }

  return text;
}
/**
 * @description - Parses the usfm string and returns an object
 * @param {String} usfm - the raw usfm string
 * @param {Object} params - extra params to use for chunk parsing. Properties:
 *                    chunk {boolean} - if true then output is just a small piece of book
 *                    content-source {String} - content source attribute to add to word imports
 *                    convertToInt {Array} - attributes to convert to integer
 * @return {Object} - json object that holds the parsed usfm data, headers and chapters
*/


var usfmToJSON = function usfmToJSON(usfm) {
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  usfm = removeBOM(usfm);
  var lines = usfm.split(/\r?\n/); // get all the lines

  var usfmJSON = {};
  var markers = [];
  var lastLine = lines.length - 1;

  for (var l = 0; l < lines.length; l++) {
    var parsedLine = parseLine(lines[l], l >= lastLine);
    markers.push.apply(markers, parsedLine); // fast concat
  }

  var state = {
    currentChapter: 0,
    currentVerse: 0,
    chapters: {},
    verses: {},
    headers: [],
    nested: [],
    phrase: null,
    phraseParent: null,
    onSameChapter: false,
    inHeader: true,
    newAlignFormat: false,
    params: params
  };
  getAlignmentFormat(usfm, state);

  for (var i = 0; i < markers.length; i++) {
    var marker = markers[i];

    switch (marker.tag) {
      case 'c':
        {
          // chapter
          if (!marker.number && marker.content) {
            // if no number, try to find in content
            extractNumberFromContent(marker);
          }

          if (marker.number) {
            processAsChapter(state, marker);
          } else {
            // no chapter number, add as text
            marker.content = markerToText(marker);
            processAsText(state, marker);
          }

          break;
        }

      case 'v':
        {
          // verse
          if (!marker.number && marker.content) {
            // if no number, try to find in content
            extractNumberFromContent(marker);
          }

          if (marker.number) {
            parseAsVerse(state, marker);
          } else {
            // no verse number, add as text
            marker.content = markerToText(marker);
            processAsText(state, marker);
          }

          break;
        }

      case 'k':
      case 'zaln':
        {
          // phrase
          if (state.inHeader) {
            addHeaderMarker(state, marker);
          } else {
            var phrase = parseWord(state, marker.content); // very similar to word marker, so start with this and modify

            phrase.type = "milestone";
            var milestone = phrase.text.trim();

            if (milestone === '-s') {
              // milestone start
              removeLastNewLine(state, marker.tag);
              delete phrase.text;
              i = startSpan(state, phrase, marker.tag, i, markers);
            } else if (milestone === '-e') {
              // milestone end
              removeLastNewLine(state, marker.tag, true);
              i = endSpan(state, i, markers, marker.tag + "-e\\*");
            } else {
              i = processMarkerForSpans(state, marker, i, markers); // process as regular marker
            }
          }

          break;
        }

      case 'w':
        {
          // word
          if (state.inHeader) {
            addHeaderMarker(state, marker);
          } else {
            handleWordWhiteSpace(state);
            var wordObject = parseWord(state, marker.content, USFM.wordSpecialAttributes);

            if (isNonDisplayablePhraseParent(state)) {
              saveUsfmObject(state, marker);
            } else {
              pushObject(state, null, wordObject);

              if (marker.nextChar) {
                pushObject(state, null, marker.nextChar);
              }
            }
          }

          break;
        }

      case 'w*':
        {
          if (state.inHeader) {
            addHeaderMarker(state, marker);
          } else {
            if (isNonDisplayablePhraseParent(state)) {
              saveUsfmObject(state, marker);
            } else if (marker.nextChar && marker.nextChar !== ' ') {
              pushObject(state, null, marker.nextChar);
            } else if (marker.nextChar) {
              // next char is space
              var nextMarker = markers[i + 1];

              if (nextMarker && !nextMarker.tag && nextMarker.content && nextMarker.content[0] !== ' ') {
                // see if space is not part of following text block
                pushObject(state, null, marker.nextChar);
              }
            }
          }

          break;
        }

      case undefined:
        {
          // likely orphaned text for the preceding verse marker
          if (marker) {
            if (state.inHeader) {
              addHeaderMarker(state, marker);
            } else if (marker.content && marker.content.substr(0, 2) === "\\*") {
              // is part of usfm3 milestone marker
              marker.content = marker.content.substr(2);
            } else if (marker.content && marker.content.substr(0, 1) === "*") {
              var phraseParent = getPhraseParent(state);

              if (phraseParent && (phraseParent.usfm3Milestone || isAlignmentMarker(phraseParent))) {
                // is part of usfm3 milestone marker
                marker.content = marker.content.substr(1);
              }
            }

            if (marker.content) {
              processAsText(state, marker);
            }
          }

          break;
        }

      default:
        {
          var tag0 = marker.tag ? marker.tag.substr(0, 1) : "";

          if (tag0 === 'v' || tag0 === 'c') {
            // check for mangled verses and chapters
            var number = marker.tag.substr(1);
            var isInt = /^\+?\d+$/.test(number);

            if (isInt) {
              // separate number from tag
              marker.tag = tag0;

              if (marker.number) {
                marker.content = marker.number + (marker.content ? " " + marker.content : "");
              }

              marker.number = number;

              if (tag0 === 'v') {
                parseAsVerse(state, marker);
                marker = null;
              } else if (tag0 === 'c') {
                processAsChapter(state, marker);
                marker = null;
              }
            } else if (marker.tag.length === 1) {
              // convert line to text
              marker.content = markerToText(marker);
              processAsText(state, marker);
              marker = null;
            }
          }

          if (marker) {
            // if not yet processed
            i = processMarker(state, marker, i, markers);
          }
        }
    }
  }

  terminatePhrases(state);
  cleanupHeaderNewLines(state);
  usfmJSON.headers = state.headers;
  getVerseObjectsForBook(usfmJSON, state);

  if (Object.keys(state.verses).length > 0) {
    usfmJSON.verses = getVerseObjectsForChapter(state.verses);
  }

  return usfmJSON;
};

exports.usfmToJSON = usfmToJSON;