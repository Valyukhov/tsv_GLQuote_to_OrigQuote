"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeVerseData = exports.convertStringToVerseObjects = exports.removeMarker = void 0;

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _usfmToJson = require("./usfmToJson");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/* eslint-disable no-use-before-define,brace-style */

/* Method to filter specified usfm marker from a string
 * @param {string} string - The string to remove specfic marker from
 * @return {string}
 */
var removeMarker = function removeMarker() {
  var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var output = string; // default results

  if (string) {
    var verseObjects = convertStringToVerseObjects(string);

    if (verseObjects) {
      output = mergeVerseData(verseObjects); // get displayed text from verseObjects
    }
  }

  return output;
};
/**
 * takes the text of a verse and converts to verseObjects
 * @param {String} text - verse text to convert
 * @return {Object|*} verseObjects for verseText
 */


exports.removeMarker = removeMarker;

var convertStringToVerseObjects = function convertStringToVerseObjects(text) {
  // first parse to verse objects
  var jsonData = (0, _usfmToJson.usfmToJSON)('\\v 1 ' + text, {
    chunk: true
  });
  var verseObjects = jsonData && jsonData.verses && jsonData.verses["1"] && jsonData.verses["1"].verseObjects;
  return verseObjects;
};
/**
 * parse a single child
 * @param {Object} child
 * @param {String} text
 * @param {String} wordSpacing
 * @return {{wordSpacing: string, text: string}}
 */


exports.convertStringToVerseObjects = convertStringToVerseObjects;

var parseChild = function parseChild(child, text, wordSpacing) {
  switch (child.type) {
    case 'word':
      text += wordSpacing + child.text;
      wordSpacing = ' ';
      break;

    case 'milestone':
      text += wordSpacing + parseMilestone(child);
      wordSpacing = ' ';
      break;

    default:
      if (child.text) {
        text += child.text;
        var lastChar = text.substr(-1);

        if (lastChar !== "," && lastChar !== '.' && lastChar !== '?' && lastChar !== ';') {
          // legacy support, make sure padding before word
          wordSpacing = '';
        }
      }

      if (child.children) {
        var length = child.children.length;

        for (var i = 0; i < length; i++) {
          var childChild = child.children[i];

          var __ret = parseChild(childChild, text, wordSpacing);

          text = __ret.text;
          wordSpacing = __ret.wordSpacing;
        }
      }

      break;
  }

  return {
    text: text,
    wordSpacing: wordSpacing
  };
};
/**
 * dive down into milestone to extract words and text
 * @param {Object} verseObject - milestone to parse
 * @return {string} text content of milestone
 */


var parseMilestone = function parseMilestone(verseObject) {
  var text = verseObject.text || "";
  var wordSpacing = '';
  var length = verseObject.children.length;

  for (var i = 0; i < length; i++) {
    var child = verseObject.children[i];

    var __ret = parseChild(child, text, wordSpacing);

    text = __ret.text;
    wordSpacing = __ret.wordSpacing;

    if (child.nextChar) {
      text += child.nextChar;
    }
  }

  if (verseObject.nextChar) {
    text += verseObject.nextChar;
  }

  return text;
};
/**
 * get text from word and milestone markers
 * @param {Object} verseObject - to parse
 * @param {String} wordSpacing - spacing to use before next word
 * @return {*} new verseObject and word spacing
 */


var replaceWordsAndMilestones = function replaceWordsAndMilestones(verseObject, wordSpacing) {
  var text = '';

  if (verseObject.type === 'word') {
    text = wordSpacing + verseObject.text;
  } else if (verseObject.children) {
    text = wordSpacing + parseMilestone(verseObject);
  }

  if (text) {
    // replace with text object
    verseObject = {
      type: "text",
      text: text
    };
    wordSpacing = ' ';
  } else {
    wordSpacing = ' ';

    if (verseObject.nextChar) {
      wordSpacing = ''; // no need for spacing before next word if this item has it
    } else if (verseObject.text) {
      var lastChar = verseObject.text.substr(-1);

      if (![',', '.', '?', ';'].includes(lastChar)) {
        // legacy support, make sure padding before next word if punctuation
        wordSpacing = '';
      }
    }

    if (verseObject.children) {
      // handle nested
      var verseObject_ = (0, _lodash["default"])(verseObject);
      var wordSpacing_ = '';
      var length = verseObject.children.length;

      for (var i = 0; i < length; i++) {
        var flattened = replaceWordsAndMilestones(verseObject.children[i], wordSpacing_);
        wordSpacing_ = flattened.wordSpacing;
        verseObject_.children[i] = flattened.verseObject;
      }

      verseObject = verseObject_;
    }
  }

  return {
    verseObject: verseObject,
    wordSpacing: wordSpacing
  };
};
/**
 * @description merge verse data into a string
 * @param {Object|Array} verseData - verse objects to be merged
 * @param {array} filter - Optional filter to get a specific type of word object type.
 * @return {String} - the merged verse object string
 */


var mergeVerseData = function mergeVerseData(verseData) {
  if (verseData.verseObjects) {
    verseData = verseData.verseObjects;
  }

  var flattenedData = [];

  if (Array.isArray(verseData)) {
    var wordSpacing = '';
    var _length = verseData.length;

    for (var i = 0; i < _length; i++) {
      var verseObject = verseData[i];
      var flattened = replaceWordsAndMilestones(verseObject, wordSpacing);
      wordSpacing = flattened.wordSpacing;
      flattenedData.push(flattened.verseObject);
    }

    verseData = {
      // use flattened data
      verseObjects: flattenedData
    };
  }

  var verseText = "";
  var length = flattenedData.length;

  for (var _i = 0; _i < length; _i++) {
    var verseObj = flattenedData[_i];

    if (verseObj.text) {
      if (verseObj.tag) {
        var lastChar = verseText && verseText[verseText.length - 1];

        if (!['', ' ', '\n'].includes(lastChar)) {
          verseText += ' ';
        }
      }

      verseText += verseObj.text;
    }

    if (verseObj.nextChar) {
      verseText += verseObj.nextChar;
    }
  }

  return verseText;
};

exports.mergeVerseData = mergeVerseData;