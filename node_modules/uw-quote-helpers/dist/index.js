import { toJSON } from "usfm-js";
function _iterableToArrayLimit$1(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$1();
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lib$1 = {};
var tokenizers = {};
var libExports = {};
var lib = {
  get exports() {
    return libExports;
  },
  set exports(v) {
    libExports = v;
  }
};
var interopRequireDefaultExports = {};
var interopRequireDefault = {
  get exports() {
    return interopRequireDefaultExports;
  },
  set exports(v) {
    interopRequireDefaultExports = v;
  }
};
(function(module) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var definePropertyExports$1 = {};
var defineProperty$4 = {
  get exports() {
    return definePropertyExports$1;
  },
  set exports(v) {
    definePropertyExports$1 = v;
  }
};
var definePropertyExports = {};
var defineProperty$3 = {
  get exports() {
    return definePropertyExports;
  },
  set exports(v) {
    definePropertyExports = v;
  }
};
var check = function(it) {
  return it && it.Math == Math && it;
};
var global$3 = (
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
  function() {
    return this;
  }() || Function("return this")()
);
var fails$6 = function(exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};
var fails$5 = fails$6;
var functionBindNative = !fails$5(function() {
  var test = function() {
  }.bind();
  return typeof test != "function" || test.hasOwnProperty("prototype");
});
var NATIVE_BIND$2 = functionBindNative;
var FunctionPrototype = Function.prototype;
var apply$1 = FunctionPrototype.apply;
var call$4 = FunctionPrototype.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$2 ? call$4.bind(apply$1) : function() {
  return call$4.apply(apply$1, arguments);
});
var functionUncurryThis;
var hasRequiredFunctionUncurryThis;
function requireFunctionUncurryThis() {
  if (hasRequiredFunctionUncurryThis)
    return functionUncurryThis;
  hasRequiredFunctionUncurryThis = 1;
  var NATIVE_BIND2 = functionBindNative;
  var FunctionPrototype2 = Function.prototype;
  var call2 = FunctionPrototype2.call;
  var uncurryThisWithBind = NATIVE_BIND2 && FunctionPrototype2.bind.bind(call2, call2);
  functionUncurryThis = NATIVE_BIND2 ? uncurryThisWithBind : function(fn) {
    return function() {
      return call2.apply(fn, arguments);
    };
  };
  return functionUncurryThis;
}
var classofRaw$1;
var hasRequiredClassofRaw;
function requireClassofRaw() {
  if (hasRequiredClassofRaw)
    return classofRaw$1;
  hasRequiredClassofRaw = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var toString2 = uncurryThis2({}.toString);
  var stringSlice = uncurryThis2("".slice);
  classofRaw$1 = function(it) {
    return stringSlice(toString2(it), 8, -1);
  };
  return classofRaw$1;
}
var classofRaw = requireClassofRaw();
var uncurryThis$3 = requireFunctionUncurryThis();
var functionUncurryThisClause = function(fn) {
  if (classofRaw(fn) === "Function")
    return uncurryThis$3(fn);
};
var documentAll$2 = typeof document == "object" && document.all;
var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA
};
var $documentAll$1 = documentAll_1;
var documentAll$1 = $documentAll$1.all;
var isCallable$6 = $documentAll$1.IS_HTMLDDA ? function(argument) {
  return typeof argument == "function" || argument === documentAll$1;
} : function(argument) {
  return typeof argument == "function";
};
var objectGetOwnPropertyDescriptor = {};
var fails$4 = fails$6;
var descriptors = !fails$4(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var NATIVE_BIND$1 = functionBindNative;
var call$3 = Function.prototype.call;
var functionCall = NATIVE_BIND$1 ? call$3.bind(call$3) : function() {
  return call$3.apply(call$3, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$1(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
var createPropertyDescriptor$2 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var uncurryThis$2 = requireFunctionUncurryThis();
var fails$3 = fails$6;
var classof$1 = requireClassofRaw();
var $Object$1 = Object;
var split = uncurryThis$2("".split);
var indexedObject = fails$3(function() {
  return !$Object$1("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$1(it) == "String" ? split(it, "") : $Object$1(it);
} : $Object$1;
var isNullOrUndefined$2 = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$1 = isNullOrUndefined$2;
var $TypeError$5 = TypeError;
var requireObjectCoercible$1 = function(it) {
  if (isNullOrUndefined$1(it))
    throw $TypeError$5("Can't call method on " + it);
  return it;
};
var IndexedObject = indexedObject;
var requireObjectCoercible = requireObjectCoercible$1;
var toIndexedObject$1 = function(it) {
  return IndexedObject(requireObjectCoercible(it));
};
var isCallable$5 = isCallable$6;
var $documentAll = documentAll_1;
var documentAll = $documentAll.all;
var isObject$4 = $documentAll.IS_HTMLDDA ? function(it) {
  return typeof it == "object" ? it !== null : isCallable$5(it) || it === documentAll;
} : function(it) {
  return typeof it == "object" ? it !== null : isCallable$5(it);
};
var path$2 = {};
var getBuiltIn$1;
var hasRequiredGetBuiltIn;
function requireGetBuiltIn() {
  if (hasRequiredGetBuiltIn)
    return getBuiltIn$1;
  hasRequiredGetBuiltIn = 1;
  var path2 = path$2;
  var global2 = global$3;
  var isCallable2 = isCallable$6;
  var aFunction = function(variable) {
    return isCallable2(variable) ? variable : void 0;
  };
  getBuiltIn$1 = function(namespace, method) {
    return arguments.length < 2 ? aFunction(path2[namespace]) || aFunction(global2[namespace]) : path2[namespace] && path2[namespace][method] || global2[namespace] && global2[namespace][method];
  };
  return getBuiltIn$1;
}
var objectIsPrototypeOf;
var hasRequiredObjectIsPrototypeOf;
function requireObjectIsPrototypeOf() {
  if (hasRequiredObjectIsPrototypeOf)
    return objectIsPrototypeOf;
  hasRequiredObjectIsPrototypeOf = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  objectIsPrototypeOf = uncurryThis2({}.isPrototypeOf);
  return objectIsPrototypeOf;
}
var engineUserAgent;
var hasRequiredEngineUserAgent;
function requireEngineUserAgent() {
  if (hasRequiredEngineUserAgent)
    return engineUserAgent;
  hasRequiredEngineUserAgent = 1;
  engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  return engineUserAgent;
}
var engineV8Version;
var hasRequiredEngineV8Version;
function requireEngineV8Version() {
  if (hasRequiredEngineV8Version)
    return engineV8Version;
  hasRequiredEngineV8Version = 1;
  var global2 = global$3;
  var userAgent = requireEngineUserAgent();
  var process2 = global2.process;
  var Deno = global2.Deno;
  var versions = process2 && process2.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version;
  if (v8) {
    match = v8.split(".");
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match)
        version = +match[1];
    }
  }
  engineV8Version = version;
  return engineV8Version;
}
var symbolConstructorDetection;
var hasRequiredSymbolConstructorDetection;
function requireSymbolConstructorDetection() {
  if (hasRequiredSymbolConstructorDetection)
    return symbolConstructorDetection;
  hasRequiredSymbolConstructorDetection = 1;
  var V8_VERSION = requireEngineV8Version();
  var fails2 = fails$6;
  symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails2(function() {
    var symbol2 = Symbol();
    return !String(symbol2) || !(Object(symbol2) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });
  return symbolConstructorDetection;
}
var useSymbolAsUid;
var hasRequiredUseSymbolAsUid;
function requireUseSymbolAsUid() {
  if (hasRequiredUseSymbolAsUid)
    return useSymbolAsUid;
  hasRequiredUseSymbolAsUid = 1;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  useSymbolAsUid = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  return useSymbolAsUid;
}
var getBuiltIn = requireGetBuiltIn();
var isCallable$4 = isCallable$6;
var isPrototypeOf = requireObjectIsPrototypeOf();
var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
var $Object = Object;
var isSymbol$2 = USE_SYMBOL_AS_UID ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol = getBuiltIn("Symbol");
  return isCallable$4($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};
var $String$1 = String;
var tryToString$1 = function(argument) {
  try {
    return $String$1(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$3 = isCallable$6;
var tryToString = tryToString$1;
var $TypeError$4 = TypeError;
var aCallable$2 = function(argument) {
  if (isCallable$3(argument))
    return argument;
  throw $TypeError$4(tryToString(argument) + " is not a function");
};
var aCallable$1 = aCallable$2;
var isNullOrUndefined = isNullOrUndefined$2;
var getMethod$1 = function(V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? void 0 : aCallable$1(func);
};
var call$2 = functionCall;
var isCallable$2 = isCallable$6;
var isObject$3 = isObject$4;
var $TypeError$3 = TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$2(fn = input.toString) && !isObject$3(val = call$2(fn, input)))
    return val;
  if (isCallable$2(fn = input.valueOf) && !isObject$3(val = call$2(fn, input)))
    return val;
  if (pref !== "string" && isCallable$2(fn = input.toString) && !isObject$3(val = call$2(fn, input)))
    return val;
  throw $TypeError$3("Can't convert object to primitive value");
};
var sharedExports = {};
var shared = {
  get exports() {
    return sharedExports;
  },
  set exports(v) {
    sharedExports = v;
  }
};
var isPure;
var hasRequiredIsPure;
function requireIsPure() {
  if (hasRequiredIsPure)
    return isPure;
  hasRequiredIsPure = 1;
  isPure = true;
  return isPure;
}
var defineGlobalProperty;
var hasRequiredDefineGlobalProperty;
function requireDefineGlobalProperty() {
  if (hasRequiredDefineGlobalProperty)
    return defineGlobalProperty;
  hasRequiredDefineGlobalProperty = 1;
  var global2 = global$3;
  var defineProperty5 = Object.defineProperty;
  defineGlobalProperty = function(key, value) {
    try {
      defineProperty5(global2, key, { value, configurable: true, writable: true });
    } catch (error) {
      global2[key] = value;
    }
    return value;
  };
  return defineGlobalProperty;
}
var sharedStore;
var hasRequiredSharedStore;
function requireSharedStore() {
  if (hasRequiredSharedStore)
    return sharedStore;
  hasRequiredSharedStore = 1;
  var global2 = global$3;
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  var SHARED = "__core-js_shared__";
  var store = global2[SHARED] || defineGlobalProperty2(SHARED, {});
  sharedStore = store;
  return sharedStore;
}
var hasRequiredShared;
function requireShared() {
  if (hasRequiredShared)
    return sharedExports;
  hasRequiredShared = 1;
  var IS_PURE = requireIsPure();
  var store = requireSharedStore();
  (shared.exports = function(key, value) {
    return store[key] || (store[key] = value !== void 0 ? value : {});
  })("versions", []).push({
    version: "3.29.1",
    mode: IS_PURE ? "pure" : "global",
    copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.29.1/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  return sharedExports;
}
var toObject;
var hasRequiredToObject;
function requireToObject() {
  if (hasRequiredToObject)
    return toObject;
  hasRequiredToObject = 1;
  var requireObjectCoercible2 = requireObjectCoercible$1;
  var $Object2 = Object;
  toObject = function(argument) {
    return $Object2(requireObjectCoercible2(argument));
  };
  return toObject;
}
var hasOwnProperty_1;
var hasRequiredHasOwnProperty;
function requireHasOwnProperty() {
  if (hasRequiredHasOwnProperty)
    return hasOwnProperty_1;
  hasRequiredHasOwnProperty = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var toObject2 = requireToObject();
  var hasOwnProperty = uncurryThis2({}.hasOwnProperty);
  hasOwnProperty_1 = Object.hasOwn || function hasOwn2(it, key) {
    return hasOwnProperty(toObject2(it), key);
  };
  return hasOwnProperty_1;
}
var uid;
var hasRequiredUid;
function requireUid() {
  if (hasRequiredUid)
    return uid;
  hasRequiredUid = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var id = 0;
  var postfix = Math.random();
  var toString2 = uncurryThis2(1 .toString);
  uid = function(key) {
    return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
  };
  return uid;
}
var wellKnownSymbol$1;
var hasRequiredWellKnownSymbol;
function requireWellKnownSymbol() {
  if (hasRequiredWellKnownSymbol)
    return wellKnownSymbol$1;
  hasRequiredWellKnownSymbol = 1;
  var global2 = global$3;
  var shared2 = requireShared();
  var hasOwn2 = requireHasOwnProperty();
  var uid2 = requireUid();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var USE_SYMBOL_AS_UID2 = requireUseSymbolAsUid();
  var Symbol2 = global2.Symbol;
  var WellKnownSymbolsStore = shared2("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID2 ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
  wellKnownSymbol$1 = function(name) {
    if (!hasOwn2(WellKnownSymbolsStore, name)) {
      WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn2(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
  return wellKnownSymbol$1;
}
var call$1 = functionCall;
var isObject$2 = isObject$4;
var isSymbol$1 = isSymbol$2;
var getMethod = getMethod$1;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol = requireWellKnownSymbol();
var $TypeError$2 = TypeError;
var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$2(input) || isSymbol$1(input))
    return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$1(exoticToPrim, input, pref);
    if (!isObject$2(result) || isSymbol$1(result))
      return result;
    throw $TypeError$2("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$2 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var global$2 = global$3;
var isObject$1 = isObject$4;
var document$1 = global$2.document;
var EXISTS = isObject$1(document$1) && isObject$1(document$1.createElement);
var documentCreateElement = function(it) {
  return EXISTS ? document$1.createElement(it) : {};
};
var DESCRIPTORS$5 = descriptors;
var fails$2 = fails$6;
var createElement = documentCreateElement;
var ie8DomDefine = !DESCRIPTORS$5 && !fails$2(function() {
  return Object.defineProperty(createElement("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$4 = descriptors;
var call = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$1 = createPropertyDescriptor$2;
var toIndexedObject = toIndexedObject$1;
var toPropertyKey$1 = toPropertyKey$2;
var hasOwn$1 = requireHasOwnProperty();
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$4 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey$1(P);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$1(O, P);
    } catch (error) {
    }
  if (hasOwn$1(O, P))
    return createPropertyDescriptor$1(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};
var fails$1 = fails$6;
var isCallable$1 = isCallable$6;
var replacement = /#|\.prototype\./;
var isForced$1 = function(feature, detection) {
  var value = data[normalize$1(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$1(detection) ? fails$1(detection) : !!detection;
};
var normalize$1 = isForced$1.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = "N";
var POLYFILL = isForced$1.POLYFILL = "P";
var isForced_1 = isForced$1;
var uncurryThis$1 = functionUncurryThisClause;
var aCallable = aCallable$2;
var NATIVE_BIND = functionBindNative;
var bind$1 = uncurryThis$1(uncurryThis$1.bind);
var functionBindContext = function(fn, that) {
  aCallable(fn);
  return that === void 0 ? fn : NATIVE_BIND ? bind$1(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var objectDefineProperty = {};
var DESCRIPTORS$3 = descriptors;
var fails = fails$6;
var v8PrototypeDefineBug = DESCRIPTORS$3 && fails(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var isObject = isObject$4;
var $String = String;
var $TypeError$1 = TypeError;
var anObject$1 = function(argument) {
  if (isObject(argument))
    return argument;
  throw $TypeError$1($String(argument) + " is not an object");
};
var DESCRIPTORS$2 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var anObject = anObject$1;
var toPropertyKey = toPropertyKey$2;
var $TypeError = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$2 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty2(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw $TypeError("Accessors not supported");
  if ("value" in Attributes)
    O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$1 = descriptors;
var definePropertyModule = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$2;
var createNonEnumerableProperty$1 = DESCRIPTORS$1 ? function(object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var global$1 = global$3;
var apply = functionApply;
var uncurryThis = functionUncurryThisClause;
var isCallable = isCallable$6;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var isForced = isForced_1;
var path$1 = path$2;
var bind = functionBindContext;
var createNonEnumerableProperty = createNonEnumerableProperty$1;
var hasOwn = requireHasOwnProperty();
var wrapConstructor = function(NativeConstructor) {
  var Wrapper = function(a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0:
          return new NativeConstructor();
        case 1:
          return new NativeConstructor(a);
        case 2:
          return new NativeConstructor(a, b);
      }
      return new NativeConstructor(a, b, c);
    }
    return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;
  var nativeSource = GLOBAL ? global$1 : STATIC ? global$1[TARGET] : (global$1[TARGET] || {}).prototype;
  var target = GLOBAL ? path$1 : path$1[TARGET] || createNonEnumerableProperty(path$1, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;
  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);
    targetProperty = target[key];
    if (USE_NATIVE)
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor2(nativeSource, key);
        nativeProperty = descriptor && descriptor.value;
      } else
        nativeProperty = nativeSource[key];
    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty)
      continue;
    if (options.bind && USE_NATIVE)
      resultProperty = bind(sourceProperty, global$1);
    else if (options.wrap && USE_NATIVE)
      resultProperty = wrapConstructor(sourceProperty);
    else if (PROTO && isCallable(sourceProperty))
      resultProperty = uncurryThis(sourceProperty);
    else
      resultProperty = sourceProperty;
    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(resultProperty, "sham", true);
    }
    createNonEnumerableProperty(target, key, resultProperty);
    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + "Prototype";
      if (!hasOwn(path$1, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path$1, VIRTUAL_PROTOTYPE, {});
      }
      createNonEnumerableProperty(path$1[VIRTUAL_PROTOTYPE], key, sourceProperty);
      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};
var $ = _export;
var DESCRIPTORS = descriptors;
var defineProperty$2 = objectDefineProperty.f;
$({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty$2, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty$2
});
var path = path$2;
var Object$1 = path.Object;
var defineProperty$1 = defineProperty$3.exports = function defineProperty3(it, key, desc) {
  return Object$1.defineProperty(it, key, desc);
};
if (Object$1.defineProperty.sham)
  defineProperty$1.sham = true;
var parent = definePropertyExports;
var defineProperty4 = parent;
(function(module) {
  module.exports = defineProperty4;
})(defineProperty$4);
var xregexpExports = {};
var xregexp = {
  get exports() {
    return xregexpExports;
  },
  set exports(v) {
    xregexpExports = v;
  }
};
var getIteratorExports$1 = {};
var getIterator$5 = {
  get exports() {
    return getIteratorExports$1;
  },
  set exports(v) {
    getIteratorExports$1 = v;
  }
};
var getIteratorExports = {};
var getIterator$4 = {
  get exports() {
    return getIteratorExports;
  },
  set exports(v) {
    getIteratorExports = v;
  }
};
var addToUnscopables;
var hasRequiredAddToUnscopables;
function requireAddToUnscopables() {
  if (hasRequiredAddToUnscopables)
    return addToUnscopables;
  hasRequiredAddToUnscopables = 1;
  addToUnscopables = function() {
  };
  return addToUnscopables;
}
var iterators;
var hasRequiredIterators;
function requireIterators() {
  if (hasRequiredIterators)
    return iterators;
  hasRequiredIterators = 1;
  iterators = {};
  return iterators;
}
var weakMapBasicDetection;
var hasRequiredWeakMapBasicDetection;
function requireWeakMapBasicDetection() {
  if (hasRequiredWeakMapBasicDetection)
    return weakMapBasicDetection;
  hasRequiredWeakMapBasicDetection = 1;
  var global2 = global$3;
  var isCallable2 = isCallable$6;
  var WeakMap2 = global2.WeakMap;
  weakMapBasicDetection = isCallable2(WeakMap2) && /native code/.test(String(WeakMap2));
  return weakMapBasicDetection;
}
var sharedKey;
var hasRequiredSharedKey;
function requireSharedKey() {
  if (hasRequiredSharedKey)
    return sharedKey;
  hasRequiredSharedKey = 1;
  var shared2 = requireShared();
  var uid2 = requireUid();
  var keys = shared2("keys");
  sharedKey = function(key) {
    return keys[key] || (keys[key] = uid2(key));
  };
  return sharedKey;
}
var hiddenKeys;
var hasRequiredHiddenKeys;
function requireHiddenKeys() {
  if (hasRequiredHiddenKeys)
    return hiddenKeys;
  hasRequiredHiddenKeys = 1;
  hiddenKeys = {};
  return hiddenKeys;
}
var internalState;
var hasRequiredInternalState;
function requireInternalState() {
  if (hasRequiredInternalState)
    return internalState;
  hasRequiredInternalState = 1;
  var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
  var global2 = global$3;
  var isObject2 = isObject$4;
  var createNonEnumerableProperty2 = createNonEnumerableProperty$1;
  var hasOwn2 = requireHasOwnProperty();
  var shared2 = requireSharedStore();
  var sharedKey2 = requireSharedKey();
  var hiddenKeys2 = requireHiddenKeys();
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError2 = global2.TypeError;
  var WeakMap2 = global2.WeakMap;
  var set, get, has;
  var enforce = function(it) {
    return has(it) ? get(it) : set(it, {});
  };
  var getterFor = function(TYPE) {
    return function(it) {
      var state;
      if (!isObject2(it) || (state = get(it)).type !== TYPE) {
        throw TypeError2("Incompatible receiver, " + TYPE + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP || shared2.state) {
    var store = shared2.state || (shared2.state = new WeakMap2());
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set = function(it, metadata) {
      if (store.has(it))
        throw TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      store.set(it, metadata);
      return metadata;
    };
    get = function(it) {
      return store.get(it) || {};
    };
    has = function(it) {
      return store.has(it);
    };
  } else {
    var STATE = sharedKey2("state");
    hiddenKeys2[STATE] = true;
    set = function(it, metadata) {
      if (hasOwn2(it, STATE))
        throw TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty2(it, STATE, metadata);
      return metadata;
    };
    get = function(it) {
      return hasOwn2(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
      return hasOwn2(it, STATE);
    };
  }
  internalState = {
    set,
    get,
    has,
    enforce,
    getterFor
  };
  return internalState;
}
var functionName;
var hasRequiredFunctionName;
function requireFunctionName() {
  if (hasRequiredFunctionName)
    return functionName;
  hasRequiredFunctionName = 1;
  var DESCRIPTORS2 = descriptors;
  var hasOwn2 = requireHasOwnProperty();
  var FunctionPrototype2 = Function.prototype;
  var getDescriptor = DESCRIPTORS2 && Object.getOwnPropertyDescriptor;
  var EXISTS2 = hasOwn2(FunctionPrototype2, "name");
  var PROPER = EXISTS2 && function something() {
  }.name === "something";
  var CONFIGURABLE2 = EXISTS2 && (!DESCRIPTORS2 || DESCRIPTORS2 && getDescriptor(FunctionPrototype2, "name").configurable);
  functionName = {
    EXISTS: EXISTS2,
    PROPER,
    CONFIGURABLE: CONFIGURABLE2
  };
  return functionName;
}
var objectDefineProperties = {};
var mathTrunc;
var hasRequiredMathTrunc;
function requireMathTrunc() {
  if (hasRequiredMathTrunc)
    return mathTrunc;
  hasRequiredMathTrunc = 1;
  var ceil = Math.ceil;
  var floor = Math.floor;
  mathTrunc = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
  };
  return mathTrunc;
}
var toIntegerOrInfinity;
var hasRequiredToIntegerOrInfinity;
function requireToIntegerOrInfinity() {
  if (hasRequiredToIntegerOrInfinity)
    return toIntegerOrInfinity;
  hasRequiredToIntegerOrInfinity = 1;
  var trunc = requireMathTrunc();
  toIntegerOrInfinity = function(argument) {
    var number = +argument;
    return number !== number || number === 0 ? 0 : trunc(number);
  };
  return toIntegerOrInfinity;
}
var toAbsoluteIndex;
var hasRequiredToAbsoluteIndex;
function requireToAbsoluteIndex() {
  if (hasRequiredToAbsoluteIndex)
    return toAbsoluteIndex;
  hasRequiredToAbsoluteIndex = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var max = Math.max;
  var min = Math.min;
  toAbsoluteIndex = function(index, length) {
    var integer = toIntegerOrInfinity2(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
  };
  return toAbsoluteIndex;
}
var toLength;
var hasRequiredToLength;
function requireToLength() {
  if (hasRequiredToLength)
    return toLength;
  hasRequiredToLength = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var min = Math.min;
  toLength = function(argument) {
    return argument > 0 ? min(toIntegerOrInfinity2(argument), 9007199254740991) : 0;
  };
  return toLength;
}
var lengthOfArrayLike;
var hasRequiredLengthOfArrayLike;
function requireLengthOfArrayLike() {
  if (hasRequiredLengthOfArrayLike)
    return lengthOfArrayLike;
  hasRequiredLengthOfArrayLike = 1;
  var toLength2 = requireToLength();
  lengthOfArrayLike = function(obj) {
    return toLength2(obj.length);
  };
  return lengthOfArrayLike;
}
var arrayIncludes;
var hasRequiredArrayIncludes;
function requireArrayIncludes() {
  if (hasRequiredArrayIncludes)
    return arrayIncludes;
  hasRequiredArrayIncludes = 1;
  var toIndexedObject2 = toIndexedObject$1;
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject2($this);
      var length = lengthOfArrayLike2(O);
      var index = toAbsoluteIndex2(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el)
        while (length > index) {
          value = O[index++];
          if (value != value)
            return true;
        }
      else
        for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el)
            return IS_INCLUDES || index || 0;
        }
      return !IS_INCLUDES && -1;
    };
  };
  arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };
  return arrayIncludes;
}
var objectKeysInternal;
var hasRequiredObjectKeysInternal;
function requireObjectKeysInternal() {
  if (hasRequiredObjectKeysInternal)
    return objectKeysInternal;
  hasRequiredObjectKeysInternal = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var hasOwn2 = requireHasOwnProperty();
  var toIndexedObject2 = toIndexedObject$1;
  var indexOf2 = requireArrayIncludes().indexOf;
  var hiddenKeys2 = requireHiddenKeys();
  var push = uncurryThis2([].push);
  objectKeysInternal = function(object, names) {
    var O = toIndexedObject2(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O)
      !hasOwn2(hiddenKeys2, key) && hasOwn2(O, key) && push(result, key);
    while (names.length > i)
      if (hasOwn2(O, key = names[i++])) {
        ~indexOf2(result, key) || push(result, key);
      }
    return result;
  };
  return objectKeysInternal;
}
var enumBugKeys;
var hasRequiredEnumBugKeys;
function requireEnumBugKeys() {
  if (hasRequiredEnumBugKeys)
    return enumBugKeys;
  hasRequiredEnumBugKeys = 1;
  enumBugKeys = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  return enumBugKeys;
}
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys)
    return objectKeys;
  hasRequiredObjectKeys = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  objectKeys = Object.keys || function keys(O) {
    return internalObjectKeys(O, enumBugKeys2);
  };
  return objectKeys;
}
var hasRequiredObjectDefineProperties;
function requireObjectDefineProperties() {
  if (hasRequiredObjectDefineProperties)
    return objectDefineProperties;
  hasRequiredObjectDefineProperties = 1;
  var DESCRIPTORS2 = descriptors;
  var V8_PROTOTYPE_DEFINE_BUG2 = v8PrototypeDefineBug;
  var definePropertyModule2 = objectDefineProperty;
  var anObject2 = anObject$1;
  var toIndexedObject2 = toIndexedObject$1;
  var objectKeys2 = requireObjectKeys();
  objectDefineProperties.f = DESCRIPTORS2 && !V8_PROTOTYPE_DEFINE_BUG2 ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject2(O);
    var props = toIndexedObject2(Properties);
    var keys = objectKeys2(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length > index)
      definePropertyModule2.f(O, key = keys[index++], props[key]);
    return O;
  };
  return objectDefineProperties;
}
var html;
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml)
    return html;
  hasRequiredHtml = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  html = getBuiltIn2("document", "documentElement");
  return html;
}
var objectCreate;
var hasRequiredObjectCreate;
function requireObjectCreate() {
  if (hasRequiredObjectCreate)
    return objectCreate;
  hasRequiredObjectCreate = 1;
  var anObject2 = anObject$1;
  var definePropertiesModule = requireObjectDefineProperties();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = requireHiddenKeys();
  var html2 = requireHtml();
  var documentCreateElement$1 = documentCreateElement;
  var sharedKey2 = requireSharedKey();
  var GT = ">";
  var LT = "<";
  var PROTOTYPE = "prototype";
  var SCRIPT = "script";
  var IE_PROTO = sharedKey2("IE_PROTO");
  var EmptyConstructor = function() {
  };
  var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument2) {
    activeXDocument2.write(scriptTag(""));
    activeXDocument2.close();
    var temp = activeXDocument2.parentWindow.Object;
    activeXDocument2 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement$1("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html2.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {
    }
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
    var length = enumBugKeys2.length;
    while (length--)
      delete NullProtoObject[PROTOTYPE][enumBugKeys2[length]];
    return NullProtoObject();
  };
  hiddenKeys2[IE_PROTO] = true;
  objectCreate = Object.create || function create2(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject2(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      result[IE_PROTO] = O;
    } else
      result = NullProtoObject();
    return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
  };
  return objectCreate;
}
var correctPrototypeGetter;
var hasRequiredCorrectPrototypeGetter;
function requireCorrectPrototypeGetter() {
  if (hasRequiredCorrectPrototypeGetter)
    return correctPrototypeGetter;
  hasRequiredCorrectPrototypeGetter = 1;
  var fails2 = fails$6;
  correctPrototypeGetter = !fails2(function() {
    function F() {
    }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });
  return correctPrototypeGetter;
}
var objectGetPrototypeOf;
var hasRequiredObjectGetPrototypeOf;
function requireObjectGetPrototypeOf() {
  if (hasRequiredObjectGetPrototypeOf)
    return objectGetPrototypeOf;
  hasRequiredObjectGetPrototypeOf = 1;
  var hasOwn2 = requireHasOwnProperty();
  var isCallable2 = isCallable$6;
  var toObject2 = requireToObject();
  var sharedKey2 = requireSharedKey();
  var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
  var IE_PROTO = sharedKey2("IE_PROTO");
  var $Object2 = Object;
  var ObjectPrototype = $Object2.prototype;
  objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object2.getPrototypeOf : function(O) {
    var object = toObject2(O);
    if (hasOwn2(object, IE_PROTO))
      return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable2(constructor) && object instanceof constructor) {
      return constructor.prototype;
    }
    return object instanceof $Object2 ? ObjectPrototype : null;
  };
  return objectGetPrototypeOf;
}
var defineBuiltIn;
var hasRequiredDefineBuiltIn;
function requireDefineBuiltIn() {
  if (hasRequiredDefineBuiltIn)
    return defineBuiltIn;
  hasRequiredDefineBuiltIn = 1;
  var createNonEnumerableProperty2 = createNonEnumerableProperty$1;
  defineBuiltIn = function(target, key, value, options) {
    if (options && options.enumerable)
      target[key] = value;
    else
      createNonEnumerableProperty2(target, key, value);
    return target;
  };
  return defineBuiltIn;
}
var iteratorsCore;
var hasRequiredIteratorsCore;
function requireIteratorsCore() {
  if (hasRequiredIteratorsCore)
    return iteratorsCore;
  hasRequiredIteratorsCore = 1;
  var fails2 = fails$6;
  var isCallable2 = isCallable$6;
  var isObject2 = isObject$4;
  var create2 = requireObjectCreate();
  var getPrototypeOf = requireObjectGetPrototypeOf();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var IS_PURE = requireIsPure();
  var ITERATOR = wellKnownSymbol2("iterator");
  var BUGGY_SAFARI_ITERATORS = false;
  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
  if ([].keys) {
    arrayIterator = [].keys();
    if (!("next" in arrayIterator))
      BUGGY_SAFARI_ITERATORS = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
        IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }
  var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails2(function() {
    var test = {};
    return IteratorPrototype[ITERATOR].call(test) !== test;
  });
  if (NEW_ITERATOR_PROTOTYPE)
    IteratorPrototype = {};
  else if (IS_PURE)
    IteratorPrototype = create2(IteratorPrototype);
  if (!isCallable2(IteratorPrototype[ITERATOR])) {
    defineBuiltIn2(IteratorPrototype, ITERATOR, function() {
      return this;
    });
  }
  iteratorsCore = {
    IteratorPrototype,
    BUGGY_SAFARI_ITERATORS
  };
  return iteratorsCore;
}
var toStringTagSupport;
var hasRequiredToStringTagSupport;
function requireToStringTagSupport() {
  if (hasRequiredToStringTagSupport)
    return toStringTagSupport;
  hasRequiredToStringTagSupport = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var test = {};
  test[TO_STRING_TAG] = "z";
  toStringTagSupport = String(test) === "[object z]";
  return toStringTagSupport;
}
var classof;
var hasRequiredClassof;
function requireClassof() {
  if (hasRequiredClassof)
    return classof;
  hasRequiredClassof = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var isCallable2 = isCallable$6;
  var classofRaw2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var $Object2 = Object;
  var CORRECT_ARGUMENTS = classofRaw2(function() {
    return arguments;
  }()) == "Arguments";
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (error) {
    }
  };
  classof = TO_STRING_TAG_SUPPORT ? classofRaw2 : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object2(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw2(O) : (result = classofRaw2(O)) == "Object" && isCallable2(O.callee) ? "Arguments" : result;
  };
  return classof;
}
var objectToString;
var hasRequiredObjectToString;
function requireObjectToString() {
  if (hasRequiredObjectToString)
    return objectToString;
  hasRequiredObjectToString = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var classof2 = requireClassof();
  objectToString = TO_STRING_TAG_SUPPORT ? {}.toString : function toString2() {
    return "[object " + classof2(this) + "]";
  };
  return objectToString;
}
var setToStringTag;
var hasRequiredSetToStringTag;
function requireSetToStringTag() {
  if (hasRequiredSetToStringTag)
    return setToStringTag;
  hasRequiredSetToStringTag = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var defineProperty5 = objectDefineProperty.f;
  var createNonEnumerableProperty2 = createNonEnumerableProperty$1;
  var hasOwn2 = requireHasOwnProperty();
  var toString2 = requireObjectToString();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  setToStringTag = function(it, TAG, STATIC, SET_METHOD) {
    if (it) {
      var target = STATIC ? it : it.prototype;
      if (!hasOwn2(target, TO_STRING_TAG)) {
        defineProperty5(target, TO_STRING_TAG, { configurable: true, value: TAG });
      }
      if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
        createNonEnumerableProperty2(target, "toString", toString2);
      }
    }
  };
  return setToStringTag;
}
var iteratorCreateConstructor;
var hasRequiredIteratorCreateConstructor;
function requireIteratorCreateConstructor() {
  if (hasRequiredIteratorCreateConstructor)
    return iteratorCreateConstructor;
  hasRequiredIteratorCreateConstructor = 1;
  var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
  var create2 = requireObjectCreate();
  var createPropertyDescriptor2 = createPropertyDescriptor$2;
  var setToStringTag2 = requireSetToStringTag();
  var Iterators = requireIterators();
  var returnThis = function() {
    return this;
  };
  iteratorCreateConstructor = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + " Iterator";
    IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor2(+!ENUMERABLE_NEXT, next) });
    setToStringTag2(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
  };
  return iteratorCreateConstructor;
}
var functionUncurryThisAccessor;
var hasRequiredFunctionUncurryThisAccessor;
function requireFunctionUncurryThisAccessor() {
  if (hasRequiredFunctionUncurryThisAccessor)
    return functionUncurryThisAccessor;
  hasRequiredFunctionUncurryThisAccessor = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var aCallable2 = aCallable$2;
  functionUncurryThisAccessor = function(object, key, method) {
    try {
      return uncurryThis2(aCallable2(Object.getOwnPropertyDescriptor(object, key)[method]));
    } catch (error) {
    }
  };
  return functionUncurryThisAccessor;
}
var aPossiblePrototype;
var hasRequiredAPossiblePrototype;
function requireAPossiblePrototype() {
  if (hasRequiredAPossiblePrototype)
    return aPossiblePrototype;
  hasRequiredAPossiblePrototype = 1;
  var isCallable2 = isCallable$6;
  var $String2 = String;
  var $TypeError2 = TypeError;
  aPossiblePrototype = function(argument) {
    if (typeof argument == "object" || isCallable2(argument))
      return argument;
    throw $TypeError2("Can't set " + $String2(argument) + " as a prototype");
  };
  return aPossiblePrototype;
}
var objectSetPrototypeOf;
var hasRequiredObjectSetPrototypeOf;
function requireObjectSetPrototypeOf() {
  if (hasRequiredObjectSetPrototypeOf)
    return objectSetPrototypeOf;
  hasRequiredObjectSetPrototypeOf = 1;
  var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
  var anObject2 = anObject$1;
  var aPossiblePrototype2 = requireAPossiblePrototype();
  objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {
    }
    return function setPrototypeOf(O, proto) {
      anObject2(O);
      aPossiblePrototype2(proto);
      if (CORRECT_SETTER)
        setter(O, proto);
      else
        O.__proto__ = proto;
      return O;
    };
  }() : void 0);
  return objectSetPrototypeOf;
}
var iteratorDefine;
var hasRequiredIteratorDefine;
function requireIteratorDefine() {
  if (hasRequiredIteratorDefine)
    return iteratorDefine;
  hasRequiredIteratorDefine = 1;
  var $2 = _export;
  var call2 = functionCall;
  var IS_PURE = requireIsPure();
  var FunctionName = requireFunctionName();
  var isCallable2 = isCallable$6;
  var createIteratorConstructor = requireIteratorCreateConstructor();
  var getPrototypeOf = requireObjectGetPrototypeOf();
  var setPrototypeOf = requireObjectSetPrototypeOf();
  var setToStringTag2 = requireSetToStringTag();
  var createNonEnumerableProperty2 = createNonEnumerableProperty$1;
  var defineBuiltIn2 = requireDefineBuiltIn();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var Iterators = requireIterators();
  var IteratorsCore = requireIteratorsCore();
  var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
  var IteratorPrototype = IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR = wellKnownSymbol2("iterator");
  var KEYS = "keys";
  var VALUES = "values";
  var ENTRIES = "entries";
  var returnThis = function() {
    return this;
  };
  iteratorDefine = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator)
        return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
        return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS:
          return function keys() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG = NAME + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
          if (setPrototypeOf) {
            setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
          } else if (!isCallable2(CurrentIteratorPrototype[ITERATOR])) {
            defineBuiltIn2(CurrentIteratorPrototype, ITERATOR, returnThis);
          }
        }
        setToStringTag2(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
        if (IS_PURE)
          Iterators[TO_STRING_TAG] = returnThis;
      }
    }
    if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty2(IterablePrototype, "name", VALUES);
      } else {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() {
          return call2(nativeIterator, this);
        };
      }
    }
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED)
        for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn2(IterablePrototype, KEY, methods[KEY]);
          }
        }
      else
        $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }
    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
      defineBuiltIn2(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
    }
    Iterators[NAME] = defaultIterator;
    return methods;
  };
  return iteratorDefine;
}
var createIterResultObject;
var hasRequiredCreateIterResultObject;
function requireCreateIterResultObject() {
  if (hasRequiredCreateIterResultObject)
    return createIterResultObject;
  hasRequiredCreateIterResultObject = 1;
  createIterResultObject = function(value, done) {
    return { value, done };
  };
  return createIterResultObject;
}
var es_array_iterator;
var hasRequiredEs_array_iterator;
function requireEs_array_iterator() {
  if (hasRequiredEs_array_iterator)
    return es_array_iterator;
  hasRequiredEs_array_iterator = 1;
  var toIndexedObject2 = toIndexedObject$1;
  var addToUnscopables2 = requireAddToUnscopables();
  var Iterators = requireIterators();
  var InternalStateModule = requireInternalState();
  var defineProperty5 = objectDefineProperty.f;
  var defineIterator = requireIteratorDefine();
  var createIterResultObject2 = requireCreateIterResultObject();
  var IS_PURE = requireIsPure();
  var DESCRIPTORS2 = descriptors;
  var ARRAY_ITERATOR = "Array Iterator";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
  es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject2(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state = getInternalState(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = void 0;
      return createIterResultObject2(void 0, true);
    }
    if (kind == "keys")
      return createIterResultObject2(index, false);
    if (kind == "values")
      return createIterResultObject2(target[index], false);
    return createIterResultObject2([index, target[index]], false);
  }, "values");
  var values = Iterators.Arguments = Iterators.Array;
  addToUnscopables2("keys");
  addToUnscopables2("values");
  addToUnscopables2("entries");
  if (!IS_PURE && DESCRIPTORS2 && values.name !== "values")
    try {
      defineProperty5(values, "name", { value: "values" });
    } catch (error) {
    }
  return es_array_iterator;
}
var es_string_iterator = {};
var toString;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString)
    return toString;
  hasRequiredToString = 1;
  var classof2 = requireClassof();
  var $String2 = String;
  toString = function(argument) {
    if (classof2(argument) === "Symbol")
      throw TypeError("Cannot convert a Symbol value to a string");
    return $String2(argument);
  };
  return toString;
}
var stringMultibyte;
var hasRequiredStringMultibyte;
function requireStringMultibyte() {
  if (hasRequiredStringMultibyte)
    return stringMultibyte;
  hasRequiredStringMultibyte = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toString2 = requireToString();
  var requireObjectCoercible2 = requireObjectCoercible$1;
  var charAt = uncurryThis2("".charAt);
  var charCodeAt = uncurryThis2("".charCodeAt);
  var stringSlice = uncurryThis2("".slice);
  var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
      var S = toString2(requireObjectCoercible2($this));
      var position = toIntegerOrInfinity2(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size)
        return CONVERT_TO_STRING ? "" : void 0;
      first = charCodeAt(S, position);
      return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
    };
  };
  stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
  };
  return stringMultibyte;
}
var hasRequiredEs_string_iterator;
function requireEs_string_iterator() {
  if (hasRequiredEs_string_iterator)
    return es_string_iterator;
  hasRequiredEs_string_iterator = 1;
  var charAt = requireStringMultibyte().charAt;
  var toString2 = requireToString();
  var InternalStateModule = requireInternalState();
  var defineIterator = requireIteratorDefine();
  var createIterResultObject2 = requireCreateIterResultObject();
  var STRING_ITERATOR = "String Iterator";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
  defineIterator(String, "String", function(iterated) {
    setInternalState(this, {
      type: STRING_ITERATOR,
      string: toString2(iterated),
      index: 0
    });
  }, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length)
      return createIterResultObject2(void 0, true);
    point = charAt(string, index);
    state.index += point.length;
    return createIterResultObject2(point, false);
  });
  return es_string_iterator;
}
var getIteratorMethod$5;
var hasRequiredGetIteratorMethod$6;
function requireGetIteratorMethod$6() {
  if (hasRequiredGetIteratorMethod$6)
    return getIteratorMethod$5;
  hasRequiredGetIteratorMethod$6 = 1;
  var classof2 = requireClassof();
  var getMethod2 = getMethod$1;
  var isNullOrUndefined2 = isNullOrUndefined$2;
  var Iterators = requireIterators();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var ITERATOR = wellKnownSymbol2("iterator");
  getIteratorMethod$5 = function(it) {
    if (!isNullOrUndefined2(it))
      return getMethod2(it, ITERATOR) || getMethod2(it, "@@iterator") || Iterators[classof2(it)];
  };
  return getIteratorMethod$5;
}
var getIterator$3;
var hasRequiredGetIterator$6;
function requireGetIterator$6() {
  if (hasRequiredGetIterator$6)
    return getIterator$3;
  hasRequiredGetIterator$6 = 1;
  var call2 = functionCall;
  var aCallable2 = aCallable$2;
  var anObject2 = anObject$1;
  var tryToString2 = tryToString$1;
  var getIteratorMethod2 = requireGetIteratorMethod$6();
  var $TypeError2 = TypeError;
  getIterator$3 = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod2(argument) : usingIterator;
    if (aCallable2(iteratorMethod))
      return anObject2(call2(iteratorMethod, argument));
    throw $TypeError2(tryToString2(argument) + " is not iterable");
  };
  return getIterator$3;
}
var getIterator_1;
var hasRequiredGetIterator$5;
function requireGetIterator$5() {
  if (hasRequiredGetIterator$5)
    return getIterator_1;
  hasRequiredGetIterator$5 = 1;
  requireEs_array_iterator();
  requireEs_string_iterator();
  var getIterator2 = requireGetIterator$6();
  getIterator_1 = getIterator2;
  return getIterator_1;
}
var web_domCollections_iterator = {};
var domIterables;
var hasRequiredDomIterables;
function requireDomIterables() {
  if (hasRequiredDomIterables)
    return domIterables;
  hasRequiredDomIterables = 1;
  domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  return domIterables;
}
var hasRequiredWeb_domCollections_iterator;
function requireWeb_domCollections_iterator() {
  if (hasRequiredWeb_domCollections_iterator)
    return web_domCollections_iterator;
  hasRequiredWeb_domCollections_iterator = 1;
  requireEs_array_iterator();
  var DOMIterables = requireDomIterables();
  var global2 = global$3;
  var classof2 = requireClassof();
  var createNonEnumerableProperty2 = createNonEnumerableProperty$1;
  var Iterators = requireIterators();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  for (var COLLECTION_NAME in DOMIterables) {
    var Collection = global2[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype && classof2(CollectionPrototype) !== TO_STRING_TAG) {
      createNonEnumerableProperty2(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    Iterators[COLLECTION_NAME] = Iterators.Array;
  }
  return web_domCollections_iterator;
}
var getIterator$2;
var hasRequiredGetIterator$4;
function requireGetIterator$4() {
  if (hasRequiredGetIterator$4)
    return getIterator$2;
  hasRequiredGetIterator$4 = 1;
  var parent2 = requireGetIterator$5();
  requireWeb_domCollections_iterator();
  getIterator$2 = parent2;
  return getIterator$2;
}
var getIterator$1;
var hasRequiredGetIterator$3;
function requireGetIterator$3() {
  if (hasRequiredGetIterator$3)
    return getIterator$1;
  hasRequiredGetIterator$3 = 1;
  var parent2 = requireGetIterator$4();
  getIterator$1 = parent2;
  return getIterator$1;
}
var getIterator;
var hasRequiredGetIterator$2;
function requireGetIterator$2() {
  if (hasRequiredGetIterator$2)
    return getIterator;
  hasRequiredGetIterator$2 = 1;
  var parent2 = requireGetIterator$3();
  getIterator = parent2;
  return getIterator;
}
var hasRequiredGetIterator$1;
function requireGetIterator$1() {
  if (hasRequiredGetIterator$1)
    return getIteratorExports;
  hasRequiredGetIterator$1 = 1;
  (function(module) {
    module.exports = requireGetIterator$2();
  })(getIterator$4);
  return getIteratorExports;
}
var hasRequiredGetIterator;
function requireGetIterator() {
  if (hasRequiredGetIterator)
    return getIteratorExports$1;
  hasRequiredGetIterator = 1;
  (function(module) {
    module.exports = requireGetIterator$1();
  })(getIterator$5);
  return getIteratorExports$1;
}
var isArrayExports$2 = {};
var isArray$7 = {
  get exports() {
    return isArrayExports$2;
  },
  set exports(v) {
    isArrayExports$2 = v;
  }
};
var es_array_isArray = {};
var isArray$6;
var hasRequiredIsArray$7;
function requireIsArray$7() {
  if (hasRequiredIsArray$7)
    return isArray$6;
  hasRequiredIsArray$7 = 1;
  var classof2 = requireClassofRaw();
  isArray$6 = Array.isArray || function isArray2(argument) {
    return classof2(argument) == "Array";
  };
  return isArray$6;
}
var hasRequiredEs_array_isArray;
function requireEs_array_isArray() {
  if (hasRequiredEs_array_isArray)
    return es_array_isArray;
  hasRequiredEs_array_isArray = 1;
  var $2 = _export;
  var isArray2 = requireIsArray$7();
  $2({ target: "Array", stat: true }, {
    isArray: isArray2
  });
  return es_array_isArray;
}
var isArray$5;
var hasRequiredIsArray$6;
function requireIsArray$6() {
  if (hasRequiredIsArray$6)
    return isArray$5;
  hasRequiredIsArray$6 = 1;
  requireEs_array_isArray();
  var path2 = path$2;
  isArray$5 = path2.Array.isArray;
  return isArray$5;
}
var isArray$4;
var hasRequiredIsArray$5;
function requireIsArray$5() {
  if (hasRequiredIsArray$5)
    return isArray$4;
  hasRequiredIsArray$5 = 1;
  var parent2 = requireIsArray$6();
  isArray$4 = parent2;
  return isArray$4;
}
var hasRequiredIsArray$4;
function requireIsArray$4() {
  if (hasRequiredIsArray$4)
    return isArrayExports$2;
  hasRequiredIsArray$4 = 1;
  (function(module) {
    module.exports = requireIsArray$5();
  })(isArray$7);
  return isArrayExports$2;
}
var getIteratorMethodExports$1 = {};
var getIteratorMethod$4 = {
  get exports() {
    return getIteratorMethodExports$1;
  },
  set exports(v) {
    getIteratorMethodExports$1 = v;
  }
};
var getIteratorMethodExports = {};
var getIteratorMethod$3 = {
  get exports() {
    return getIteratorMethodExports;
  },
  set exports(v) {
    getIteratorMethodExports = v;
  }
};
var getIteratorMethod_1;
var hasRequiredGetIteratorMethod$5;
function requireGetIteratorMethod$5() {
  if (hasRequiredGetIteratorMethod$5)
    return getIteratorMethod_1;
  hasRequiredGetIteratorMethod$5 = 1;
  requireEs_array_iterator();
  requireEs_string_iterator();
  var getIteratorMethod2 = requireGetIteratorMethod$6();
  getIteratorMethod_1 = getIteratorMethod2;
  return getIteratorMethod_1;
}
var getIteratorMethod$2;
var hasRequiredGetIteratorMethod$4;
function requireGetIteratorMethod$4() {
  if (hasRequiredGetIteratorMethod$4)
    return getIteratorMethod$2;
  hasRequiredGetIteratorMethod$4 = 1;
  var parent2 = requireGetIteratorMethod$5();
  requireWeb_domCollections_iterator();
  getIteratorMethod$2 = parent2;
  return getIteratorMethod$2;
}
var getIteratorMethod$1;
var hasRequiredGetIteratorMethod$3;
function requireGetIteratorMethod$3() {
  if (hasRequiredGetIteratorMethod$3)
    return getIteratorMethod$1;
  hasRequiredGetIteratorMethod$3 = 1;
  var parent2 = requireGetIteratorMethod$4();
  getIteratorMethod$1 = parent2;
  return getIteratorMethod$1;
}
var getIteratorMethod;
var hasRequiredGetIteratorMethod$2;
function requireGetIteratorMethod$2() {
  if (hasRequiredGetIteratorMethod$2)
    return getIteratorMethod;
  hasRequiredGetIteratorMethod$2 = 1;
  var parent2 = requireGetIteratorMethod$3();
  getIteratorMethod = parent2;
  return getIteratorMethod;
}
var hasRequiredGetIteratorMethod$1;
function requireGetIteratorMethod$1() {
  if (hasRequiredGetIteratorMethod$1)
    return getIteratorMethodExports;
  hasRequiredGetIteratorMethod$1 = 1;
  (function(module) {
    module.exports = requireGetIteratorMethod$2();
  })(getIteratorMethod$3);
  return getIteratorMethodExports;
}
var hasRequiredGetIteratorMethod;
function requireGetIteratorMethod() {
  if (hasRequiredGetIteratorMethod)
    return getIteratorMethodExports$1;
  hasRequiredGetIteratorMethod = 1;
  (function(module) {
    module.exports = requireGetIteratorMethod$1();
  })(getIteratorMethod$4);
  return getIteratorMethodExports$1;
}
var symbolExports$2 = {};
var symbol$6 = {
  get exports() {
    return symbolExports$2;
  },
  set exports(v) {
    symbolExports$2 = v;
  }
};
var es_array_concat = {};
var doesNotExceedSafeInteger;
var hasRequiredDoesNotExceedSafeInteger;
function requireDoesNotExceedSafeInteger() {
  if (hasRequiredDoesNotExceedSafeInteger)
    return doesNotExceedSafeInteger;
  hasRequiredDoesNotExceedSafeInteger = 1;
  var $TypeError2 = TypeError;
  var MAX_SAFE_INTEGER = 9007199254740991;
  doesNotExceedSafeInteger = function(it) {
    if (it > MAX_SAFE_INTEGER)
      throw $TypeError2("Maximum allowed index exceeded");
    return it;
  };
  return doesNotExceedSafeInteger;
}
var createProperty;
var hasRequiredCreateProperty;
function requireCreateProperty() {
  if (hasRequiredCreateProperty)
    return createProperty;
  hasRequiredCreateProperty = 1;
  var toPropertyKey2 = toPropertyKey$2;
  var definePropertyModule2 = objectDefineProperty;
  var createPropertyDescriptor2 = createPropertyDescriptor$2;
  createProperty = function(object, key, value) {
    var propertyKey = toPropertyKey2(key);
    if (propertyKey in object)
      definePropertyModule2.f(object, propertyKey, createPropertyDescriptor2(0, value));
    else
      object[propertyKey] = value;
  };
  return createProperty;
}
var inspectSource;
var hasRequiredInspectSource;
function requireInspectSource() {
  if (hasRequiredInspectSource)
    return inspectSource;
  hasRequiredInspectSource = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var isCallable2 = isCallable$6;
  var store = requireSharedStore();
  var functionToString = uncurryThis2(Function.toString);
  if (!isCallable2(store.inspectSource)) {
    store.inspectSource = function(it) {
      return functionToString(it);
    };
  }
  inspectSource = store.inspectSource;
  return inspectSource;
}
var isConstructor;
var hasRequiredIsConstructor;
function requireIsConstructor() {
  if (hasRequiredIsConstructor)
    return isConstructor;
  hasRequiredIsConstructor = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var fails2 = fails$6;
  var isCallable2 = isCallable$6;
  var classof2 = requireClassof();
  var getBuiltIn2 = requireGetBuiltIn();
  var inspectSource2 = requireInspectSource();
  var noop = function() {
  };
  var empty = [];
  var construct = getBuiltIn2("Reflect", "construct");
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = uncurryThis2(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
  var isConstructorModern = function isConstructor2(argument) {
    if (!isCallable2(argument))
      return false;
    try {
      construct(noop, empty, argument);
      return true;
    } catch (error) {
      return false;
    }
  };
  var isConstructorLegacy = function isConstructor2(argument) {
    if (!isCallable2(argument))
      return false;
    switch (classof2(argument)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource2(argument));
    } catch (error) {
      return true;
    }
  };
  isConstructorLegacy.sham = true;
  isConstructor = !construct || fails2(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;
  return isConstructor;
}
var arraySpeciesConstructor;
var hasRequiredArraySpeciesConstructor;
function requireArraySpeciesConstructor() {
  if (hasRequiredArraySpeciesConstructor)
    return arraySpeciesConstructor;
  hasRequiredArraySpeciesConstructor = 1;
  var isArray2 = requireIsArray$7();
  var isConstructor2 = requireIsConstructor();
  var isObject2 = isObject$4;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var SPECIES = wellKnownSymbol2("species");
  var $Array = Array;
  arraySpeciesConstructor = function(originalArray) {
    var C;
    if (isArray2(originalArray)) {
      C = originalArray.constructor;
      if (isConstructor2(C) && (C === $Array || isArray2(C.prototype)))
        C = void 0;
      else if (isObject2(C)) {
        C = C[SPECIES];
        if (C === null)
          C = void 0;
      }
    }
    return C === void 0 ? $Array : C;
  };
  return arraySpeciesConstructor;
}
var arraySpeciesCreate;
var hasRequiredArraySpeciesCreate;
function requireArraySpeciesCreate() {
  if (hasRequiredArraySpeciesCreate)
    return arraySpeciesCreate;
  hasRequiredArraySpeciesCreate = 1;
  var arraySpeciesConstructor2 = requireArraySpeciesConstructor();
  arraySpeciesCreate = function(originalArray, length) {
    return new (arraySpeciesConstructor2(originalArray))(length === 0 ? 0 : length);
  };
  return arraySpeciesCreate;
}
var arrayMethodHasSpeciesSupport;
var hasRequiredArrayMethodHasSpeciesSupport;
function requireArrayMethodHasSpeciesSupport() {
  if (hasRequiredArrayMethodHasSpeciesSupport)
    return arrayMethodHasSpeciesSupport;
  hasRequiredArrayMethodHasSpeciesSupport = 1;
  var fails2 = fails$6;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var V8_VERSION = requireEngineV8Version();
  var SPECIES = wellKnownSymbol2("species");
  arrayMethodHasSpeciesSupport = function(METHOD_NAME) {
    return V8_VERSION >= 51 || !fails2(function() {
      var array = [];
      var constructor = array.constructor = {};
      constructor[SPECIES] = function() {
        return { foo: 1 };
      };
      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };
  return arrayMethodHasSpeciesSupport;
}
var hasRequiredEs_array_concat;
function requireEs_array_concat() {
  if (hasRequiredEs_array_concat)
    return es_array_concat;
  hasRequiredEs_array_concat = 1;
  var $2 = _export;
  var fails2 = fails$6;
  var isArray2 = requireIsArray$7();
  var isObject2 = isObject$4;
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var doesNotExceedSafeInteger2 = requireDoesNotExceedSafeInteger();
  var createProperty2 = requireCreateProperty();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  var arrayMethodHasSpeciesSupport2 = requireArrayMethodHasSpeciesSupport();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var V8_VERSION = requireEngineV8Version();
  var IS_CONCAT_SPREADABLE = wellKnownSymbol2("isConcatSpreadable");
  var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails2(function() {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });
  var isConcatSpreadable = function(O) {
    if (!isObject2(O))
      return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== void 0 ? !!spreadable : isArray2(O);
  };
  var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport2("concat");
  $2({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat2(arg) {
      var O = toObject2(this);
      var A = arraySpeciesCreate2(O, 0);
      var n = 0;
      var i, k, length, len, E;
      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];
        if (isConcatSpreadable(E)) {
          len = lengthOfArrayLike2(E);
          doesNotExceedSafeInteger2(n + len);
          for (k = 0; k < len; k++, n++)
            if (k in E)
              createProperty2(A, n, E[k]);
        } else {
          doesNotExceedSafeInteger2(n + 1);
          createProperty2(A, n++, E);
        }
      }
      A.length = n;
      return A;
    }
  });
  return es_array_concat;
}
var es_symbol = {};
var es_symbol_constructor = {};
var objectGetOwnPropertyNames = {};
var hasRequiredObjectGetOwnPropertyNames;
function requireObjectGetOwnPropertyNames() {
  if (hasRequiredObjectGetOwnPropertyNames)
    return objectGetOwnPropertyNames;
  hasRequiredObjectGetOwnPropertyNames = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = enumBugKeys2.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys2);
  };
  return objectGetOwnPropertyNames;
}
var objectGetOwnPropertyNamesExternal = {};
var arraySliceSimple;
var hasRequiredArraySliceSimple;
function requireArraySliceSimple() {
  if (hasRequiredArraySliceSimple)
    return arraySliceSimple;
  hasRequiredArraySliceSimple = 1;
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var createProperty2 = requireCreateProperty();
  var $Array = Array;
  var max = Math.max;
  arraySliceSimple = function(O, start, end) {
    var length = lengthOfArrayLike2(O);
    var k = toAbsoluteIndex2(start, length);
    var fin = toAbsoluteIndex2(end === void 0 ? length : end, length);
    var result = $Array(max(fin - k, 0));
    for (var n = 0; k < fin; k++, n++)
      createProperty2(result, n, O[k]);
    result.length = n;
    return result;
  };
  return arraySliceSimple;
}
var hasRequiredObjectGetOwnPropertyNamesExternal;
function requireObjectGetOwnPropertyNamesExternal() {
  if (hasRequiredObjectGetOwnPropertyNamesExternal)
    return objectGetOwnPropertyNamesExternal;
  hasRequiredObjectGetOwnPropertyNamesExternal = 1;
  var classof2 = requireClassofRaw();
  var toIndexedObject2 = toIndexedObject$1;
  var $getOwnPropertyNames = requireObjectGetOwnPropertyNames().f;
  var arraySlice2 = requireArraySliceSimple();
  var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return $getOwnPropertyNames(it);
    } catch (error) {
      return arraySlice2(windowNames);
    }
  };
  objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
    return windowNames && classof2(it) == "Window" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject2(it));
  };
  return objectGetOwnPropertyNamesExternal;
}
var objectGetOwnPropertySymbols = {};
var hasRequiredObjectGetOwnPropertySymbols;
function requireObjectGetOwnPropertySymbols() {
  if (hasRequiredObjectGetOwnPropertySymbols)
    return objectGetOwnPropertySymbols;
  hasRequiredObjectGetOwnPropertySymbols = 1;
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  return objectGetOwnPropertySymbols;
}
var defineBuiltInAccessor;
var hasRequiredDefineBuiltInAccessor;
function requireDefineBuiltInAccessor() {
  if (hasRequiredDefineBuiltInAccessor)
    return defineBuiltInAccessor;
  hasRequiredDefineBuiltInAccessor = 1;
  var defineProperty5 = objectDefineProperty;
  defineBuiltInAccessor = function(target, name, descriptor) {
    return defineProperty5.f(target, name, descriptor);
  };
  return defineBuiltInAccessor;
}
var wellKnownSymbolWrapped = {};
var hasRequiredWellKnownSymbolWrapped;
function requireWellKnownSymbolWrapped() {
  if (hasRequiredWellKnownSymbolWrapped)
    return wellKnownSymbolWrapped;
  hasRequiredWellKnownSymbolWrapped = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  wellKnownSymbolWrapped.f = wellKnownSymbol2;
  return wellKnownSymbolWrapped;
}
var wellKnownSymbolDefine;
var hasRequiredWellKnownSymbolDefine;
function requireWellKnownSymbolDefine() {
  if (hasRequiredWellKnownSymbolDefine)
    return wellKnownSymbolDefine;
  hasRequiredWellKnownSymbolDefine = 1;
  var path2 = path$2;
  var hasOwn2 = requireHasOwnProperty();
  var wrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
  var defineProperty5 = objectDefineProperty.f;
  wellKnownSymbolDefine = function(NAME) {
    var Symbol2 = path2.Symbol || (path2.Symbol = {});
    if (!hasOwn2(Symbol2, NAME))
      defineProperty5(Symbol2, NAME, {
        value: wrappedWellKnownSymbolModule.f(NAME)
      });
  };
  return wellKnownSymbolDefine;
}
var symbolDefineToPrimitive;
var hasRequiredSymbolDefineToPrimitive;
function requireSymbolDefineToPrimitive() {
  if (hasRequiredSymbolDefineToPrimitive)
    return symbolDefineToPrimitive;
  hasRequiredSymbolDefineToPrimitive = 1;
  var call2 = functionCall;
  var getBuiltIn2 = requireGetBuiltIn();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var defineBuiltIn2 = requireDefineBuiltIn();
  symbolDefineToPrimitive = function() {
    var Symbol2 = getBuiltIn2("Symbol");
    var SymbolPrototype = Symbol2 && Symbol2.prototype;
    var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
    var TO_PRIMITIVE2 = wellKnownSymbol2("toPrimitive");
    if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE2]) {
      defineBuiltIn2(SymbolPrototype, TO_PRIMITIVE2, function(hint) {
        return call2(valueOf, this);
      }, { arity: 1 });
    }
  };
  return symbolDefineToPrimitive;
}
var arrayIteration;
var hasRequiredArrayIteration;
function requireArrayIteration() {
  if (hasRequiredArrayIteration)
    return arrayIteration;
  hasRequiredArrayIteration = 1;
  var bind2 = functionBindContext;
  var uncurryThis2 = requireFunctionUncurryThis();
  var IndexedObject2 = indexedObject;
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var arraySpeciesCreate2 = requireArraySpeciesCreate();
  var push = uncurryThis2([].push);
  var createMethod = function(TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_REJECT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that, specificCreate) {
      var O = toObject2($this);
      var self2 = IndexedObject2(O);
      var boundFunction = bind2(callbackfn, that);
      var length = lengthOfArrayLike2(self2);
      var index = 0;
      var create2 = specificCreate || arraySpeciesCreate2;
      var target = IS_MAP ? create2($this, length) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
      var value, result;
      for (; length > index; index++)
        if (NO_HOLES || index in self2) {
          value = self2[index];
          result = boundFunction(value, index, O);
          if (TYPE) {
            if (IS_MAP)
              target[index] = result;
            else if (result)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return value;
                case 6:
                  return index;
                case 2:
                  push(target, value);
              }
            else
              switch (TYPE) {
                case 4:
                  return false;
                case 7:
                  push(target, value);
              }
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };
  arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod(7)
  };
  return arrayIteration;
}
var hasRequiredEs_symbol_constructor;
function requireEs_symbol_constructor() {
  if (hasRequiredEs_symbol_constructor)
    return es_symbol_constructor;
  hasRequiredEs_symbol_constructor = 1;
  var $2 = _export;
  var global2 = global$3;
  var call2 = functionCall;
  var uncurryThis2 = requireFunctionUncurryThis();
  var IS_PURE = requireIsPure();
  var DESCRIPTORS2 = descriptors;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var fails2 = fails$6;
  var hasOwn2 = requireHasOwnProperty();
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var anObject2 = anObject$1;
  var toIndexedObject2 = toIndexedObject$1;
  var toPropertyKey2 = toPropertyKey$2;
  var $toString = requireToString();
  var createPropertyDescriptor2 = createPropertyDescriptor$2;
  var nativeObjectCreate = requireObjectCreate();
  var objectKeys2 = requireObjectKeys();
  var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
  var getOwnPropertyNamesExternal = requireObjectGetOwnPropertyNamesExternal();
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var definePropertyModule2 = objectDefineProperty;
  var definePropertiesModule = requireObjectDefineProperties();
  var propertyIsEnumerableModule2 = objectPropertyIsEnumerable;
  var defineBuiltIn2 = requireDefineBuiltIn();
  var defineBuiltInAccessor2 = requireDefineBuiltInAccessor();
  var shared2 = requireShared();
  var sharedKey2 = requireSharedKey();
  var hiddenKeys2 = requireHiddenKeys();
  var uid2 = requireUid();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var wrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  var defineSymbolToPrimitive = requireSymbolDefineToPrimitive();
  var setToStringTag2 = requireSetToStringTag();
  var InternalStateModule = requireInternalState();
  var $forEach = requireArrayIteration().forEach;
  var HIDDEN = sharedKey2("hidden");
  var SYMBOL = "Symbol";
  var PROTOTYPE = "prototype";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(SYMBOL);
  var ObjectPrototype = Object[PROTOTYPE];
  var $Symbol = global2.Symbol;
  var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
  var TypeError2 = global2.TypeError;
  var QObject = global2.QObject;
  var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  var nativeDefineProperty = definePropertyModule2.f;
  var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
  var nativePropertyIsEnumerable = propertyIsEnumerableModule2.f;
  var push = uncurryThis2([].push);
  var AllSymbols = shared2("symbols");
  var ObjectPrototypeSymbols = shared2("op-symbols");
  var WellKnownSymbolsStore = shared2("wks");
  var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
  var setSymbolDescriptor = DESCRIPTORS2 && fails2(function() {
    return nativeObjectCreate(nativeDefineProperty({}, "a", {
      get: function() {
        return nativeDefineProperty(this, "a", { value: 7 }).a;
      }
    })).a != 7;
  }) ? function(O, P, Attributes) {
    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
    if (ObjectPrototypeDescriptor)
      delete ObjectPrototype[P];
    nativeDefineProperty(O, P, Attributes);
    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
      nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
    }
  } : nativeDefineProperty;
  var wrap = function(tag, description) {
    var symbol2 = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
    setInternalState(symbol2, {
      type: SYMBOL,
      tag,
      description
    });
    if (!DESCRIPTORS2)
      symbol2.description = description;
    return symbol2;
  };
  var $defineProperty2 = function defineProperty5(O, P, Attributes) {
    if (O === ObjectPrototype)
      $defineProperty2(ObjectPrototypeSymbols, P, Attributes);
    anObject2(O);
    var key = toPropertyKey2(P);
    anObject2(Attributes);
    if (hasOwn2(AllSymbols, key)) {
      if (!Attributes.enumerable) {
        if (!hasOwn2(O, HIDDEN))
          nativeDefineProperty(O, HIDDEN, createPropertyDescriptor2(1, {}));
        O[HIDDEN][key] = true;
      } else {
        if (hasOwn2(O, HIDDEN) && O[HIDDEN][key])
          O[HIDDEN][key] = false;
        Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor2(0, false) });
      }
      return setSymbolDescriptor(O, key, Attributes);
    }
    return nativeDefineProperty(O, key, Attributes);
  };
  var $defineProperties = function defineProperties(O, Properties) {
    anObject2(O);
    var properties2 = toIndexedObject2(Properties);
    var keys = objectKeys2(properties2).concat($getOwnPropertySymbols(properties2));
    $forEach(keys, function(key) {
      if (!DESCRIPTORS2 || call2($propertyIsEnumerable2, properties2, key))
        $defineProperty2(O, key, properties2[key]);
    });
    return O;
  };
  var $create = function create2(O, Properties) {
    return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
  };
  var $propertyIsEnumerable2 = function propertyIsEnumerable2(V) {
    var P = toPropertyKey2(V);
    var enumerable = call2(nativePropertyIsEnumerable, this, P);
    if (this === ObjectPrototype && hasOwn2(AllSymbols, P) && !hasOwn2(ObjectPrototypeSymbols, P))
      return false;
    return enumerable || !hasOwn2(this, P) || !hasOwn2(AllSymbols, P) || hasOwn2(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
  };
  var $getOwnPropertyDescriptor2 = function getOwnPropertyDescriptor3(O, P) {
    var it = toIndexedObject2(O);
    var key = toPropertyKey2(P);
    if (it === ObjectPrototype && hasOwn2(AllSymbols, key) && !hasOwn2(ObjectPrototypeSymbols, key))
      return;
    var descriptor = nativeGetOwnPropertyDescriptor(it, key);
    if (descriptor && hasOwn2(AllSymbols, key) && !(hasOwn2(it, HIDDEN) && it[HIDDEN][key])) {
      descriptor.enumerable = true;
    }
    return descriptor;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(O) {
    var names = nativeGetOwnPropertyNames(toIndexedObject2(O));
    var result = [];
    $forEach(names, function(key) {
      if (!hasOwn2(AllSymbols, key) && !hasOwn2(hiddenKeys2, key))
        push(result, key);
    });
    return result;
  };
  var $getOwnPropertySymbols = function(O) {
    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject2(O));
    var result = [];
    $forEach(names, function(key) {
      if (hasOwn2(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn2(ObjectPrototype, key))) {
        push(result, AllSymbols[key]);
      }
    });
    return result;
  };
  if (!NATIVE_SYMBOL) {
    $Symbol = function Symbol2() {
      if (isPrototypeOf2(SymbolPrototype, this))
        throw TypeError2("Symbol is not a constructor");
      var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
      var tag = uid2(description);
      var setter = function(value) {
        if (this === ObjectPrototype)
          call2(setter, ObjectPrototypeSymbols, value);
        if (hasOwn2(this, HIDDEN) && hasOwn2(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDescriptor(this, tag, createPropertyDescriptor2(1, value));
      };
      if (DESCRIPTORS2 && USE_SETTER)
        setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
      return wrap(tag, description);
    };
    SymbolPrototype = $Symbol[PROTOTYPE];
    defineBuiltIn2(SymbolPrototype, "toString", function toString2() {
      return getInternalState(this).tag;
    });
    defineBuiltIn2($Symbol, "withoutSetter", function(description) {
      return wrap(uid2(description), description);
    });
    propertyIsEnumerableModule2.f = $propertyIsEnumerable2;
    definePropertyModule2.f = $defineProperty2;
    definePropertiesModule.f = $defineProperties;
    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor2;
    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
    getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
    wrappedWellKnownSymbolModule.f = function(name) {
      return wrap(wellKnownSymbol2(name), name);
    };
    if (DESCRIPTORS2) {
      defineBuiltInAccessor2(SymbolPrototype, "description", {
        configurable: true,
        get: function description() {
          return getInternalState(this).description;
        }
      });
      if (!IS_PURE) {
        defineBuiltIn2(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable2, { unsafe: true });
      }
    }
  }
  $2({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
    Symbol: $Symbol
  });
  $forEach(objectKeys2(WellKnownSymbolsStore), function(name) {
    defineWellKnownSymbol(name);
  });
  $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
    useSetter: function() {
      USE_SETTER = true;
    },
    useSimple: function() {
      USE_SETTER = false;
    }
  });
  $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS2 }, {
    // `Object.create` method
    // https://tc39.es/ecma262/#sec-object.create
    create: $create,
    // `Object.defineProperty` method
    // https://tc39.es/ecma262/#sec-object.defineproperty
    defineProperty: $defineProperty2,
    // `Object.defineProperties` method
    // https://tc39.es/ecma262/#sec-object.defineproperties
    defineProperties: $defineProperties,
    // `Object.getOwnPropertyDescriptor` method
    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor2
  });
  $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
    // `Object.getOwnPropertyNames` method
    // https://tc39.es/ecma262/#sec-object.getownpropertynames
    getOwnPropertyNames: $getOwnPropertyNames
  });
  defineSymbolToPrimitive();
  setToStringTag2($Symbol, SYMBOL);
  hiddenKeys2[HIDDEN] = true;
  return es_symbol_constructor;
}
var es_symbol_for = {};
var symbolRegistryDetection;
var hasRequiredSymbolRegistryDetection;
function requireSymbolRegistryDetection() {
  if (hasRequiredSymbolRegistryDetection)
    return symbolRegistryDetection;
  hasRequiredSymbolRegistryDetection = 1;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  symbolRegistryDetection = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
  return symbolRegistryDetection;
}
var hasRequiredEs_symbol_for;
function requireEs_symbol_for() {
  if (hasRequiredEs_symbol_for)
    return es_symbol_for;
  hasRequiredEs_symbol_for = 1;
  var $2 = _export;
  var getBuiltIn2 = requireGetBuiltIn();
  var hasOwn2 = requireHasOwnProperty();
  var toString2 = requireToString();
  var shared2 = requireShared();
  var NATIVE_SYMBOL_REGISTRY = requireSymbolRegistryDetection();
  var StringToSymbolRegistry = shared2("string-to-symbol-registry");
  var SymbolToStringRegistry = shared2("symbol-to-string-registry");
  $2({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
    "for": function(key) {
      var string = toString2(key);
      if (hasOwn2(StringToSymbolRegistry, string))
        return StringToSymbolRegistry[string];
      var symbol2 = getBuiltIn2("Symbol")(string);
      StringToSymbolRegistry[string] = symbol2;
      SymbolToStringRegistry[symbol2] = string;
      return symbol2;
    }
  });
  return es_symbol_for;
}
var es_symbol_keyFor = {};
var hasRequiredEs_symbol_keyFor;
function requireEs_symbol_keyFor() {
  if (hasRequiredEs_symbol_keyFor)
    return es_symbol_keyFor;
  hasRequiredEs_symbol_keyFor = 1;
  var $2 = _export;
  var hasOwn2 = requireHasOwnProperty();
  var isSymbol2 = isSymbol$2;
  var tryToString2 = tryToString$1;
  var shared2 = requireShared();
  var NATIVE_SYMBOL_REGISTRY = requireSymbolRegistryDetection();
  var SymbolToStringRegistry = shared2("symbol-to-string-registry");
  $2({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
    keyFor: function keyFor(sym) {
      if (!isSymbol2(sym))
        throw TypeError(tryToString2(sym) + " is not a symbol");
      if (hasOwn2(SymbolToStringRegistry, sym))
        return SymbolToStringRegistry[sym];
    }
  });
  return es_symbol_keyFor;
}
var es_json_stringify = {};
var arraySlice;
var hasRequiredArraySlice;
function requireArraySlice() {
  if (hasRequiredArraySlice)
    return arraySlice;
  hasRequiredArraySlice = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  arraySlice = uncurryThis2([].slice);
  return arraySlice;
}
var getJsonReplacerFunction;
var hasRequiredGetJsonReplacerFunction;
function requireGetJsonReplacerFunction() {
  if (hasRequiredGetJsonReplacerFunction)
    return getJsonReplacerFunction;
  hasRequiredGetJsonReplacerFunction = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var isArray2 = requireIsArray$7();
  var isCallable2 = isCallable$6;
  var classof2 = requireClassofRaw();
  var toString2 = requireToString();
  var push = uncurryThis2([].push);
  getJsonReplacerFunction = function(replacer) {
    if (isCallable2(replacer))
      return replacer;
    if (!isArray2(replacer))
      return;
    var rawLength = replacer.length;
    var keys = [];
    for (var i = 0; i < rawLength; i++) {
      var element = replacer[i];
      if (typeof element == "string")
        push(keys, element);
      else if (typeof element == "number" || classof2(element) == "Number" || classof2(element) == "String")
        push(keys, toString2(element));
    }
    var keysLength = keys.length;
    var root = true;
    return function(key, value) {
      if (root) {
        root = false;
        return value;
      }
      if (isArray2(this))
        return value;
      for (var j = 0; j < keysLength; j++)
        if (keys[j] === key)
          return value;
    };
  };
  return getJsonReplacerFunction;
}
var hasRequiredEs_json_stringify;
function requireEs_json_stringify() {
  if (hasRequiredEs_json_stringify)
    return es_json_stringify;
  hasRequiredEs_json_stringify = 1;
  var $2 = _export;
  var getBuiltIn2 = requireGetBuiltIn();
  var apply2 = functionApply;
  var call2 = functionCall;
  var uncurryThis2 = requireFunctionUncurryThis();
  var fails2 = fails$6;
  var isCallable2 = isCallable$6;
  var isSymbol2 = isSymbol$2;
  var arraySlice2 = requireArraySlice();
  var getReplacerFunction = requireGetJsonReplacerFunction();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var $String2 = String;
  var $stringify = getBuiltIn2("JSON", "stringify");
  var exec = uncurryThis2(/./.exec);
  var charAt = uncurryThis2("".charAt);
  var charCodeAt = uncurryThis2("".charCodeAt);
  var replace = uncurryThis2("".replace);
  var numberToString = uncurryThis2(1 .toString);
  var tester = /[\uD800-\uDFFF]/g;
  var low = /^[\uD800-\uDBFF]$/;
  var hi = /^[\uDC00-\uDFFF]$/;
  var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails2(function() {
    var symbol2 = getBuiltIn2("Symbol")();
    return $stringify([symbol2]) != "[null]" || $stringify({ a: symbol2 }) != "{}" || $stringify(Object(symbol2)) != "{}";
  });
  var ILL_FORMED_UNICODE = fails2(function() {
    return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
  });
  var stringifyWithSymbolsFix = function(it, replacer) {
    var args = arraySlice2(arguments);
    var $replacer = getReplacerFunction(replacer);
    if (!isCallable2($replacer) && (it === void 0 || isSymbol2(it)))
      return;
    args[1] = function(key, value) {
      if (isCallable2($replacer))
        value = call2($replacer, this, $String2(key), value);
      if (!isSymbol2(value))
        return value;
    };
    return apply2($stringify, null, args);
  };
  var fixIllFormed = function(match, offset, string) {
    var prev = charAt(string, offset - 1);
    var next = charAt(string, offset + 1);
    if (exec(low, match) && !exec(hi, next) || exec(hi, match) && !exec(low, prev)) {
      return "\\u" + numberToString(charCodeAt(match, 0), 16);
    }
    return match;
  };
  if ($stringify) {
    $2({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      stringify: function stringify(it, replacer, space) {
        var args = arraySlice2(arguments);
        var result = apply2(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
        return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
      }
    });
  }
  return es_json_stringify;
}
var es_object_getOwnPropertySymbols = {};
var hasRequiredEs_object_getOwnPropertySymbols;
function requireEs_object_getOwnPropertySymbols() {
  if (hasRequiredEs_object_getOwnPropertySymbols)
    return es_object_getOwnPropertySymbols;
  hasRequiredEs_object_getOwnPropertySymbols = 1;
  var $2 = _export;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var fails2 = fails$6;
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var toObject2 = requireToObject();
  var FORCED = !NATIVE_SYMBOL || fails2(function() {
    getOwnPropertySymbolsModule.f(1);
  });
  $2({ target: "Object", stat: true, forced: FORCED }, {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject2(it)) : [];
    }
  });
  return es_object_getOwnPropertySymbols;
}
var hasRequiredEs_symbol;
function requireEs_symbol() {
  if (hasRequiredEs_symbol)
    return es_symbol;
  hasRequiredEs_symbol = 1;
  requireEs_symbol_constructor();
  requireEs_symbol_for();
  requireEs_symbol_keyFor();
  requireEs_json_stringify();
  requireEs_object_getOwnPropertySymbols();
  return es_symbol;
}
var es_symbol_asyncIterator = {};
var hasRequiredEs_symbol_asyncIterator;
function requireEs_symbol_asyncIterator() {
  if (hasRequiredEs_symbol_asyncIterator)
    return es_symbol_asyncIterator;
  hasRequiredEs_symbol_asyncIterator = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("asyncIterator");
  return es_symbol_asyncIterator;
}
var es_symbol_hasInstance = {};
var hasRequiredEs_symbol_hasInstance;
function requireEs_symbol_hasInstance() {
  if (hasRequiredEs_symbol_hasInstance)
    return es_symbol_hasInstance;
  hasRequiredEs_symbol_hasInstance = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("hasInstance");
  return es_symbol_hasInstance;
}
var es_symbol_isConcatSpreadable = {};
var hasRequiredEs_symbol_isConcatSpreadable;
function requireEs_symbol_isConcatSpreadable() {
  if (hasRequiredEs_symbol_isConcatSpreadable)
    return es_symbol_isConcatSpreadable;
  hasRequiredEs_symbol_isConcatSpreadable = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("isConcatSpreadable");
  return es_symbol_isConcatSpreadable;
}
var es_symbol_iterator = {};
var hasRequiredEs_symbol_iterator;
function requireEs_symbol_iterator() {
  if (hasRequiredEs_symbol_iterator)
    return es_symbol_iterator;
  hasRequiredEs_symbol_iterator = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("iterator");
  return es_symbol_iterator;
}
var es_symbol_match = {};
var hasRequiredEs_symbol_match;
function requireEs_symbol_match() {
  if (hasRequiredEs_symbol_match)
    return es_symbol_match;
  hasRequiredEs_symbol_match = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("match");
  return es_symbol_match;
}
var es_symbol_matchAll = {};
var hasRequiredEs_symbol_matchAll;
function requireEs_symbol_matchAll() {
  if (hasRequiredEs_symbol_matchAll)
    return es_symbol_matchAll;
  hasRequiredEs_symbol_matchAll = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("matchAll");
  return es_symbol_matchAll;
}
var es_symbol_replace = {};
var hasRequiredEs_symbol_replace;
function requireEs_symbol_replace() {
  if (hasRequiredEs_symbol_replace)
    return es_symbol_replace;
  hasRequiredEs_symbol_replace = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("replace");
  return es_symbol_replace;
}
var es_symbol_search = {};
var hasRequiredEs_symbol_search;
function requireEs_symbol_search() {
  if (hasRequiredEs_symbol_search)
    return es_symbol_search;
  hasRequiredEs_symbol_search = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("search");
  return es_symbol_search;
}
var es_symbol_species = {};
var hasRequiredEs_symbol_species;
function requireEs_symbol_species() {
  if (hasRequiredEs_symbol_species)
    return es_symbol_species;
  hasRequiredEs_symbol_species = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("species");
  return es_symbol_species;
}
var es_symbol_split = {};
var hasRequiredEs_symbol_split;
function requireEs_symbol_split() {
  if (hasRequiredEs_symbol_split)
    return es_symbol_split;
  hasRequiredEs_symbol_split = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("split");
  return es_symbol_split;
}
var es_symbol_toPrimitive = {};
var hasRequiredEs_symbol_toPrimitive;
function requireEs_symbol_toPrimitive() {
  if (hasRequiredEs_symbol_toPrimitive)
    return es_symbol_toPrimitive;
  hasRequiredEs_symbol_toPrimitive = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  var defineSymbolToPrimitive = requireSymbolDefineToPrimitive();
  defineWellKnownSymbol("toPrimitive");
  defineSymbolToPrimitive();
  return es_symbol_toPrimitive;
}
var es_symbol_toStringTag = {};
var hasRequiredEs_symbol_toStringTag;
function requireEs_symbol_toStringTag() {
  if (hasRequiredEs_symbol_toStringTag)
    return es_symbol_toStringTag;
  hasRequiredEs_symbol_toStringTag = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  var setToStringTag2 = requireSetToStringTag();
  defineWellKnownSymbol("toStringTag");
  setToStringTag2(getBuiltIn2("Symbol"), "Symbol");
  return es_symbol_toStringTag;
}
var es_symbol_unscopables = {};
var hasRequiredEs_symbol_unscopables;
function requireEs_symbol_unscopables() {
  if (hasRequiredEs_symbol_unscopables)
    return es_symbol_unscopables;
  hasRequiredEs_symbol_unscopables = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("unscopables");
  return es_symbol_unscopables;
}
var es_json_toStringTag = {};
var hasRequiredEs_json_toStringTag;
function requireEs_json_toStringTag() {
  if (hasRequiredEs_json_toStringTag)
    return es_json_toStringTag;
  hasRequiredEs_json_toStringTag = 1;
  var global2 = global$3;
  var setToStringTag2 = requireSetToStringTag();
  setToStringTag2(global2.JSON, "JSON", true);
  return es_json_toStringTag;
}
var symbol$5;
var hasRequiredSymbol$6;
function requireSymbol$6() {
  if (hasRequiredSymbol$6)
    return symbol$5;
  hasRequiredSymbol$6 = 1;
  requireEs_array_concat();
  requireEs_symbol();
  requireEs_symbol_asyncIterator();
  requireEs_symbol_hasInstance();
  requireEs_symbol_isConcatSpreadable();
  requireEs_symbol_iterator();
  requireEs_symbol_match();
  requireEs_symbol_matchAll();
  requireEs_symbol_replace();
  requireEs_symbol_search();
  requireEs_symbol_species();
  requireEs_symbol_split();
  requireEs_symbol_toPrimitive();
  requireEs_symbol_toStringTag();
  requireEs_symbol_unscopables();
  requireEs_json_toStringTag();
  var path2 = path$2;
  symbol$5 = path2.Symbol;
  return symbol$5;
}
var symbol$4;
var hasRequiredSymbol$5;
function requireSymbol$5() {
  if (hasRequiredSymbol$5)
    return symbol$4;
  hasRequiredSymbol$5 = 1;
  var parent2 = requireSymbol$6();
  requireWeb_domCollections_iterator();
  symbol$4 = parent2;
  return symbol$4;
}
var hasRequiredSymbol$4;
function requireSymbol$4() {
  if (hasRequiredSymbol$4)
    return symbolExports$2;
  hasRequiredSymbol$4 = 1;
  (function(module) {
    module.exports = requireSymbol$5();
  })(symbol$6);
  return symbolExports$2;
}
var fromExports$2 = {};
var from$6 = {
  get exports() {
    return fromExports$2;
  },
  set exports(v) {
    fromExports$2 = v;
  }
};
var es_array_from = {};
var iteratorClose;
var hasRequiredIteratorClose;
function requireIteratorClose() {
  if (hasRequiredIteratorClose)
    return iteratorClose;
  hasRequiredIteratorClose = 1;
  var call2 = functionCall;
  var anObject2 = anObject$1;
  var getMethod2 = getMethod$1;
  iteratorClose = function(iterator, kind, value) {
    var innerResult, innerError;
    anObject2(iterator);
    try {
      innerResult = getMethod2(iterator, "return");
      if (!innerResult) {
        if (kind === "throw")
          throw value;
        return value;
      }
      innerResult = call2(innerResult, iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === "throw")
      throw value;
    if (innerError)
      throw innerResult;
    anObject2(innerResult);
    return value;
  };
  return iteratorClose;
}
var callWithSafeIterationClosing;
var hasRequiredCallWithSafeIterationClosing;
function requireCallWithSafeIterationClosing() {
  if (hasRequiredCallWithSafeIterationClosing)
    return callWithSafeIterationClosing;
  hasRequiredCallWithSafeIterationClosing = 1;
  var anObject2 = anObject$1;
  var iteratorClose2 = requireIteratorClose();
  callWithSafeIterationClosing = function(iterator, fn, value, ENTRIES) {
    try {
      return ENTRIES ? fn(anObject2(value)[0], value[1]) : fn(value);
    } catch (error) {
      iteratorClose2(iterator, "throw", error);
    }
  };
  return callWithSafeIterationClosing;
}
var isArrayIteratorMethod;
var hasRequiredIsArrayIteratorMethod;
function requireIsArrayIteratorMethod() {
  if (hasRequiredIsArrayIteratorMethod)
    return isArrayIteratorMethod;
  hasRequiredIsArrayIteratorMethod = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var Iterators = requireIterators();
  var ITERATOR = wellKnownSymbol2("iterator");
  var ArrayPrototype = Array.prototype;
  isArrayIteratorMethod = function(it) {
    return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
  };
  return isArrayIteratorMethod;
}
var arrayFrom;
var hasRequiredArrayFrom;
function requireArrayFrom() {
  if (hasRequiredArrayFrom)
    return arrayFrom;
  hasRequiredArrayFrom = 1;
  var bind2 = functionBindContext;
  var call2 = functionCall;
  var toObject2 = requireToObject();
  var callWithSafeIterationClosing2 = requireCallWithSafeIterationClosing();
  var isArrayIteratorMethod2 = requireIsArrayIteratorMethod();
  var isConstructor2 = requireIsConstructor();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var createProperty2 = requireCreateProperty();
  var getIterator2 = requireGetIterator$6();
  var getIteratorMethod2 = requireGetIteratorMethod$6();
  var $Array = Array;
  arrayFrom = function from2(arrayLike) {
    var O = toObject2(arrayLike);
    var IS_CONSTRUCTOR = isConstructor2(this);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
    var mapping = mapfn !== void 0;
    if (mapping)
      mapfn = bind2(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
    var iteratorMethod = getIteratorMethod2(O);
    var index = 0;
    var length, result, step, iterator, next, value;
    if (iteratorMethod && !(this === $Array && isArrayIteratorMethod2(iteratorMethod))) {
      iterator = getIterator2(O, iteratorMethod);
      next = iterator.next;
      result = IS_CONSTRUCTOR ? new this() : [];
      for (; !(step = call2(next, iterator)).done; index++) {
        value = mapping ? callWithSafeIterationClosing2(iterator, mapfn, [step.value, index], true) : step.value;
        createProperty2(result, index, value);
      }
    } else {
      length = lengthOfArrayLike2(O);
      result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
      for (; length > index; index++) {
        value = mapping ? mapfn(O[index], index) : O[index];
        createProperty2(result, index, value);
      }
    }
    result.length = index;
    return result;
  };
  return arrayFrom;
}
var checkCorrectnessOfIteration;
var hasRequiredCheckCorrectnessOfIteration;
function requireCheckCorrectnessOfIteration() {
  if (hasRequiredCheckCorrectnessOfIteration)
    return checkCorrectnessOfIteration;
  hasRequiredCheckCorrectnessOfIteration = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var ITERATOR = wellKnownSymbol2("iterator");
  var SAFE_CLOSING = false;
  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function() {
        return { done: !!called++ };
      },
      "return": function() {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR] = function() {
      return this;
    };
    Array.from(iteratorWithReturn, function() {
      throw 2;
    });
  } catch (error) {
  }
  checkCorrectnessOfIteration = function(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING)
      return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR] = function() {
        return {
          next: function() {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec(object);
    } catch (error) {
    }
    return ITERATION_SUPPORT;
  };
  return checkCorrectnessOfIteration;
}
var hasRequiredEs_array_from;
function requireEs_array_from() {
  if (hasRequiredEs_array_from)
    return es_array_from;
  hasRequiredEs_array_from = 1;
  var $2 = _export;
  var from2 = requireArrayFrom();
  var checkCorrectnessOfIteration2 = requireCheckCorrectnessOfIteration();
  var INCORRECT_ITERATION = !checkCorrectnessOfIteration2(function(iterable) {
    Array.from(iterable);
  });
  $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
    from: from2
  });
  return es_array_from;
}
var from$5;
var hasRequiredFrom$6;
function requireFrom$6() {
  if (hasRequiredFrom$6)
    return from$5;
  hasRequiredFrom$6 = 1;
  requireEs_string_iterator();
  requireEs_array_from();
  var path2 = path$2;
  from$5 = path2.Array.from;
  return from$5;
}
var from$4;
var hasRequiredFrom$5;
function requireFrom$5() {
  if (hasRequiredFrom$5)
    return from$4;
  hasRequiredFrom$5 = 1;
  var parent2 = requireFrom$6();
  from$4 = parent2;
  return from$4;
}
var hasRequiredFrom$4;
function requireFrom$4() {
  if (hasRequiredFrom$4)
    return fromExports$2;
  hasRequiredFrom$4 = 1;
  (function(module) {
    module.exports = requireFrom$5();
  })(from$6);
  return fromExports$2;
}
var concatExports = {};
var concat$3 = {
  get exports() {
    return concatExports;
  },
  set exports(v) {
    concatExports = v;
  }
};
var entryVirtual;
var hasRequiredEntryVirtual;
function requireEntryVirtual() {
  if (hasRequiredEntryVirtual)
    return entryVirtual;
  hasRequiredEntryVirtual = 1;
  var path2 = path$2;
  entryVirtual = function(CONSTRUCTOR) {
    return path2[CONSTRUCTOR + "Prototype"];
  };
  return entryVirtual;
}
var concat$2;
var hasRequiredConcat$3;
function requireConcat$3() {
  if (hasRequiredConcat$3)
    return concat$2;
  hasRequiredConcat$3 = 1;
  requireEs_array_concat();
  var entryVirtual2 = requireEntryVirtual();
  concat$2 = entryVirtual2("Array").concat;
  return concat$2;
}
var concat$1;
var hasRequiredConcat$2;
function requireConcat$2() {
  if (hasRequiredConcat$2)
    return concat$1;
  hasRequiredConcat$2 = 1;
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var method = requireConcat$3();
  var ArrayPrototype = Array.prototype;
  concat$1 = function(it) {
    var own = it.concat;
    return it === ArrayPrototype || isPrototypeOf2(ArrayPrototype, it) && own === ArrayPrototype.concat ? method : own;
  };
  return concat$1;
}
var concat;
var hasRequiredConcat$1;
function requireConcat$1() {
  if (hasRequiredConcat$1)
    return concat;
  hasRequiredConcat$1 = 1;
  var parent2 = requireConcat$2();
  concat = parent2;
  return concat;
}
var hasRequiredConcat;
function requireConcat() {
  if (hasRequiredConcat)
    return concatExports;
  hasRequiredConcat = 1;
  (function(module) {
    module.exports = requireConcat$1();
  })(concat$3);
  return concatExports;
}
var indexOfExports = {};
var indexOf$3 = {
  get exports() {
    return indexOfExports;
  },
  set exports(v) {
    indexOfExports = v;
  }
};
var es_array_indexOf = {};
var arrayMethodIsStrict;
var hasRequiredArrayMethodIsStrict;
function requireArrayMethodIsStrict() {
  if (hasRequiredArrayMethodIsStrict)
    return arrayMethodIsStrict;
  hasRequiredArrayMethodIsStrict = 1;
  var fails2 = fails$6;
  arrayMethodIsStrict = function(METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails2(function() {
      method.call(null, argument || function() {
        return 1;
      }, 1);
    });
  };
  return arrayMethodIsStrict;
}
var hasRequiredEs_array_indexOf;
function requireEs_array_indexOf() {
  if (hasRequiredEs_array_indexOf)
    return es_array_indexOf;
  hasRequiredEs_array_indexOf = 1;
  var $2 = _export;
  var uncurryThis2 = functionUncurryThisClause;
  var $indexOf = requireArrayIncludes().indexOf;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var nativeIndexOf = uncurryThis2([].indexOf);
  var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
  var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict2("indexOf");
  $2({ target: "Array", proto: true, forced: FORCED }, {
    indexOf: function indexOf2(searchElement) {
      var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
      return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
    }
  });
  return es_array_indexOf;
}
var indexOf$2;
var hasRequiredIndexOf$3;
function requireIndexOf$3() {
  if (hasRequiredIndexOf$3)
    return indexOf$2;
  hasRequiredIndexOf$3 = 1;
  requireEs_array_indexOf();
  var entryVirtual2 = requireEntryVirtual();
  indexOf$2 = entryVirtual2("Array").indexOf;
  return indexOf$2;
}
var indexOf$1;
var hasRequiredIndexOf$2;
function requireIndexOf$2() {
  if (hasRequiredIndexOf$2)
    return indexOf$1;
  hasRequiredIndexOf$2 = 1;
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var method = requireIndexOf$3();
  var ArrayPrototype = Array.prototype;
  indexOf$1 = function(it) {
    var own = it.indexOf;
    return it === ArrayPrototype || isPrototypeOf2(ArrayPrototype, it) && own === ArrayPrototype.indexOf ? method : own;
  };
  return indexOf$1;
}
var indexOf;
var hasRequiredIndexOf$1;
function requireIndexOf$1() {
  if (hasRequiredIndexOf$1)
    return indexOf;
  hasRequiredIndexOf$1 = 1;
  var parent2 = requireIndexOf$2();
  indexOf = parent2;
  return indexOf;
}
var hasRequiredIndexOf;
function requireIndexOf() {
  if (hasRequiredIndexOf)
    return indexOfExports;
  hasRequiredIndexOf = 1;
  (function(module) {
    module.exports = requireIndexOf$1();
  })(indexOf$3);
  return indexOfExports;
}
var createExports = {};
var create$2 = {
  get exports() {
    return createExports;
  },
  set exports(v) {
    createExports = v;
  }
};
var es_object_create = {};
var hasRequiredEs_object_create;
function requireEs_object_create() {
  if (hasRequiredEs_object_create)
    return es_object_create;
  hasRequiredEs_object_create = 1;
  var $2 = _export;
  var DESCRIPTORS2 = descriptors;
  var create2 = requireObjectCreate();
  $2({ target: "Object", stat: true, sham: !DESCRIPTORS2 }, {
    create: create2
  });
  return es_object_create;
}
var create$1;
var hasRequiredCreate$2;
function requireCreate$2() {
  if (hasRequiredCreate$2)
    return create$1;
  hasRequiredCreate$2 = 1;
  requireEs_object_create();
  var path2 = path$2;
  var Object2 = path2.Object;
  create$1 = function create2(P, D) {
    return Object2.create(P, D);
  };
  return create$1;
}
var create;
var hasRequiredCreate$1;
function requireCreate$1() {
  if (hasRequiredCreate$1)
    return create;
  hasRequiredCreate$1 = 1;
  var parent2 = requireCreate$2();
  create = parent2;
  return create;
}
var hasRequiredCreate;
function requireCreate() {
  if (hasRequiredCreate)
    return createExports;
  hasRequiredCreate = 1;
  (function(module) {
    module.exports = requireCreate$1();
  })(create$2);
  return createExports;
}
var slicedToArrayExports = {};
var slicedToArray = {
  get exports() {
    return slicedToArrayExports;
  },
  set exports(v) {
    slicedToArrayExports = v;
  }
};
var arrayWithHolesExports = {};
var arrayWithHoles = {
  get exports() {
    return arrayWithHolesExports;
  },
  set exports(v) {
    arrayWithHolesExports = v;
  }
};
var isArrayExports$1 = {};
var isArray$3 = {
  get exports() {
    return isArrayExports$1;
  },
  set exports(v) {
    isArrayExports$1 = v;
  }
};
var isArrayExports = {};
var isArray$2 = {
  get exports() {
    return isArrayExports;
  },
  set exports(v) {
    isArrayExports = v;
  }
};
var isArray$1;
var hasRequiredIsArray$3;
function requireIsArray$3() {
  if (hasRequiredIsArray$3)
    return isArray$1;
  hasRequiredIsArray$3 = 1;
  var parent2 = requireIsArray$5();
  isArray$1 = parent2;
  return isArray$1;
}
var isArray;
var hasRequiredIsArray$2;
function requireIsArray$2() {
  if (hasRequiredIsArray$2)
    return isArray;
  hasRequiredIsArray$2 = 1;
  var parent2 = requireIsArray$3();
  isArray = parent2;
  return isArray;
}
var hasRequiredIsArray$1;
function requireIsArray$1() {
  if (hasRequiredIsArray$1)
    return isArrayExports;
  hasRequiredIsArray$1 = 1;
  (function(module) {
    module.exports = requireIsArray$2();
  })(isArray$2);
  return isArrayExports;
}
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray)
    return isArrayExports$1;
  hasRequiredIsArray = 1;
  (function(module) {
    module.exports = requireIsArray$1();
  })(isArray$3);
  return isArrayExports$1;
}
var hasRequiredArrayWithHoles;
function requireArrayWithHoles() {
  if (hasRequiredArrayWithHoles)
    return arrayWithHolesExports;
  hasRequiredArrayWithHoles = 1;
  (function(module) {
    var _Array$isArray = requireIsArray();
    function _arrayWithHoles2(arr) {
      if (_Array$isArray(arr))
        return arr;
    }
    module.exports = _arrayWithHoles2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(arrayWithHoles);
  return arrayWithHolesExports;
}
var iterableToArrayLimitExports = {};
var iterableToArrayLimit = {
  get exports() {
    return iterableToArrayLimitExports;
  },
  set exports(v) {
    iterableToArrayLimitExports = v;
  }
};
var symbolExports$1 = {};
var symbol$3 = {
  get exports() {
    return symbolExports$1;
  },
  set exports(v) {
    symbolExports$1 = v;
  }
};
var symbolExports = {};
var symbol$2 = {
  get exports() {
    return symbolExports;
  },
  set exports(v) {
    symbolExports = v;
  }
};
var esnext_symbol_dispose = {};
var hasRequiredEsnext_symbol_dispose;
function requireEsnext_symbol_dispose() {
  if (hasRequiredEsnext_symbol_dispose)
    return esnext_symbol_dispose;
  hasRequiredEsnext_symbol_dispose = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("dispose");
  return esnext_symbol_dispose;
}
var symbol$1;
var hasRequiredSymbol$3;
function requireSymbol$3() {
  if (hasRequiredSymbol$3)
    return symbol$1;
  hasRequiredSymbol$3 = 1;
  var parent2 = requireSymbol$5();
  requireEsnext_symbol_dispose();
  symbol$1 = parent2;
  return symbol$1;
}
var esnext_symbol_asyncDispose = {};
var hasRequiredEsnext_symbol_asyncDispose;
function requireEsnext_symbol_asyncDispose() {
  if (hasRequiredEsnext_symbol_asyncDispose)
    return esnext_symbol_asyncDispose;
  hasRequiredEsnext_symbol_asyncDispose = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("asyncDispose");
  return esnext_symbol_asyncDispose;
}
var esnext_symbol_isRegistered = {};
var hasRequiredEsnext_symbol_isRegistered;
function requireEsnext_symbol_isRegistered() {
  if (hasRequiredEsnext_symbol_isRegistered)
    return esnext_symbol_isRegistered;
  hasRequiredEsnext_symbol_isRegistered = 1;
  var $2 = _export;
  var getBuiltIn2 = requireGetBuiltIn();
  var uncurryThis2 = requireFunctionUncurryThis();
  var Symbol2 = getBuiltIn2("Symbol");
  var keyFor = Symbol2.keyFor;
  var thisSymbolValue = uncurryThis2(Symbol2.prototype.valueOf);
  $2({ target: "Symbol", stat: true }, {
    isRegistered: function isRegistered(value) {
      try {
        return keyFor(thisSymbolValue(value)) !== void 0;
      } catch (error) {
        return false;
      }
    }
  });
  return esnext_symbol_isRegistered;
}
var esnext_symbol_isWellKnown = {};
var hasRequiredEsnext_symbol_isWellKnown;
function requireEsnext_symbol_isWellKnown() {
  if (hasRequiredEsnext_symbol_isWellKnown)
    return esnext_symbol_isWellKnown;
  hasRequiredEsnext_symbol_isWellKnown = 1;
  var $2 = _export;
  var shared2 = requireShared();
  var getBuiltIn2 = requireGetBuiltIn();
  var uncurryThis2 = requireFunctionUncurryThis();
  var isSymbol2 = isSymbol$2;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var Symbol2 = getBuiltIn2("Symbol");
  var $isWellKnown = Symbol2.isWellKnown;
  var getOwnPropertyNames = getBuiltIn2("Object", "getOwnPropertyNames");
  var thisSymbolValue = uncurryThis2(Symbol2.prototype.valueOf);
  var WellKnownSymbolsStore = shared2("wks");
  for (var i = 0, symbolKeys = getOwnPropertyNames(Symbol2), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
    try {
      var symbolKey = symbolKeys[i];
      if (isSymbol2(Symbol2[symbolKey]))
        wellKnownSymbol2(symbolKey);
    } catch (error) {
    }
  }
  $2({ target: "Symbol", stat: true, forced: true }, {
    isWellKnown: function isWellKnown(value) {
      if ($isWellKnown && $isWellKnown(value))
        return true;
      try {
        var symbol2 = thisSymbolValue(value);
        for (var j = 0, keys = getOwnPropertyNames(WellKnownSymbolsStore), keysLength = keys.length; j < keysLength; j++) {
          if (WellKnownSymbolsStore[keys[j]] == symbol2)
            return true;
        }
      } catch (error) {
      }
      return false;
    }
  });
  return esnext_symbol_isWellKnown;
}
var esnext_symbol_matcher = {};
var hasRequiredEsnext_symbol_matcher;
function requireEsnext_symbol_matcher() {
  if (hasRequiredEsnext_symbol_matcher)
    return esnext_symbol_matcher;
  hasRequiredEsnext_symbol_matcher = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("matcher");
  return esnext_symbol_matcher;
}
var esnext_symbol_metadataKey = {};
var hasRequiredEsnext_symbol_metadataKey;
function requireEsnext_symbol_metadataKey() {
  if (hasRequiredEsnext_symbol_metadataKey)
    return esnext_symbol_metadataKey;
  hasRequiredEsnext_symbol_metadataKey = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("metadataKey");
  return esnext_symbol_metadataKey;
}
var esnext_symbol_observable = {};
var hasRequiredEsnext_symbol_observable;
function requireEsnext_symbol_observable() {
  if (hasRequiredEsnext_symbol_observable)
    return esnext_symbol_observable;
  hasRequiredEsnext_symbol_observable = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("observable");
  return esnext_symbol_observable;
}
var esnext_symbol_metadata = {};
var hasRequiredEsnext_symbol_metadata;
function requireEsnext_symbol_metadata() {
  if (hasRequiredEsnext_symbol_metadata)
    return esnext_symbol_metadata;
  hasRequiredEsnext_symbol_metadata = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("metadata");
  return esnext_symbol_metadata;
}
var esnext_symbol_patternMatch = {};
var hasRequiredEsnext_symbol_patternMatch;
function requireEsnext_symbol_patternMatch() {
  if (hasRequiredEsnext_symbol_patternMatch)
    return esnext_symbol_patternMatch;
  hasRequiredEsnext_symbol_patternMatch = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("patternMatch");
  return esnext_symbol_patternMatch;
}
var esnext_symbol_replaceAll = {};
var hasRequiredEsnext_symbol_replaceAll;
function requireEsnext_symbol_replaceAll() {
  if (hasRequiredEsnext_symbol_replaceAll)
    return esnext_symbol_replaceAll;
  hasRequiredEsnext_symbol_replaceAll = 1;
  var defineWellKnownSymbol = requireWellKnownSymbolDefine();
  defineWellKnownSymbol("replaceAll");
  return esnext_symbol_replaceAll;
}
var symbol;
var hasRequiredSymbol$2;
function requireSymbol$2() {
  if (hasRequiredSymbol$2)
    return symbol;
  hasRequiredSymbol$2 = 1;
  var parent2 = requireSymbol$3();
  requireEsnext_symbol_asyncDispose();
  requireEsnext_symbol_isRegistered();
  requireEsnext_symbol_isWellKnown();
  requireEsnext_symbol_matcher();
  requireEsnext_symbol_metadataKey();
  requireEsnext_symbol_observable();
  requireEsnext_symbol_metadata();
  requireEsnext_symbol_patternMatch();
  requireEsnext_symbol_replaceAll();
  symbol = parent2;
  return symbol;
}
var hasRequiredSymbol$1;
function requireSymbol$1() {
  if (hasRequiredSymbol$1)
    return symbolExports;
  hasRequiredSymbol$1 = 1;
  (function(module) {
    module.exports = requireSymbol$2();
  })(symbol$2);
  return symbolExports;
}
var hasRequiredSymbol;
function requireSymbol() {
  if (hasRequiredSymbol)
    return symbolExports$1;
  hasRequiredSymbol = 1;
  (function(module) {
    module.exports = requireSymbol$1();
  })(symbol$3);
  return symbolExports$1;
}
var hasRequiredIterableToArrayLimit;
function requireIterableToArrayLimit() {
  if (hasRequiredIterableToArrayLimit)
    return iterableToArrayLimitExports;
  hasRequiredIterableToArrayLimit = 1;
  (function(module) {
    var _Symbol = requireSymbol();
    var _getIteratorMethod = requireGetIteratorMethod();
    function _iterableToArrayLimit2(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof _Symbol && _getIteratorMethod(arr) || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i)
              return;
            _n = false;
          } else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    module.exports = _iterableToArrayLimit2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(iterableToArrayLimit);
  return iterableToArrayLimitExports;
}
var unsupportedIterableToArrayExports = {};
var unsupportedIterableToArray = {
  get exports() {
    return unsupportedIterableToArrayExports;
  },
  set exports(v) {
    unsupportedIterableToArrayExports = v;
  }
};
var sliceExports$2 = {};
var slice$7 = {
  get exports() {
    return sliceExports$2;
  },
  set exports(v) {
    sliceExports$2 = v;
  }
};
var sliceExports$1 = {};
var slice$6 = {
  get exports() {
    return sliceExports$1;
  },
  set exports(v) {
    sliceExports$1 = v;
  }
};
var es_array_slice = {};
var hasRequiredEs_array_slice;
function requireEs_array_slice() {
  if (hasRequiredEs_array_slice)
    return es_array_slice;
  hasRequiredEs_array_slice = 1;
  var $2 = _export;
  var isArray2 = requireIsArray$7();
  var isConstructor2 = requireIsConstructor();
  var isObject2 = isObject$4;
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var toIndexedObject2 = toIndexedObject$1;
  var createProperty2 = requireCreateProperty();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var arrayMethodHasSpeciesSupport2 = requireArrayMethodHasSpeciesSupport();
  var nativeSlice = requireArraySlice();
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport2("slice");
  var SPECIES = wellKnownSymbol2("species");
  var $Array = Array;
  var max = Math.max;
  $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
    slice: function slice2(start, end) {
      var O = toIndexedObject2(this);
      var length = lengthOfArrayLike2(O);
      var k = toAbsoluteIndex2(start, length);
      var fin = toAbsoluteIndex2(end === void 0 ? length : end, length);
      var Constructor, result, n;
      if (isArray2(O)) {
        Constructor = O.constructor;
        if (isConstructor2(Constructor) && (Constructor === $Array || isArray2(Constructor.prototype))) {
          Constructor = void 0;
        } else if (isObject2(Constructor)) {
          Constructor = Constructor[SPECIES];
          if (Constructor === null)
            Constructor = void 0;
        }
        if (Constructor === $Array || Constructor === void 0) {
          return nativeSlice(O, k, fin);
        }
      }
      result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k, 0));
      for (n = 0; k < fin; k++, n++)
        if (k in O)
          createProperty2(result, n, O[k]);
      result.length = n;
      return result;
    }
  });
  return es_array_slice;
}
var slice$5;
var hasRequiredSlice$7;
function requireSlice$7() {
  if (hasRequiredSlice$7)
    return slice$5;
  hasRequiredSlice$7 = 1;
  requireEs_array_slice();
  var entryVirtual2 = requireEntryVirtual();
  slice$5 = entryVirtual2("Array").slice;
  return slice$5;
}
var slice$4;
var hasRequiredSlice$6;
function requireSlice$6() {
  if (hasRequiredSlice$6)
    return slice$4;
  hasRequiredSlice$6 = 1;
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var method = requireSlice$7();
  var ArrayPrototype = Array.prototype;
  slice$4 = function(it) {
    var own = it.slice;
    return it === ArrayPrototype || isPrototypeOf2(ArrayPrototype, it) && own === ArrayPrototype.slice ? method : own;
  };
  return slice$4;
}
var slice$3;
var hasRequiredSlice$5;
function requireSlice$5() {
  if (hasRequiredSlice$5)
    return slice$3;
  hasRequiredSlice$5 = 1;
  var parent2 = requireSlice$6();
  slice$3 = parent2;
  return slice$3;
}
var slice$2;
var hasRequiredSlice$4;
function requireSlice$4() {
  if (hasRequiredSlice$4)
    return slice$2;
  hasRequiredSlice$4 = 1;
  var parent2 = requireSlice$5();
  slice$2 = parent2;
  return slice$2;
}
var slice$1;
var hasRequiredSlice$3;
function requireSlice$3() {
  if (hasRequiredSlice$3)
    return slice$1;
  hasRequiredSlice$3 = 1;
  var parent2 = requireSlice$4();
  slice$1 = parent2;
  return slice$1;
}
var hasRequiredSlice$2;
function requireSlice$2() {
  if (hasRequiredSlice$2)
    return sliceExports$1;
  hasRequiredSlice$2 = 1;
  (function(module) {
    module.exports = requireSlice$3();
  })(slice$6);
  return sliceExports$1;
}
var hasRequiredSlice$1;
function requireSlice$1() {
  if (hasRequiredSlice$1)
    return sliceExports$2;
  hasRequiredSlice$1 = 1;
  (function(module) {
    module.exports = requireSlice$2();
  })(slice$7);
  return sliceExports$2;
}
var fromExports$1 = {};
var from$3 = {
  get exports() {
    return fromExports$1;
  },
  set exports(v) {
    fromExports$1 = v;
  }
};
var fromExports = {};
var from$2 = {
  get exports() {
    return fromExports;
  },
  set exports(v) {
    fromExports = v;
  }
};
var from$1;
var hasRequiredFrom$3;
function requireFrom$3() {
  if (hasRequiredFrom$3)
    return from$1;
  hasRequiredFrom$3 = 1;
  var parent2 = requireFrom$5();
  from$1 = parent2;
  return from$1;
}
var from;
var hasRequiredFrom$2;
function requireFrom$2() {
  if (hasRequiredFrom$2)
    return from;
  hasRequiredFrom$2 = 1;
  var parent2 = requireFrom$3();
  from = parent2;
  return from;
}
var hasRequiredFrom$1;
function requireFrom$1() {
  if (hasRequiredFrom$1)
    return fromExports;
  hasRequiredFrom$1 = 1;
  (function(module) {
    module.exports = requireFrom$2();
  })(from$2);
  return fromExports;
}
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom)
    return fromExports$1;
  hasRequiredFrom = 1;
  (function(module) {
    module.exports = requireFrom$1();
  })(from$3);
  return fromExports$1;
}
var arrayLikeToArrayExports = {};
var arrayLikeToArray = {
  get exports() {
    return arrayLikeToArrayExports;
  },
  set exports(v) {
    arrayLikeToArrayExports = v;
  }
};
var hasRequiredArrayLikeToArray;
function requireArrayLikeToArray() {
  if (hasRequiredArrayLikeToArray)
    return arrayLikeToArrayExports;
  hasRequiredArrayLikeToArray = 1;
  (function(module) {
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    module.exports = _arrayLikeToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(arrayLikeToArray);
  return arrayLikeToArrayExports;
}
var hasRequiredUnsupportedIterableToArray;
function requireUnsupportedIterableToArray() {
  if (hasRequiredUnsupportedIterableToArray)
    return unsupportedIterableToArrayExports;
  hasRequiredUnsupportedIterableToArray = 1;
  (function(module) {
    var _sliceInstanceProperty = requireSlice$1();
    var _Array$from = requireFrom();
    var arrayLikeToArray2 = requireArrayLikeToArray();
    function _unsupportedIterableToArray2(o, minLen) {
      var _context;
      if (!o)
        return;
      if (typeof o === "string")
        return arrayLikeToArray2(o, minLen);
      var n = _sliceInstanceProperty(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return _Array$from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return arrayLikeToArray2(o, minLen);
    }
    module.exports = _unsupportedIterableToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(unsupportedIterableToArray);
  return unsupportedIterableToArrayExports;
}
var nonIterableRestExports = {};
var nonIterableRest = {
  get exports() {
    return nonIterableRestExports;
  },
  set exports(v) {
    nonIterableRestExports = v;
  }
};
var hasRequiredNonIterableRest;
function requireNonIterableRest() {
  if (hasRequiredNonIterableRest)
    return nonIterableRestExports;
  hasRequiredNonIterableRest = 1;
  (function(module) {
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(nonIterableRest);
  return nonIterableRestExports;
}
var hasRequiredSlicedToArray;
function requireSlicedToArray() {
  if (hasRequiredSlicedToArray)
    return slicedToArrayExports;
  hasRequiredSlicedToArray = 1;
  (function(module) {
    var arrayWithHoles2 = requireArrayWithHoles();
    var iterableToArrayLimit2 = requireIterableToArrayLimit();
    var unsupportedIterableToArray2 = requireUnsupportedIterableToArray();
    var nonIterableRest2 = requireNonIterableRest();
    function _slicedToArray2(arr, i) {
      return arrayWithHoles2(arr) || iterableToArrayLimit2(arr, i) || unsupportedIterableToArray2(arr, i) || nonIterableRest2();
    }
    module.exports = _slicedToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(slicedToArray);
  return slicedToArrayExports;
}
var forEachExports = {};
var forEach$3 = {
  get exports() {
    return forEachExports;
  },
  set exports(v) {
    forEachExports = v;
  }
};
var es_array_forEach = {};
var arrayForEach;
var hasRequiredArrayForEach;
function requireArrayForEach() {
  if (hasRequiredArrayForEach)
    return arrayForEach;
  hasRequiredArrayForEach = 1;
  var $forEach = requireArrayIteration().forEach;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var STRICT_METHOD = arrayMethodIsStrict2("forEach");
  arrayForEach = !STRICT_METHOD ? function forEach2(callbackfn) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
  } : [].forEach;
  return arrayForEach;
}
var hasRequiredEs_array_forEach;
function requireEs_array_forEach() {
  if (hasRequiredEs_array_forEach)
    return es_array_forEach;
  hasRequiredEs_array_forEach = 1;
  var $2 = _export;
  var forEach2 = requireArrayForEach();
  $2({ target: "Array", proto: true, forced: [].forEach != forEach2 }, {
    forEach: forEach2
  });
  return es_array_forEach;
}
var forEach$2;
var hasRequiredForEach$3;
function requireForEach$3() {
  if (hasRequiredForEach$3)
    return forEach$2;
  hasRequiredForEach$3 = 1;
  requireEs_array_forEach();
  var entryVirtual2 = requireEntryVirtual();
  forEach$2 = entryVirtual2("Array").forEach;
  return forEach$2;
}
var forEach$1;
var hasRequiredForEach$2;
function requireForEach$2() {
  if (hasRequiredForEach$2)
    return forEach$1;
  hasRequiredForEach$2 = 1;
  var parent2 = requireForEach$3();
  forEach$1 = parent2;
  return forEach$1;
}
var forEach;
var hasRequiredForEach$1;
function requireForEach$1() {
  if (hasRequiredForEach$1)
    return forEach;
  hasRequiredForEach$1 = 1;
  requireWeb_domCollections_iterator();
  var classof2 = requireClassof();
  var hasOwn2 = requireHasOwnProperty();
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var method = requireForEach$2();
  var ArrayPrototype = Array.prototype;
  var DOMIterables = {
    DOMTokenList: true,
    NodeList: true
  };
  forEach = function(it) {
    var own = it.forEach;
    return it === ArrayPrototype || isPrototypeOf2(ArrayPrototype, it) && own === ArrayPrototype.forEach || hasOwn2(DOMIterables, classof2(it)) ? method : own;
  };
  return forEach;
}
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEachExports;
  hasRequiredForEach = 1;
  (function(module) {
    module.exports = requireForEach$1();
  })(forEach$3);
  return forEachExports;
}
var includesExports = {};
var includes$4 = {
  get exports() {
    return includesExports;
  },
  set exports(v) {
    includesExports = v;
  }
};
var es_array_includes = {};
var hasRequiredEs_array_includes;
function requireEs_array_includes() {
  if (hasRequiredEs_array_includes)
    return es_array_includes;
  hasRequiredEs_array_includes = 1;
  var $2 = _export;
  var $includes = requireArrayIncludes().includes;
  var fails2 = fails$6;
  var addToUnscopables2 = requireAddToUnscopables();
  var BROKEN_ON_SPARSE = fails2(function() {
    return !Array(1).includes();
  });
  $2({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
    includes: function includes2(el) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  addToUnscopables2("includes");
  return es_array_includes;
}
var includes$3;
var hasRequiredIncludes$4;
function requireIncludes$4() {
  if (hasRequiredIncludes$4)
    return includes$3;
  hasRequiredIncludes$4 = 1;
  requireEs_array_includes();
  var entryVirtual2 = requireEntryVirtual();
  includes$3 = entryVirtual2("Array").includes;
  return includes$3;
}
var es_string_includes = {};
var isRegexp;
var hasRequiredIsRegexp;
function requireIsRegexp() {
  if (hasRequiredIsRegexp)
    return isRegexp;
  hasRequiredIsRegexp = 1;
  var isObject2 = isObject$4;
  var classof2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var MATCH = wellKnownSymbol2("match");
  isRegexp = function(it) {
    var isRegExp;
    return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof2(it) == "RegExp");
  };
  return isRegexp;
}
var notARegexp;
var hasRequiredNotARegexp;
function requireNotARegexp() {
  if (hasRequiredNotARegexp)
    return notARegexp;
  hasRequiredNotARegexp = 1;
  var isRegExp = requireIsRegexp();
  var $TypeError2 = TypeError;
  notARegexp = function(it) {
    if (isRegExp(it)) {
      throw $TypeError2("The method doesn't accept regular expressions");
    }
    return it;
  };
  return notARegexp;
}
var correctIsRegexpLogic;
var hasRequiredCorrectIsRegexpLogic;
function requireCorrectIsRegexpLogic() {
  if (hasRequiredCorrectIsRegexpLogic)
    return correctIsRegexpLogic;
  hasRequiredCorrectIsRegexpLogic = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var MATCH = wellKnownSymbol2("match");
  correctIsRegexpLogic = function(METHOD_NAME) {
    var regexp = /./;
    try {
      "/./"[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH] = false;
        return "/./"[METHOD_NAME](regexp);
      } catch (error2) {
      }
    }
    return false;
  };
  return correctIsRegexpLogic;
}
var hasRequiredEs_string_includes;
function requireEs_string_includes() {
  if (hasRequiredEs_string_includes)
    return es_string_includes;
  hasRequiredEs_string_includes = 1;
  var $2 = _export;
  var uncurryThis2 = requireFunctionUncurryThis();
  var notARegExp = requireNotARegexp();
  var requireObjectCoercible2 = requireObjectCoercible$1;
  var toString2 = requireToString();
  var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
  var stringIndexOf = uncurryThis2("".indexOf);
  $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
    includes: function includes2(searchString) {
      return !!~stringIndexOf(
        toString2(requireObjectCoercible2(this)),
        toString2(notARegExp(searchString)),
        arguments.length > 1 ? arguments[1] : void 0
      );
    }
  });
  return es_string_includes;
}
var includes$2;
var hasRequiredIncludes$3;
function requireIncludes$3() {
  if (hasRequiredIncludes$3)
    return includes$2;
  hasRequiredIncludes$3 = 1;
  requireEs_string_includes();
  var entryVirtual2 = requireEntryVirtual();
  includes$2 = entryVirtual2("String").includes;
  return includes$2;
}
var includes$1;
var hasRequiredIncludes$2;
function requireIncludes$2() {
  if (hasRequiredIncludes$2)
    return includes$1;
  hasRequiredIncludes$2 = 1;
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var arrayMethod = requireIncludes$4();
  var stringMethod = requireIncludes$3();
  var ArrayPrototype = Array.prototype;
  var StringPrototype = String.prototype;
  includes$1 = function(it) {
    var own = it.includes;
    if (it === ArrayPrototype || isPrototypeOf2(ArrayPrototype, it) && own === ArrayPrototype.includes)
      return arrayMethod;
    if (typeof it == "string" || it === StringPrototype || isPrototypeOf2(StringPrototype, it) && own === StringPrototype.includes) {
      return stringMethod;
    }
    return own;
  };
  return includes$1;
}
var includes;
var hasRequiredIncludes$1;
function requireIncludes$1() {
  if (hasRequiredIncludes$1)
    return includes;
  hasRequiredIncludes$1 = 1;
  var parent2 = requireIncludes$2();
  includes = parent2;
  return includes;
}
var hasRequiredIncludes;
function requireIncludes() {
  if (hasRequiredIncludes)
    return includesExports;
  hasRequiredIncludes = 1;
  (function(module) {
    module.exports = requireIncludes$1();
  })(includes$4);
  return includesExports;
}
var _parseIntExports = {};
var _parseInt$2 = {
  get exports() {
    return _parseIntExports;
  },
  set exports(v) {
    _parseIntExports = v;
  }
};
var es_parseInt = {};
var whitespaces;
var hasRequiredWhitespaces;
function requireWhitespaces() {
  if (hasRequiredWhitespaces)
    return whitespaces;
  hasRequiredWhitespaces = 1;
  whitespaces = "	\n\v\f\r                　\u2028\u2029\uFEFF";
  return whitespaces;
}
var stringTrim;
var hasRequiredStringTrim;
function requireStringTrim() {
  if (hasRequiredStringTrim)
    return stringTrim;
  hasRequiredStringTrim = 1;
  var uncurryThis2 = requireFunctionUncurryThis();
  var requireObjectCoercible2 = requireObjectCoercible$1;
  var toString2 = requireToString();
  var whitespaces2 = requireWhitespaces();
  var replace = uncurryThis2("".replace);
  var ltrim = RegExp("^[" + whitespaces2 + "]+");
  var rtrim = RegExp("(^|[^" + whitespaces2 + "])[" + whitespaces2 + "]+$");
  var createMethod = function(TYPE) {
    return function($this) {
      var string = toString2(requireObjectCoercible2($this));
      if (TYPE & 1)
        string = replace(string, ltrim, "");
      if (TYPE & 2)
        string = replace(string, rtrim, "$1");
      return string;
    };
  };
  stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
  };
  return stringTrim;
}
var numberParseInt;
var hasRequiredNumberParseInt;
function requireNumberParseInt() {
  if (hasRequiredNumberParseInt)
    return numberParseInt;
  hasRequiredNumberParseInt = 1;
  var global2 = global$3;
  var fails2 = fails$6;
  var uncurryThis2 = requireFunctionUncurryThis();
  var toString2 = requireToString();
  var trim = requireStringTrim().trim;
  var whitespaces2 = requireWhitespaces();
  var $parseInt = global2.parseInt;
  var Symbol2 = global2.Symbol;
  var ITERATOR = Symbol2 && Symbol2.iterator;
  var hex2 = /^[+-]?0x/i;
  var exec = uncurryThis2(hex2.exec);
  var FORCED = $parseInt(whitespaces2 + "08") !== 8 || $parseInt(whitespaces2 + "0x16") !== 22 || ITERATOR && !fails2(function() {
    $parseInt(Object(ITERATOR));
  });
  numberParseInt = FORCED ? function parseInt2(string, radix) {
    var S = trim(toString2(string));
    return $parseInt(S, radix >>> 0 || (exec(hex2, S) ? 16 : 10));
  } : $parseInt;
  return numberParseInt;
}
var hasRequiredEs_parseInt;
function requireEs_parseInt() {
  if (hasRequiredEs_parseInt)
    return es_parseInt;
  hasRequiredEs_parseInt = 1;
  var $2 = _export;
  var $parseInt = requireNumberParseInt();
  $2({ global: true, forced: parseInt != $parseInt }, {
    parseInt: $parseInt
  });
  return es_parseInt;
}
var _parseInt$1;
var hasRequired_parseInt$2;
function require_parseInt$2() {
  if (hasRequired_parseInt$2)
    return _parseInt$1;
  hasRequired_parseInt$2 = 1;
  requireEs_parseInt();
  var path2 = path$2;
  _parseInt$1 = path2.parseInt;
  return _parseInt$1;
}
var _parseInt;
var hasRequired_parseInt$1;
function require_parseInt$1() {
  if (hasRequired_parseInt$1)
    return _parseInt;
  hasRequired_parseInt$1 = 1;
  var parent2 = require_parseInt$2();
  _parseInt = parent2;
  return _parseInt;
}
var hasRequired_parseInt;
function require_parseInt() {
  if (hasRequired_parseInt)
    return _parseIntExports;
  hasRequired_parseInt = 1;
  (function(module) {
    module.exports = require_parseInt$1();
  })(_parseInt$2);
  return _parseIntExports;
}
var sliceExports = {};
var slice = {
  get exports() {
    return sliceExports;
  },
  set exports(v) {
    sliceExports = v;
  }
};
var hasRequiredSlice;
function requireSlice() {
  if (hasRequiredSlice)
    return sliceExports;
  hasRequiredSlice = 1;
  (function(module) {
    module.exports = requireSlice$5();
  })(slice);
  return sliceExports;
}
var sortExports = {};
var sort$3 = {
  get exports() {
    return sortExports;
  },
  set exports(v) {
    sortExports = v;
  }
};
var es_array_sort = {};
var deletePropertyOrThrow;
var hasRequiredDeletePropertyOrThrow;
function requireDeletePropertyOrThrow() {
  if (hasRequiredDeletePropertyOrThrow)
    return deletePropertyOrThrow;
  hasRequiredDeletePropertyOrThrow = 1;
  var tryToString2 = tryToString$1;
  var $TypeError2 = TypeError;
  deletePropertyOrThrow = function(O, P) {
    if (!delete O[P])
      throw $TypeError2("Cannot delete property " + tryToString2(P) + " of " + tryToString2(O));
  };
  return deletePropertyOrThrow;
}
var arraySort;
var hasRequiredArraySort;
function requireArraySort() {
  if (hasRequiredArraySort)
    return arraySort;
  hasRequiredArraySort = 1;
  var arraySlice2 = requireArraySliceSimple();
  var floor = Math.floor;
  var mergeSort = function(array, comparefn) {
    var length = array.length;
    var middle = floor(length / 2);
    return length < 8 ? insertionSort(array, comparefn) : merge(
      array,
      mergeSort(arraySlice2(array, 0, middle), comparefn),
      mergeSort(arraySlice2(array, middle), comparefn),
      comparefn
    );
  };
  var insertionSort = function(array, comparefn) {
    var length = array.length;
    var i = 1;
    var element, j;
    while (i < length) {
      j = i;
      element = array[i];
      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }
      if (j !== i++)
        array[j] = element;
    }
    return array;
  };
  var merge = function(array, left, right, comparefn) {
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;
    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
    }
    return array;
  };
  arraySort = mergeSort;
  return arraySort;
}
var engineFfVersion;
var hasRequiredEngineFfVersion;
function requireEngineFfVersion() {
  if (hasRequiredEngineFfVersion)
    return engineFfVersion;
  hasRequiredEngineFfVersion = 1;
  var userAgent = requireEngineUserAgent();
  var firefox = userAgent.match(/firefox\/(\d+)/i);
  engineFfVersion = !!firefox && +firefox[1];
  return engineFfVersion;
}
var engineIsIeOrEdge;
var hasRequiredEngineIsIeOrEdge;
function requireEngineIsIeOrEdge() {
  if (hasRequiredEngineIsIeOrEdge)
    return engineIsIeOrEdge;
  hasRequiredEngineIsIeOrEdge = 1;
  var UA = requireEngineUserAgent();
  engineIsIeOrEdge = /MSIE|Trident/.test(UA);
  return engineIsIeOrEdge;
}
var engineWebkitVersion;
var hasRequiredEngineWebkitVersion;
function requireEngineWebkitVersion() {
  if (hasRequiredEngineWebkitVersion)
    return engineWebkitVersion;
  hasRequiredEngineWebkitVersion = 1;
  var userAgent = requireEngineUserAgent();
  var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
  engineWebkitVersion = !!webkit && +webkit[1];
  return engineWebkitVersion;
}
var hasRequiredEs_array_sort;
function requireEs_array_sort() {
  if (hasRequiredEs_array_sort)
    return es_array_sort;
  hasRequiredEs_array_sort = 1;
  var $2 = _export;
  var uncurryThis2 = requireFunctionUncurryThis();
  var aCallable2 = aCallable$2;
  var toObject2 = requireToObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var deletePropertyOrThrow2 = requireDeletePropertyOrThrow();
  var toString2 = requireToString();
  var fails2 = fails$6;
  var internalSort = requireArraySort();
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var FF = requireEngineFfVersion();
  var IE_OR_EDGE = requireEngineIsIeOrEdge();
  var V8 = requireEngineV8Version();
  var WEBKIT = requireEngineWebkitVersion();
  var test = [];
  var nativeSort = uncurryThis2(test.sort);
  var push = uncurryThis2(test.push);
  var FAILS_ON_UNDEFINED = fails2(function() {
    test.sort(void 0);
  });
  var FAILS_ON_NULL = fails2(function() {
    test.sort(null);
  });
  var STRICT_METHOD = arrayMethodIsStrict2("sort");
  var STABLE_SORT = !fails2(function() {
    if (V8)
      return V8 < 70;
    if (FF && FF > 3)
      return;
    if (IE_OR_EDGE)
      return true;
    if (WEBKIT)
      return WEBKIT < 603;
    var result = "";
    var code, chr, value, index;
    for (code = 65; code < 76; code++) {
      chr = String.fromCharCode(code);
      switch (code) {
        case 66:
        case 69:
        case 70:
        case 72:
          value = 3;
          break;
        case 68:
        case 71:
          value = 4;
          break;
        default:
          value = 2;
      }
      for (index = 0; index < 47; index++) {
        test.push({ k: chr + index, v: value });
      }
    }
    test.sort(function(a, b) {
      return b.v - a.v;
    });
    for (index = 0; index < test.length; index++) {
      chr = test[index].k.charAt(0);
      if (result.charAt(result.length - 1) !== chr)
        result += chr;
    }
    return result !== "DGBEFHACIJK";
  });
  var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
  var getSortCompare = function(comparefn) {
    return function(x, y) {
      if (y === void 0)
        return -1;
      if (x === void 0)
        return 1;
      if (comparefn !== void 0)
        return +comparefn(x, y) || 0;
      return toString2(x) > toString2(y) ? 1 : -1;
    };
  };
  $2({ target: "Array", proto: true, forced: FORCED }, {
    sort: function sort2(comparefn) {
      if (comparefn !== void 0)
        aCallable2(comparefn);
      var array = toObject2(this);
      if (STABLE_SORT)
        return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
      var items = [];
      var arrayLength = lengthOfArrayLike2(array);
      var itemsLength, index;
      for (index = 0; index < arrayLength; index++) {
        if (index in array)
          push(items, array[index]);
      }
      internalSort(items, getSortCompare(comparefn));
      itemsLength = lengthOfArrayLike2(items);
      index = 0;
      while (index < itemsLength)
        array[index] = items[index++];
      while (index < arrayLength)
        deletePropertyOrThrow2(array, index++);
      return array;
    }
  });
  return es_array_sort;
}
var sort$2;
var hasRequiredSort$3;
function requireSort$3() {
  if (hasRequiredSort$3)
    return sort$2;
  hasRequiredSort$3 = 1;
  requireEs_array_sort();
  var entryVirtual2 = requireEntryVirtual();
  sort$2 = entryVirtual2("Array").sort;
  return sort$2;
}
var sort$1;
var hasRequiredSort$2;
function requireSort$2() {
  if (hasRequiredSort$2)
    return sort$1;
  hasRequiredSort$2 = 1;
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var method = requireSort$3();
  var ArrayPrototype = Array.prototype;
  sort$1 = function(it) {
    var own = it.sort;
    return it === ArrayPrototype || isPrototypeOf2(ArrayPrototype, it) && own === ArrayPrototype.sort ? method : own;
  };
  return sort$1;
}
var sort;
var hasRequiredSort$1;
function requireSort$1() {
  if (hasRequiredSort$1)
    return sort;
  hasRequiredSort$1 = 1;
  var parent2 = requireSort$2();
  sort = parent2;
  return sort;
}
var hasRequiredSort;
function requireSort() {
  if (hasRequiredSort)
    return sortExports;
  hasRequiredSort = 1;
  (function(module) {
    module.exports = requireSort$1();
  })(sort$3);
  return sortExports;
}
var flagsExports = {};
var flags$2 = {
  get exports() {
    return flagsExports;
  },
  set exports(v) {
    flagsExports = v;
  }
};
var regexpFlags;
var hasRequiredRegexpFlags;
function requireRegexpFlags() {
  if (hasRequiredRegexpFlags)
    return regexpFlags;
  hasRequiredRegexpFlags = 1;
  var anObject2 = anObject$1;
  regexpFlags = function() {
    var that = anObject2(this);
    var result = "";
    if (that.hasIndices)
      result += "d";
    if (that.global)
      result += "g";
    if (that.ignoreCase)
      result += "i";
    if (that.multiline)
      result += "m";
    if (that.dotAll)
      result += "s";
    if (that.unicode)
      result += "u";
    if (that.unicodeSets)
      result += "v";
    if (that.sticky)
      result += "y";
    return result;
  };
  return regexpFlags;
}
var regexpGetFlags;
var hasRequiredRegexpGetFlags;
function requireRegexpGetFlags() {
  if (hasRequiredRegexpGetFlags)
    return regexpGetFlags;
  hasRequiredRegexpGetFlags = 1;
  var call2 = functionCall;
  var hasOwn2 = requireHasOwnProperty();
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var regExpFlags = requireRegexpFlags();
  var RegExpPrototype = RegExp.prototype;
  regexpGetFlags = function(R) {
    var flags2 = R.flags;
    return flags2 === void 0 && !("flags" in RegExpPrototype) && !hasOwn2(R, "flags") && isPrototypeOf2(RegExpPrototype, R) ? call2(regExpFlags, R) : flags2;
  };
  return regexpGetFlags;
}
var flags$1;
var hasRequiredFlags$3;
function requireFlags$3() {
  if (hasRequiredFlags$3)
    return flags$1;
  hasRequiredFlags$3 = 1;
  var getRegExpFlags = requireRegexpGetFlags();
  flags$1 = getRegExpFlags;
  return flags$1;
}
var flags_1;
var hasRequiredFlags$2;
function requireFlags$2() {
  if (hasRequiredFlags$2)
    return flags_1;
  hasRequiredFlags$2 = 1;
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var flags2 = requireFlags$3();
  var RegExpPrototype = RegExp.prototype;
  flags_1 = function(it) {
    return it === RegExpPrototype || isPrototypeOf2(RegExpPrototype, it) ? flags2(it) : it.flags;
  };
  return flags_1;
}
var flags;
var hasRequiredFlags$1;
function requireFlags$1() {
  if (hasRequiredFlags$1)
    return flags;
  hasRequiredFlags$1 = 1;
  var parent2 = requireFlags$2();
  flags = parent2;
  return flags;
}
var hasRequiredFlags;
function requireFlags() {
  if (hasRequiredFlags)
    return flagsExports;
  hasRequiredFlags = 1;
  (function(module) {
    module.exports = requireFlags$1();
  })(flags$2);
  return flagsExports;
}
var hasRequiredXregexp;
function requireXregexp() {
  if (hasRequiredXregexp)
    return xregexpExports;
  hasRequiredXregexp = 1;
  (function(module, exports) {
    var _interopRequireDefault = interopRequireDefaultExports;
    var _Object$defineProperty = definePropertyExports$1;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _getIterator2 = _interopRequireDefault(requireGetIterator());
    var _isArray = _interopRequireDefault(requireIsArray$4());
    var _getIteratorMethod2 = _interopRequireDefault(requireGetIteratorMethod());
    var _symbol = _interopRequireDefault(requireSymbol$4());
    var _from = _interopRequireDefault(requireFrom$4());
    var _concat = _interopRequireDefault(requireConcat());
    var _indexOf = _interopRequireDefault(requireIndexOf());
    var _create = _interopRequireDefault(requireCreate());
    var _slicedToArray2 = _interopRequireDefault(requireSlicedToArray());
    var _forEach = _interopRequireDefault(requireForEach());
    var _includes = _interopRequireDefault(requireIncludes());
    var _parseInt2 = _interopRequireDefault(require_parseInt());
    var _slice = _interopRequireDefault(requireSlice());
    var _sort = _interopRequireDefault(requireSort());
    var _flags = _interopRequireDefault(requireFlags());
    function _createForOfIteratorHelper2(o, allowArrayLike) {
      var it;
      if (typeof _symbol["default"] === "undefined" || (0, _getIteratorMethod2["default"])(o) == null) {
        if ((0, _isArray["default"])(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return {
            s: F,
            n: function n() {
              if (i >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function e(_e) {
              throw _e;
            },
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = (0, _getIterator2["default"])(o);
        },
        n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function f() {
          try {
            if (!normalCompletion && it["return"] != null)
              it["return"]();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray2(o, minLen) {
      var _context9;
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray2(o, minLen);
      var n = (0, _slice["default"])(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return (0, _from["default"])(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray2(o, minLen);
    }
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    /*!
     * XRegExp 4.4.1
     * <xregexp.com>
     * Steven Levithan (c) 2007-present MIT License
     */
    var REGEX_DATA2 = "xregexp";
    var features2 = {
      astral: false,
      namespacing: false
    };
    var nativ = {
      exec: RegExp.prototype.exec,
      test: RegExp.prototype.test,
      match: String.prototype.match,
      replace: String.prototype.replace,
      split: String.prototype.split
    };
    var fixed2 = {};
    var regexCache2 = {};
    var patternCache2 = {};
    var tokens2 = [];
    var defaultScope2 = "default";
    var classScope2 = "class";
    var nativeTokens2 = {
      // Any native multicharacter token in default scope, or any single character
      "default": /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
      // Any native multicharacter token in character class scope, or any single character
      "class": /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
    };
    var replacementToken2 = /\$(?:{([\w$]+)}|<([\w$]+)>|(\d\d?|[\s\S]))/g;
    var correctExecNpcg2 = nativ.exec.call(/()??/, "")[1] === void 0;
    var hasFlagsProp2 = (0, _flags["default"])(/x/) !== void 0;
    var _ref = {}, toString2 = _ref.toString;
    function hasNativeFlag2(flag) {
      var isSupported = true;
      try {
        new RegExp("", flag);
        if (flag === "y") {
          var gy = function() {
            return "gy";
          }();
          var incompleteY = ".a".replace(new RegExp("a", gy), ".") === "..";
          if (incompleteY) {
            isSupported = false;
          }
        }
      } catch (exception) {
        isSupported = false;
      }
      return isSupported;
    }
    var hasNativeU2 = hasNativeFlag2("u");
    var hasNativeY2 = hasNativeFlag2("y");
    var registeredFlags2 = {
      g: true,
      i: true,
      m: true,
      u: hasNativeU2,
      y: hasNativeY2
    };
    function augment2(regex, captureNames, xSource, xFlags, isInternalOnly) {
      var _context;
      regex[REGEX_DATA2] = {
        captureNames
      };
      if (isInternalOnly) {
        return regex;
      }
      if (regex.__proto__) {
        regex.__proto__ = XRegExp2.prototype;
      } else {
        for (var p in XRegExp2.prototype) {
          regex[p] = XRegExp2.prototype[p];
        }
      }
      regex[REGEX_DATA2].source = xSource;
      regex[REGEX_DATA2].flags = xFlags ? (0, _sort["default"])(_context = xFlags.split("")).call(_context).join("") : xFlags;
      return regex;
    }
    function clipDuplicates2(str) {
      return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, "");
    }
    function copyRegex2(regex, options) {
      var _context2;
      if (!XRegExp2.isRegExp(regex)) {
        throw new TypeError("Type RegExp expected");
      }
      var xData = regex[REGEX_DATA2] || {};
      var flags2 = getNativeFlags2(regex);
      var flagsToAdd = "";
      var flagsToRemove = "";
      var xregexpSource = null;
      var xregexpFlags = null;
      options = options || {};
      if (options.removeG) {
        flagsToRemove += "g";
      }
      if (options.removeY) {
        flagsToRemove += "y";
      }
      if (flagsToRemove) {
        flags2 = nativ.replace.call(flags2, new RegExp("[".concat(flagsToRemove, "]+"), "g"), "");
      }
      if (options.addG) {
        flagsToAdd += "g";
      }
      if (options.addY) {
        flagsToAdd += "y";
      }
      if (flagsToAdd) {
        flags2 = clipDuplicates2(flags2 + flagsToAdd);
      }
      if (!options.isInternalOnly) {
        if (xData.source !== void 0) {
          xregexpSource = xData.source;
        }
        if ((0, _flags["default"])(xData) != null) {
          xregexpFlags = flagsToAdd ? clipDuplicates2((0, _flags["default"])(xData) + flagsToAdd) : (0, _flags["default"])(xData);
        }
      }
      regex = augment2(new RegExp(options.source || regex.source, flags2), hasNamedCapture2(regex) ? (0, _slice["default"])(_context2 = xData.captureNames).call(_context2, 0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);
      return regex;
    }
    function dec2(hex3) {
      return (0, _parseInt2["default"])(hex3, 16);
    }
    function getContextualTokenSeparator2(match, scope, flags2) {
      if (
        // No need to separate tokens if at the beginning or end of a group
        match.input[match.index - 1] === "(" || match.input[match.index + match[0].length] === ")" || // No need to separate tokens if before or after a `|`
        match.input[match.index - 1] === "|" || match.input[match.index + match[0].length] === "|" || // No need to separate tokens if at the beginning or end of the pattern
        match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.
        // The way this is written relies on:
        // - The search regex matching only 3-char strings.
        // - Although `substr` gives chars from the end of the string if given a negative index,
        //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`
        nativ.test.call(/^\(\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier
        isQuantifierNext2(match.input, match.index + match[0].length, flags2)
      ) {
        return "";
      }
      return "(?:)";
    }
    function getNativeFlags2(regex) {
      return hasFlagsProp2 ? (0, _flags["default"])(regex) : (
        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
        // with an empty string) allows this to continue working predictably when
        // `XRegExp.proptotype.toString` is overridden
        nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1]
      );
    }
    function hasNamedCapture2(regex) {
      return !!(regex[REGEX_DATA2] && regex[REGEX_DATA2].captureNames);
    }
    function hex2(dec3) {
      return (0, _parseInt2["default"])(dec3, 10).toString(16);
    }
    function isQuantifierNext2(pattern, pos, flags2) {
      return nativ.test.call((0, _includes["default"])(flags2).call(flags2, "x") ? (
        // Ignore any leading whitespace, line comments, and inline comments
        /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/
      ) : (
        // Ignore any leading inline comments
        /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/
      ), (0, _slice["default"])(pattern).call(pattern, pos));
    }
    function isType2(value, type) {
      return toString2.call(value) === "[object ".concat(type, "]");
    }
    function pad42(str) {
      while (str.length < 4) {
        str = "0".concat(str);
      }
      return str;
    }
    function prepareFlags2(pattern, flags2) {
      if (clipDuplicates2(flags2) !== flags2) {
        throw new SyntaxError("Invalid duplicate regex flag ".concat(flags2));
      }
      pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
        if (nativ.test.call(/[gy]/, $1)) {
          throw new SyntaxError("Cannot use flag g or y in mode modifier ".concat($0));
        }
        flags2 = clipDuplicates2(flags2 + $1);
        return "";
      });
      var _iterator = _createForOfIteratorHelper2(flags2), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var flag = _step.value;
          if (!registeredFlags2[flag]) {
            throw new SyntaxError("Unknown regex flag ".concat(flag));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return {
        pattern,
        flags: flags2
      };
    }
    function prepareOptions2(value) {
      var options = {};
      if (isType2(value, "String")) {
        (0, _forEach["default"])(XRegExp2).call(XRegExp2, value, /[^\s,]+/, function(match) {
          options[match] = true;
        });
        return options;
      }
      return value;
    }
    function registerFlag2(flag) {
      if (!/^[\w$]$/.test(flag)) {
        throw new Error("Flag must be a single character A-Za-z0-9_$");
      }
      registeredFlags2[flag] = true;
    }
    function runTokens2(pattern, flags2, pos, scope, context) {
      var i = tokens2.length;
      var leadChar = pattern[pos];
      var result = null;
      var match;
      var t;
      while (i--) {
        t = tokens2[i];
        if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== "all" || t.flag && !(0, _includes["default"])(flags2).call(flags2, t.flag)) {
          continue;
        }
        match = XRegExp2.exec(pattern, t.regex, pos, "sticky");
        if (match) {
          result = {
            matchLength: match[0].length,
            output: t.handler.call(context, match, scope, flags2),
            reparse: t.reparse
          };
          break;
        }
      }
      return result;
    }
    function setAstral2(on) {
      features2.astral = on;
    }
    function setNamespacing2(on) {
      features2.namespacing = on;
    }
    function toObject2(value) {
      if (value == null) {
        throw new TypeError("Cannot convert null or undefined to object");
      }
      return value;
    }
    function XRegExp2(pattern, flags2) {
      if (XRegExp2.isRegExp(pattern)) {
        if (flags2 !== void 0) {
          throw new TypeError("Cannot supply flags when copying a RegExp");
        }
        return copyRegex2(pattern);
      }
      pattern = pattern === void 0 ? "" : String(pattern);
      flags2 = flags2 === void 0 ? "" : String(flags2);
      if (XRegExp2.isInstalled("astral") && !(0, _includes["default"])(flags2).call(flags2, "A")) {
        flags2 += "A";
      }
      if (!patternCache2[pattern]) {
        patternCache2[pattern] = {};
      }
      if (!patternCache2[pattern][flags2]) {
        var context = {
          hasNamedCapture: false,
          captureNames: []
        };
        var scope = defaultScope2;
        var output = "";
        var pos = 0;
        var result;
        var applied = prepareFlags2(pattern, flags2);
        var appliedPattern = applied.pattern;
        var appliedFlags = (0, _flags["default"])(applied);
        while (pos < appliedPattern.length) {
          do {
            result = runTokens2(appliedPattern, appliedFlags, pos, scope, context);
            if (result && result.reparse) {
              appliedPattern = (0, _slice["default"])(appliedPattern).call(appliedPattern, 0, pos) + result.output + (0, _slice["default"])(appliedPattern).call(appliedPattern, pos + result.matchLength);
            }
          } while (result && result.reparse);
          if (result) {
            output += result.output;
            pos += result.matchLength || 1;
          } else {
            var _XRegExp$exec = XRegExp2.exec(appliedPattern, nativeTokens2[scope], pos, "sticky"), _XRegExp$exec2 = (0, _slicedToArray2["default"])(_XRegExp$exec, 1), token = _XRegExp$exec2[0];
            output += token;
            pos += token.length;
            if (token === "[" && scope === defaultScope2) {
              scope = classScope2;
            } else if (token === "]" && scope === classScope2) {
              scope = defaultScope2;
            }
          }
        }
        patternCache2[pattern][flags2] = {
          // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
          // groups are sometimes inserted during regex transpilation in order to keep tokens
          // separated. However, more than one empty group in a row is never needed.
          pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, "(?:)"),
          // Strip all but native flags
          flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ""),
          // `context.captureNames` has an item for each capturing group, even if unnamed
          captures: context.hasNamedCapture ? context.captureNames : null
        };
      }
      var generated = patternCache2[pattern][flags2];
      return augment2(new RegExp(generated.pattern, (0, _flags["default"])(generated)), generated.captures, pattern, flags2);
    }
    XRegExp2.prototype = /(?:)/;
    XRegExp2.version = "4.4.1";
    XRegExp2._clipDuplicates = clipDuplicates2;
    XRegExp2._hasNativeFlag = hasNativeFlag2;
    XRegExp2._dec = dec2;
    XRegExp2._hex = hex2;
    XRegExp2._pad4 = pad42;
    XRegExp2.addToken = function(regex, handler, options) {
      options = options || {};
      var _options = options, optionalFlags = _options.optionalFlags;
      if (options.flag) {
        registerFlag2(options.flag);
      }
      if (optionalFlags) {
        optionalFlags = nativ.split.call(optionalFlags, "");
        var _iterator2 = _createForOfIteratorHelper2(optionalFlags), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var flag = _step2.value;
            registerFlag2(flag);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      tokens2.push({
        regex: copyRegex2(regex, {
          addG: true,
          addY: hasNativeY2,
          isInternalOnly: true
        }),
        handler,
        scope: options.scope || defaultScope2,
        flag: options.flag,
        reparse: options.reparse,
        leadChar: options.leadChar
      });
      XRegExp2.cache.flush("patterns");
    };
    XRegExp2.cache = function(pattern, flags2) {
      if (!regexCache2[pattern]) {
        regexCache2[pattern] = {};
      }
      return regexCache2[pattern][flags2] || (regexCache2[pattern][flags2] = XRegExp2(pattern, flags2));
    };
    XRegExp2.cache.flush = function(cacheName) {
      if (cacheName === "patterns") {
        patternCache2 = {};
      } else {
        regexCache2 = {};
      }
    };
    XRegExp2.escape = function(str) {
      return nativ.replace.call(toObject2(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    };
    XRegExp2.exec = function(str, regex, pos, sticky) {
      var cacheKey = "g";
      var addY = false;
      var fakeY = false;
      var match;
      addY = hasNativeY2 && !!(sticky || regex.sticky && sticky !== false);
      if (addY) {
        cacheKey += "y";
      } else if (sticky) {
        fakeY = true;
        cacheKey += "FakeY";
      }
      regex[REGEX_DATA2] = regex[REGEX_DATA2] || {};
      var r2 = regex[REGEX_DATA2][cacheKey] || (regex[REGEX_DATA2][cacheKey] = copyRegex2(regex, {
        addG: true,
        addY,
        source: fakeY ? "".concat(regex.source, "|()") : void 0,
        removeY: sticky === false,
        isInternalOnly: true
      }));
      pos = pos || 0;
      r2.lastIndex = pos;
      match = fixed2.exec.call(r2, str);
      if (fakeY && match && match.pop() === "") {
        match = null;
      }
      if (regex.global) {
        regex.lastIndex = match ? r2.lastIndex : 0;
      }
      return match;
    };
    XRegExp2.forEach = function(str, regex, callback) {
      var pos = 0;
      var i = -1;
      var match;
      while (match = XRegExp2.exec(str, regex, pos)) {
        callback(match, ++i, str, regex);
        pos = match.index + (match[0].length || 1);
      }
    };
    XRegExp2.globalize = function(regex) {
      return copyRegex2(regex, {
        addG: true
      });
    };
    XRegExp2.install = function(options) {
      options = prepareOptions2(options);
      if (!features2.astral && options.astral) {
        setAstral2(true);
      }
      if (!features2.namespacing && options.namespacing) {
        setNamespacing2(true);
      }
    };
    XRegExp2.isInstalled = function(feature) {
      return !!features2[feature];
    };
    XRegExp2.isRegExp = function(value) {
      return toString2.call(value) === "[object RegExp]";
    };
    XRegExp2.match = function(str, regex, scope) {
      var global2 = regex.global && scope !== "one" || scope === "all";
      var cacheKey = (global2 ? "g" : "") + (regex.sticky ? "y" : "") || "noGY";
      regex[REGEX_DATA2] = regex[REGEX_DATA2] || {};
      var r2 = regex[REGEX_DATA2][cacheKey] || (regex[REGEX_DATA2][cacheKey] = copyRegex2(regex, {
        addG: !!global2,
        removeG: scope === "one",
        isInternalOnly: true
      }));
      var result = nativ.match.call(toObject2(str), r2);
      if (regex.global) {
        regex.lastIndex = scope === "one" && result ? (
          // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
          result.index + result[0].length
        ) : 0;
      }
      return global2 ? result || [] : result && result[0];
    };
    XRegExp2.matchChain = function(str, chain) {
      return function recurseChain(values, level) {
        var item = chain[level].regex ? chain[level] : {
          regex: chain[level]
        };
        var matches = [];
        function addMatch(match) {
          if (item.backref) {
            var ERR_UNDEFINED_GROUP = "Backreference to undefined group: ".concat(item.backref);
            var isNamedBackref = isNaN(item.backref);
            if (isNamedBackref && XRegExp2.isInstalled("namespacing")) {
              if (!(item.backref in match.groups)) {
                throw new ReferenceError(ERR_UNDEFINED_GROUP);
              }
            } else if (!match.hasOwnProperty(item.backref)) {
              throw new ReferenceError(ERR_UNDEFINED_GROUP);
            }
            var backrefValue = isNamedBackref && XRegExp2.isInstalled("namespacing") ? match.groups[item.backref] : match[item.backref];
            matches.push(backrefValue || "");
          } else {
            matches.push(match[0]);
          }
        }
        var _iterator3 = _createForOfIteratorHelper2(values), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var value = _step3.value;
            (0, _forEach["default"])(XRegExp2).call(XRegExp2, value, item.regex, addMatch);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);
      }([str], 0);
    };
    XRegExp2.replace = function(str, search, replacement2, scope) {
      var isRegex = XRegExp2.isRegExp(search);
      var global2 = search.global && scope !== "one" || scope === "all";
      var cacheKey = (global2 ? "g" : "") + (search.sticky ? "y" : "") || "noGY";
      var s2 = search;
      if (isRegex) {
        search[REGEX_DATA2] = search[REGEX_DATA2] || {};
        s2 = search[REGEX_DATA2][cacheKey] || (search[REGEX_DATA2][cacheKey] = copyRegex2(search, {
          addG: !!global2,
          removeG: scope === "one",
          isInternalOnly: true
        }));
      } else if (global2) {
        s2 = new RegExp(XRegExp2.escape(String(search)), "g");
      }
      var result = fixed2.replace.call(toObject2(str), s2, replacement2);
      if (isRegex && search.global) {
        search.lastIndex = 0;
      }
      return result;
    };
    XRegExp2.replaceEach = function(str, replacements) {
      var _iterator4 = _createForOfIteratorHelper2(replacements), _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
          var r = _step4.value;
          str = XRegExp2.replace(str, r[0], r[1], r[2]);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return str;
    };
    XRegExp2.split = function(str, separator, limit) {
      return fixed2.split.call(toObject2(str), separator, limit);
    };
    XRegExp2.test = function(str, regex, pos, sticky) {
      return !!XRegExp2.exec(str, regex, pos, sticky);
    };
    XRegExp2.uninstall = function(options) {
      options = prepareOptions2(options);
      if (features2.astral && options.astral) {
        setAstral2(false);
      }
      if (features2.namespacing && options.namespacing) {
        setNamespacing2(false);
      }
    };
    XRegExp2.union = function(patterns, flags2, options) {
      options = options || {};
      var conjunction = options.conjunction || "or";
      var numCaptures = 0;
      var numPriorCaptures;
      var captureNames;
      function rewrite(match, paren, backref) {
        var name = captureNames[numCaptures - numPriorCaptures];
        if (paren) {
          ++numCaptures;
          if (name) {
            return "(?<".concat(name, ">");
          }
        } else if (backref) {
          return "\\".concat(+backref + numPriorCaptures);
        }
        return match;
      }
      if (!(isType2(patterns, "Array") && patterns.length)) {
        throw new TypeError("Must provide a nonempty array of patterns to merge");
      }
      var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
      var output = [];
      var _iterator5 = _createForOfIteratorHelper2(patterns), _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
          var pattern = _step5.value;
          if (XRegExp2.isRegExp(pattern)) {
            numPriorCaptures = numCaptures;
            captureNames = pattern[REGEX_DATA2] && pattern[REGEX_DATA2].captureNames || [];
            output.push(nativ.replace.call(XRegExp2(pattern.source).source, parts, rewrite));
          } else {
            output.push(XRegExp2.escape(pattern));
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      var separator = conjunction === "none" ? "" : "|";
      return XRegExp2(output.join(separator), flags2);
    };
    fixed2.exec = function(str) {
      var origLastIndex = this.lastIndex;
      var match = nativ.exec.apply(this, arguments);
      if (match) {
        if (!correctExecNpcg2 && match.length > 1 && (0, _includes["default"])(match).call(match, "")) {
          var _context3;
          var r2 = copyRegex2(this, {
            removeG: true,
            isInternalOnly: true
          });
          nativ.replace.call((0, _slice["default"])(_context3 = String(str)).call(_context3, match.index), r2, function() {
            var len = arguments.length;
            for (var i2 = 1; i2 < len - 2; ++i2) {
              if ((i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]) === void 0) {
                match[i2] = void 0;
              }
            }
          });
        }
        var groupsObject = match;
        if (XRegExp2.isInstalled("namespacing")) {
          match.groups = (0, _create["default"])(null);
          groupsObject = match.groups;
        }
        if (this[REGEX_DATA2] && this[REGEX_DATA2].captureNames) {
          for (var i = 1; i < match.length; ++i) {
            var name = this[REGEX_DATA2].captureNames[i - 1];
            if (name) {
              groupsObject[name] = match[i];
            }
          }
        }
        if (this.global && !match[0].length && this.lastIndex > match.index) {
          this.lastIndex = match.index;
        }
      }
      if (!this.global) {
        this.lastIndex = origLastIndex;
      }
      return match;
    };
    fixed2.test = function(str) {
      return !!fixed2.exec.call(this, str);
    };
    fixed2.match = function(regex) {
      if (!XRegExp2.isRegExp(regex)) {
        regex = new RegExp(regex);
      } else if (regex.global) {
        var result = nativ.match.apply(this, arguments);
        regex.lastIndex = 0;
        return result;
      }
      return fixed2.exec.call(regex, toObject2(this));
    };
    fixed2.replace = function(search, replacement2) {
      var isRegex = XRegExp2.isRegExp(search);
      var origLastIndex;
      var captureNames;
      var result;
      if (isRegex) {
        if (search[REGEX_DATA2]) {
          captureNames = search[REGEX_DATA2].captureNames;
        }
        origLastIndex = search.lastIndex;
      } else {
        search += "";
      }
      if (isType2(replacement2, "Function")) {
        result = nativ.replace.call(String(this), search, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (captureNames) {
            var groupsObject;
            if (XRegExp2.isInstalled("namespacing")) {
              groupsObject = (0, _create["default"])(null);
              args.push(groupsObject);
            } else {
              args[0] = new String(args[0]);
              groupsObject = args[0];
            }
            for (var i = 0; i < captureNames.length; ++i) {
              if (captureNames[i]) {
                groupsObject[captureNames[i]] = args[i + 1];
              }
            }
          }
          return replacement2.apply(void 0, args);
        });
      } else {
        result = nativ.replace.call(this == null ? this : String(this), search, function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return nativ.replace.call(String(replacement2), replacementToken2, replacer);
          function replacer($0, bracketed, angled, dollarToken) {
            bracketed = bracketed || angled;
            if (bracketed) {
              var n = +bracketed;
              if (n <= args.length - 3) {
                return args[n] || "";
              }
              n = captureNames ? (0, _indexOf["default"])(captureNames).call(captureNames, bracketed) : -1;
              if (n < 0) {
                throw new SyntaxError("Backreference to undefined group ".concat($0));
              }
              return args[n + 1] || "";
            }
            if (dollarToken === "$") {
              return "$";
            }
            if (dollarToken === "&" || +dollarToken === 0) {
              return args[0];
            }
            if (dollarToken === "`") {
              var _context4;
              return (0, _slice["default"])(_context4 = args[args.length - 1]).call(_context4, 0, args[args.length - 2]);
            }
            if (dollarToken === "'") {
              var _context5;
              return (0, _slice["default"])(_context5 = args[args.length - 1]).call(_context5, args[args.length - 2] + args[0].length);
            }
            dollarToken = +dollarToken;
            if (!isNaN(dollarToken)) {
              if (dollarToken > args.length - 3) {
                throw new SyntaxError("Backreference to undefined group ".concat($0));
              }
              return args[dollarToken] || "";
            }
            throw new SyntaxError("Invalid token ".concat($0));
          }
        });
      }
      if (isRegex) {
        if (search.global) {
          search.lastIndex = 0;
        } else {
          search.lastIndex = origLastIndex;
        }
      }
      return result;
    };
    fixed2.split = function(separator, limit) {
      if (!XRegExp2.isRegExp(separator)) {
        return nativ.split.apply(this, arguments);
      }
      var str = String(this);
      var output = [];
      var origLastIndex = separator.lastIndex;
      var lastLastIndex = 0;
      var lastLength;
      limit = (limit === void 0 ? -1 : limit) >>> 0;
      (0, _forEach["default"])(XRegExp2).call(XRegExp2, str, separator, function(match) {
        if (match.index + match[0].length > lastLastIndex) {
          output.push((0, _slice["default"])(str).call(str, lastLastIndex, match.index));
          if (match.length > 1 && match.index < str.length) {
            Array.prototype.push.apply(output, (0, _slice["default"])(match).call(match, 1));
          }
          lastLength = match[0].length;
          lastLastIndex = match.index + lastLength;
        }
      });
      if (lastLastIndex === str.length) {
        if (!nativ.test.call(separator, "") || lastLength) {
          output.push("");
        }
      } else {
        output.push((0, _slice["default"])(str).call(str, lastLastIndex));
      }
      separator.lastIndex = origLastIndex;
      return output.length > limit ? (0, _slice["default"])(output).call(output, 0, limit) : output;
    };
    XRegExp2.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function(match, scope) {
      if (match[1] === "B" && scope === defaultScope2) {
        return match[0];
      }
      throw new SyntaxError("Invalid escape ".concat(match[0]));
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp2.addToken(/\\u{([\dA-Fa-f]+)}/, function(match, scope, flags2) {
      var code = dec2(match[1]);
      if (code > 1114111) {
        throw new SyntaxError("Invalid Unicode code point ".concat(match[0]));
      }
      if (code <= 65535) {
        return "\\u".concat(pad42(hex2(code)));
      }
      if (hasNativeU2 && (0, _includes["default"])(flags2).call(flags2, "u")) {
        return match[0];
      }
      throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u");
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp2.addToken(
      /\[(\^?)\]/,
      // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
      // (?!) should work like \b\B, but is unreliable in some versions of Firefox
      /* eslint-disable no-confusing-arrow */
      function(match) {
        return match[1] ? "[\\s\\S]" : "\\b\\B";
      },
      /* eslint-enable no-confusing-arrow */
      {
        leadChar: "["
      }
    );
    XRegExp2.addToken(/\(\?#[^)]*\)/, getContextualTokenSeparator2, {
      leadChar: "("
    });
    XRegExp2.addToken(/\s+|#[^\n]*\n?/, getContextualTokenSeparator2, {
      flag: "x"
    });
    XRegExp2.addToken(/\./, function() {
      return "[\\s\\S]";
    }, {
      flag: "s",
      leadChar: "."
    });
    XRegExp2.addToken(/\\k<([\w$]+)>/, function(match) {
      var _context6, _context7;
      var index = isNaN(match[1]) ? (0, _indexOf["default"])(_context6 = this.captureNames).call(_context6, match[1]) + 1 : +match[1];
      var endIndex = match.index + match[0].length;
      if (!index || index > this.captureNames.length) {
        throw new SyntaxError("Backreference to undefined group ".concat(match[0]));
      }
      return (0, _concat["default"])(_context7 = "\\".concat(index)).call(_context7, endIndex === match.input.length || isNaN(match.input[endIndex]) ? "" : "(?:)");
    }, {
      leadChar: "\\"
    });
    XRegExp2.addToken(/\\(\d+)/, function(match, scope) {
      if (!(scope === defaultScope2 && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== "0") {
        throw new SyntaxError("Cannot use octal escape or backreference to undefined group ".concat(match[0]));
      }
      return match[0];
    }, {
      scope: "all",
      leadChar: "\\"
    });
    XRegExp2.addToken(/\(\?P?<([\w$]+)>/, function(match) {
      var _context8;
      if (!isNaN(match[1])) {
        throw new SyntaxError("Cannot use integer as capture name ".concat(match[0]));
      }
      if (!XRegExp2.isInstalled("namespacing") && (match[1] === "length" || match[1] === "__proto__")) {
        throw new SyntaxError("Cannot use reserved word as capture name ".concat(match[0]));
      }
      if ((0, _includes["default"])(_context8 = this.captureNames).call(_context8, match[1])) {
        throw new SyntaxError("Cannot use same name for multiple groups ".concat(match[0]));
      }
      this.captureNames.push(match[1]);
      this.hasNamedCapture = true;
      return "(";
    }, {
      leadChar: "("
    });
    XRegExp2.addToken(/\((?!\?)/, function(match, scope, flags2) {
      if ((0, _includes["default"])(flags2).call(flags2, "n")) {
        return "(?:";
      }
      this.captureNames.push(null);
      return "(";
    }, {
      optionalFlags: "n",
      leadChar: "("
    });
    var _default = XRegExp2;
    exports["default"] = _default;
    module.exports = exports.default;
  })(xregexp, xregexpExports);
  return xregexpExports;
}
var buildExports = {};
var build$1 = {
  get exports() {
    return buildExports;
  },
  set exports(v) {
    buildExports = v;
  }
};
var mapExports = {};
var map$3 = {
  get exports() {
    return mapExports;
  },
  set exports(v) {
    mapExports = v;
  }
};
var es_array_map = {};
var hasRequiredEs_array_map;
function requireEs_array_map() {
  if (hasRequiredEs_array_map)
    return es_array_map;
  hasRequiredEs_array_map = 1;
  var $2 = _export;
  var $map = requireArrayIteration().map;
  var arrayMethodHasSpeciesSupport2 = requireArrayMethodHasSpeciesSupport();
  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport2("map");
  $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
    map: function map2(callbackfn) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  return es_array_map;
}
var map$2;
var hasRequiredMap$3;
function requireMap$3() {
  if (hasRequiredMap$3)
    return map$2;
  hasRequiredMap$3 = 1;
  requireEs_array_map();
  var entryVirtual2 = requireEntryVirtual();
  map$2 = entryVirtual2("Array").map;
  return map$2;
}
var map$1;
var hasRequiredMap$2;
function requireMap$2() {
  if (hasRequiredMap$2)
    return map$1;
  hasRequiredMap$2 = 1;
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var method = requireMap$3();
  var ArrayPrototype = Array.prototype;
  map$1 = function(it) {
    var own = it.map;
    return it === ArrayPrototype || isPrototypeOf2(ArrayPrototype, it) && own === ArrayPrototype.map ? method : own;
  };
  return map$1;
}
var map;
var hasRequiredMap$1;
function requireMap$1() {
  if (hasRequiredMap$1)
    return map;
  hasRequiredMap$1 = 1;
  var parent2 = requireMap$2();
  map = parent2;
  return map;
}
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap)
    return mapExports;
  hasRequiredMap = 1;
  (function(module) {
    module.exports = requireMap$1();
  })(map$3);
  return mapExports;
}
var reduceExports = {};
var reduce$3 = {
  get exports() {
    return reduceExports;
  },
  set exports(v) {
    reduceExports = v;
  }
};
var es_array_reduce = {};
var arrayReduce;
var hasRequiredArrayReduce;
function requireArrayReduce() {
  if (hasRequiredArrayReduce)
    return arrayReduce;
  hasRequiredArrayReduce = 1;
  var aCallable2 = aCallable$2;
  var toObject2 = requireToObject();
  var IndexedObject2 = indexedObject;
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var $TypeError2 = TypeError;
  var createMethod = function(IS_RIGHT) {
    return function(that, callbackfn, argumentsLength, memo) {
      aCallable2(callbackfn);
      var O = toObject2(that);
      var self2 = IndexedObject2(O);
      var length = lengthOfArrayLike2(O);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2)
        while (true) {
          if (index in self2) {
            memo = self2[index];
            index += i;
            break;
          }
          index += i;
          if (IS_RIGHT ? index < 0 : length <= index) {
            throw $TypeError2("Reduce of empty array with no initial value");
          }
        }
      for (; IS_RIGHT ? index >= 0 : length > index; index += i)
        if (index in self2) {
          memo = callbackfn(memo, self2[index], index, O);
        }
      return memo;
    };
  };
  arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod(true)
  };
  return arrayReduce;
}
var engineIsNode;
var hasRequiredEngineIsNode;
function requireEngineIsNode() {
  if (hasRequiredEngineIsNode)
    return engineIsNode;
  hasRequiredEngineIsNode = 1;
  var classof2 = requireClassofRaw();
  engineIsNode = typeof process != "undefined" && classof2(process) == "process";
  return engineIsNode;
}
var hasRequiredEs_array_reduce;
function requireEs_array_reduce() {
  if (hasRequiredEs_array_reduce)
    return es_array_reduce;
  hasRequiredEs_array_reduce = 1;
  var $2 = _export;
  var $reduce = requireArrayReduce().left;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var CHROME_VERSION = requireEngineV8Version();
  var IS_NODE = requireEngineIsNode();
  var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
  var FORCED = CHROME_BUG || !arrayMethodIsStrict2("reduce");
  $2({ target: "Array", proto: true, forced: FORCED }, {
    reduce: function reduce2(callbackfn) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
    }
  });
  return es_array_reduce;
}
var reduce$2;
var hasRequiredReduce$3;
function requireReduce$3() {
  if (hasRequiredReduce$3)
    return reduce$2;
  hasRequiredReduce$3 = 1;
  requireEs_array_reduce();
  var entryVirtual2 = requireEntryVirtual();
  reduce$2 = entryVirtual2("Array").reduce;
  return reduce$2;
}
var reduce$1;
var hasRequiredReduce$2;
function requireReduce$2() {
  if (hasRequiredReduce$2)
    return reduce$1;
  hasRequiredReduce$2 = 1;
  var isPrototypeOf2 = requireObjectIsPrototypeOf();
  var method = requireReduce$3();
  var ArrayPrototype = Array.prototype;
  reduce$1 = function(it) {
    var own = it.reduce;
    return it === ArrayPrototype || isPrototypeOf2(ArrayPrototype, it) && own === ArrayPrototype.reduce ? method : own;
  };
  return reduce$1;
}
var reduce;
var hasRequiredReduce$1;
function requireReduce$1() {
  if (hasRequiredReduce$1)
    return reduce;
  hasRequiredReduce$1 = 1;
  var parent2 = requireReduce$2();
  reduce = parent2;
  return reduce;
}
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce)
    return reduceExports;
  hasRequiredReduce = 1;
  (function(module) {
    module.exports = requireReduce$1();
  })(reduce$3);
  return reduceExports;
}
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild)
    return buildExports;
  hasRequiredBuild = 1;
  (function(module, exports) {
    var _interopRequireDefault = interopRequireDefaultExports;
    var _Object$defineProperty = definePropertyExports$1;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _concat = _interopRequireDefault(requireConcat());
    var _includes = _interopRequireDefault(requireIncludes());
    var _map = _interopRequireDefault(requireMap());
    var _reduce = _interopRequireDefault(requireReduce());
    /*!
     * XRegExp.build 4.4.1
     * <xregexp.com>
     * Steven Levithan (c) 2012-present MIT License
     */
    var _default = function _default2(XRegExp2) {
      var REGEX_DATA2 = "xregexp";
      var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
      var parts = XRegExp2.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], "g", {
        conjunction: "or"
      });
      function deanchor(pattern) {
        var leadingAnchor = /^(?:\(\?:\))*\^/;
        var trailingAnchor = /\$(?:\(\?:\))*$/;
        if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped
        trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ""))) {
          return pattern.replace(leadingAnchor, "").replace(trailingAnchor, "");
        }
        return pattern;
      }
      function asXRegExp(value, addFlagX) {
        var flags2 = addFlagX ? "x" : "";
        return XRegExp2.isRegExp(value) ? value[REGEX_DATA2] && value[REGEX_DATA2].captureNames ? (
          // Don't recompile, to preserve capture names
          value
        ) : (
          // Recompile as XRegExp
          XRegExp2(value.source, flags2)
        ) : (
          // Compile string as XRegExp
          XRegExp2(value, flags2)
        );
      }
      function interpolate(substitution) {
        return substitution instanceof RegExp ? substitution : XRegExp2.escape(substitution);
      }
      function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {
        subpatterns["subpattern".concat(subpatternIndex)] = interpolated;
        return subpatterns;
      }
      function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {
        var hasSubpattern = subpatternIndex < rawLiterals.length - 1;
        return raw + (hasSubpattern ? "{{subpattern".concat(subpatternIndex, "}}") : "");
      }
      XRegExp2.tag = function(flags2) {
        return function(literals) {
          var _context, _context2;
          for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            substitutions[_key - 1] = arguments[_key];
          }
          var subpatterns = (0, _reduce["default"])(_context = (0, _map["default"])(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});
          var pattern = (0, _map["default"])(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join("");
          return XRegExp2.build(pattern, subpatterns, flags2);
        };
      };
      XRegExp2.build = function(pattern, subs, flags2) {
        flags2 = flags2 || "";
        var addFlagX = (0, _includes["default"])(flags2).call(flags2, "x");
        var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
        if (inlineFlags) {
          flags2 = XRegExp2._clipDuplicates(flags2 + inlineFlags[1]);
        }
        var data2 = {};
        for (var p in subs) {
          if (subs.hasOwnProperty(p)) {
            var sub = asXRegExp(subs[p], addFlagX);
            data2[p] = {
              // Deanchoring allows embedding independently useful anchored regexes. If you
              // really need to keep your anchors, double them (i.e., `^^...$$`).
              pattern: deanchor(sub.source),
              names: sub[REGEX_DATA2].captureNames || []
            };
          }
        }
        var patternAsRegex = asXRegExp(pattern, addFlagX);
        var numCaps = 0;
        var numPriorCaps;
        var numOuterCaps = 0;
        var outerCapsMap = [0];
        var outerCapNames = patternAsRegex[REGEX_DATA2].captureNames || [];
        var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
          var subName = $1 || $2;
          var capName;
          var intro;
          var localCapIndex;
          if (subName) {
            var _context3;
            if (!data2.hasOwnProperty(subName)) {
              throw new ReferenceError("Undefined property ".concat($0));
            }
            if ($1) {
              capName = outerCapNames[numOuterCaps];
              outerCapsMap[++numOuterCaps] = ++numCaps;
              intro = "(?<".concat(capName || subName, ">");
            } else {
              intro = "(?:";
            }
            numPriorCaps = numCaps;
            var rewrittenSubpattern = data2[subName].pattern.replace(subParts, function(match, paren, backref) {
              if (paren) {
                capName = data2[subName].names[numCaps - numPriorCaps];
                ++numCaps;
                if (capName) {
                  return "(?<".concat(capName, ">");
                }
              } else if (backref) {
                localCapIndex = +backref - 1;
                return data2[subName].names[localCapIndex] ? (
                  // Need to preserve the backreference name in case using flag `n`
                  "\\k<".concat(data2[subName].names[localCapIndex], ">")
                ) : "\\".concat(+backref + numPriorCaps);
              }
              return match;
            });
            return (0, _concat["default"])(_context3 = "".concat(intro)).call(_context3, rewrittenSubpattern, ")");
          }
          if ($3) {
            capName = outerCapNames[numOuterCaps];
            outerCapsMap[++numOuterCaps] = ++numCaps;
            if (capName) {
              return "(?<".concat(capName, ">");
            }
          } else if ($4) {
            localCapIndex = +$4 - 1;
            return outerCapNames[localCapIndex] ? (
              // Need to preserve the backreference name in case using flag `n`
              "\\k<".concat(outerCapNames[localCapIndex], ">")
            ) : "\\".concat(outerCapsMap[+$4]);
          }
          return $0;
        });
        return XRegExp2(output, flags2);
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  })(build$1, buildExports);
  return buildExports;
}
var matchrecursiveExports = {};
var matchrecursive = {
  get exports() {
    return matchrecursiveExports;
  },
  set exports(v) {
    matchrecursiveExports = v;
  }
};
var hasRequiredMatchrecursive;
function requireMatchrecursive() {
  if (hasRequiredMatchrecursive)
    return matchrecursiveExports;
  hasRequiredMatchrecursive = 1;
  (function(module, exports) {
    var _interopRequireDefault = interopRequireDefaultExports;
    var _Object$defineProperty = definePropertyExports$1;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _slice = _interopRequireDefault(requireSlice());
    var _concat = _interopRequireDefault(requireConcat());
    var _includes = _interopRequireDefault(requireIncludes());
    /*!
     * XRegExp.matchRecursive 4.4.1
     * <xregexp.com>
     * Steven Levithan (c) 2009-present MIT License
     */
    var _default = function _default2(XRegExp2) {
      function row(name, value, start, end) {
        return {
          name,
          value,
          start,
          end
        };
      }
      XRegExp2.matchRecursive = function(str, left, right, flags2, options) {
        flags2 = flags2 || "";
        options = options || {};
        var global2 = (0, _includes["default"])(flags2).call(flags2, "g");
        var sticky = (0, _includes["default"])(flags2).call(flags2, "y");
        var basicFlags = flags2.replace(/y/g, "");
        var _options = options, escapeChar = _options.escapeChar;
        var vN = options.valueNames;
        var output = [];
        var openTokens = 0;
        var delimStart = 0;
        var delimEnd = 0;
        var lastOuterEnd = 0;
        var outerStart;
        var innerStart;
        var leftMatch;
        var rightMatch;
        var esc;
        left = XRegExp2(left, basicFlags);
        right = XRegExp2(right, basicFlags);
        if (escapeChar) {
          var _context, _context2;
          if (escapeChar.length > 1) {
            throw new Error("Cannot use more than one escape character");
          }
          escapeChar = XRegExp2.escape(escapeChar);
          esc = new RegExp(
            (0, _concat["default"])(_context = (0, _concat["default"])(_context2 = "(?:".concat(escapeChar, "[\\S\\s]|(?:(?!")).call(
              _context2,
              // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
              // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
              // transformation resulting from those flags was already applied to `left` and
              // `right` when they were passed through the XRegExp constructor above.
              XRegExp2.union([left, right], "", {
                conjunction: "or"
              }).source,
              ")[^"
            )).call(_context, escapeChar, "])+)+"),
            // Flags `gy` not needed here
            flags2.replace(/[^imu]+/g, "")
          );
        }
        while (true) {
          if (escapeChar) {
            delimEnd += (XRegExp2.exec(str, esc, delimEnd, "sticky") || [""])[0].length;
          }
          leftMatch = XRegExp2.exec(str, left, delimEnd);
          rightMatch = XRegExp2.exec(str, right, delimEnd);
          if (leftMatch && rightMatch) {
            if (leftMatch.index <= rightMatch.index) {
              rightMatch = null;
            } else {
              leftMatch = null;
            }
          }
          if (leftMatch || rightMatch) {
            delimStart = (leftMatch || rightMatch).index;
            delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
          } else if (!openTokens) {
            break;
          }
          if (sticky && !openTokens && delimStart > lastOuterEnd) {
            break;
          }
          if (leftMatch) {
            if (!openTokens) {
              outerStart = delimStart;
              innerStart = delimEnd;
            }
            ++openTokens;
          } else if (rightMatch && openTokens) {
            if (!--openTokens) {
              if (vN) {
                if (vN[0] && outerStart > lastOuterEnd) {
                  output.push(row(vN[0], (0, _slice["default"])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                }
                if (vN[1]) {
                  output.push(row(vN[1], (0, _slice["default"])(str).call(str, outerStart, innerStart), outerStart, innerStart));
                }
                if (vN[2]) {
                  output.push(row(vN[2], (0, _slice["default"])(str).call(str, innerStart, delimStart), innerStart, delimStart));
                }
                if (vN[3]) {
                  output.push(row(vN[3], (0, _slice["default"])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));
                }
              } else {
                output.push((0, _slice["default"])(str).call(str, innerStart, delimStart));
              }
              lastOuterEnd = delimEnd;
              if (!global2) {
                break;
              }
            }
          } else {
            throw new Error("Unbalanced delimiter found in string");
          }
          if (delimStart === delimEnd) {
            ++delimEnd;
          }
        }
        if (global2 && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
          output.push(row(vN[0], (0, _slice["default"])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));
        }
        return output;
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  })(matchrecursive, matchrecursiveExports);
  return matchrecursiveExports;
}
var unicodeBaseExports = {};
var unicodeBase$1 = {
  get exports() {
    return unicodeBaseExports;
  },
  set exports(v) {
    unicodeBaseExports = v;
  }
};
var hasRequiredUnicodeBase;
function requireUnicodeBase() {
  if (hasRequiredUnicodeBase)
    return unicodeBaseExports;
  hasRequiredUnicodeBase = 1;
  (function(module, exports) {
    var _interopRequireDefault = interopRequireDefaultExports;
    var _Object$defineProperty = definePropertyExports$1;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _getIterator2 = _interopRequireDefault(requireGetIterator());
    var _isArray = _interopRequireDefault(requireIsArray$4());
    var _getIteratorMethod2 = _interopRequireDefault(requireGetIteratorMethod());
    var _symbol = _interopRequireDefault(requireSymbol$4());
    var _from = _interopRequireDefault(requireFrom$4());
    var _slice = _interopRequireDefault(requireSlice());
    var _includes = _interopRequireDefault(requireIncludes());
    var _concat = _interopRequireDefault(requireConcat());
    var _forEach = _interopRequireDefault(requireForEach());
    function _createForOfIteratorHelper2(o, allowArrayLike) {
      var it;
      if (typeof _symbol["default"] === "undefined" || (0, _getIteratorMethod2["default"])(o) == null) {
        if ((0, _isArray["default"])(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return {
            s: F,
            n: function n() {
              if (i >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function e(_e) {
              throw _e;
            },
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = (0, _getIterator2["default"])(o);
        },
        n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e2) {
          didErr = true;
          err = _e2;
        },
        f: function f() {
          try {
            if (!normalCompletion && it["return"] != null)
              it["return"]();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray2(o, minLen) {
      var _context4;
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray2(o, minLen);
      var n = (0, _slice["default"])(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return (0, _from["default"])(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray2(o, minLen);
    }
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    /*!
     * XRegExp Unicode Base 4.4.1
     * <xregexp.com>
     * Steven Levithan (c) 2008-present MIT License
     */
    var _default = function _default2(XRegExp2) {
      var unicode = {};
      var dec2 = XRegExp2._dec;
      var hex2 = XRegExp2._hex;
      var pad42 = XRegExp2._pad4;
      function normalize2(name) {
        return name.replace(/[- _]+/g, "").toLowerCase();
      }
      function charCode(chr) {
        var esc = /^\\[xu](.+)/.exec(chr);
        return esc ? dec2(esc[1]) : chr.charCodeAt(chr[0] === "\\" ? 1 : 0);
      }
      function invertBmp(range) {
        var output = "";
        var lastEnd = -1;
        (0, _forEach["default"])(XRegExp2).call(XRegExp2, range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function(m) {
          var start = charCode(m[1]);
          if (start > lastEnd + 1) {
            output += "\\u".concat(pad42(hex2(lastEnd + 1)));
            if (start > lastEnd + 2) {
              output += "-\\u".concat(pad42(hex2(start - 1)));
            }
          }
          lastEnd = charCode(m[2] || m[1]);
        });
        if (lastEnd < 65535) {
          output += "\\u".concat(pad42(hex2(lastEnd + 1)));
          if (lastEnd < 65534) {
            output += "-\\uFFFF";
          }
        }
        return output;
      }
      function cacheInvertedBmp(slug) {
        var prop = "b!";
        return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));
      }
      function buildAstral(slug, isNegated) {
        var item = unicode[slug];
        var combined = "";
        if (item.bmp && !item.isBmpLast) {
          var _context;
          combined = (0, _concat["default"])(_context = "[".concat(item.bmp, "]")).call(_context, item.astral ? "|" : "");
        }
        if (item.astral) {
          combined += item.astral;
        }
        if (item.isBmpLast && item.bmp) {
          var _context2;
          combined += (0, _concat["default"])(_context2 = "".concat(item.astral ? "|" : "", "[")).call(_context2, item.bmp, "]");
        }
        return isNegated ? "(?:(?!".concat(combined, ")(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-￿]))") : "(?:".concat(combined, ")");
      }
      function cacheAstral(slug, isNegated) {
        var prop = isNegated ? "a!" : "a=";
        return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));
      }
      XRegExp2.addToken(
        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
        /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
        function(match, scope, flags2) {
          var ERR_DOUBLE_NEG = "Invalid double negation ";
          var ERR_UNKNOWN_NAME = "Unknown Unicode token ";
          var ERR_UNKNOWN_REF = "Unicode token missing data ";
          var ERR_ASTRAL_ONLY = "Astral mode required for Unicode token ";
          var ERR_ASTRAL_IN_CLASS = "Astral mode does not support Unicode tokens within character classes";
          var isNegated = match[1] === "P" || !!match[2];
          var isAstralMode = (0, _includes["default"])(flags2).call(flags2, "A");
          var slug = normalize2(match[4] || match[3]);
          var item = unicode[slug];
          if (match[1] === "P" && match[2]) {
            throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
          }
          if (!unicode.hasOwnProperty(slug)) {
            throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
          }
          if (item.inverseOf) {
            slug = normalize2(item.inverseOf);
            if (!unicode.hasOwnProperty(slug)) {
              var _context3;
              throw new ReferenceError((0, _concat["default"])(_context3 = "".concat(ERR_UNKNOWN_REF + match[0], " -> ")).call(_context3, item.inverseOf));
            }
            item = unicode[slug];
            isNegated = !isNegated;
          }
          if (!(item.bmp || isAstralMode)) {
            throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
          }
          if (isAstralMode) {
            if (scope === "class") {
              throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
            }
            return cacheAstral(slug, isNegated);
          }
          return scope === "class" ? isNegated ? cacheInvertedBmp(slug) : item.bmp : "".concat((isNegated ? "[^" : "[") + item.bmp, "]");
        },
        {
          scope: "all",
          optionalFlags: "A",
          leadChar: "\\"
        }
      );
      XRegExp2.addUnicodeData = function(data2) {
        var ERR_NO_NAME = "Unicode token requires name";
        var ERR_NO_DATA = "Unicode token has no character data ";
        var _iterator = _createForOfIteratorHelper2(data2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var item = _step.value;
            if (!item.name) {
              throw new Error(ERR_NO_NAME);
            }
            if (!(item.inverseOf || item.bmp || item.astral)) {
              throw new Error(ERR_NO_DATA + item.name);
            }
            unicode[normalize2(item.name)] = item;
            if (item.alias) {
              unicode[normalize2(item.alias)] = item;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        XRegExp2.cache.flush("patterns");
      };
      XRegExp2._getUnicodeProperty = function(name) {
        var slug = normalize2(name);
        return unicode[slug];
      };
    };
    exports["default"] = _default;
    module.exports = exports.default;
  })(unicodeBase$1, unicodeBaseExports);
  return unicodeBaseExports;
}
var unicodeBlocksExports = {};
var unicodeBlocks = {
  get exports() {
    return unicodeBlocksExports;
  },
  set exports(v) {
    unicodeBlocksExports = v;
  }
};
var blocks;
var hasRequiredBlocks;
function requireBlocks() {
  if (hasRequiredBlocks)
    return blocks;
  hasRequiredBlocks = 1;
  blocks = [{
    "name": "InAdlam",
    "astral": "\uD83A[\uDD00-\uDD5F]"
  }, {
    "name": "InAegean_Numbers",
    "astral": "\uD800[\uDD00-\uDD3F]"
  }, {
    "name": "InAhom",
    "astral": "\uD805[\uDF00-\uDF3F]"
  }, {
    "name": "InAlchemical_Symbols",
    "astral": "\uD83D[\uDF00-\uDF7F]"
  }, {
    "name": "InAlphabetic_Presentation_Forms",
    "bmp": "ﬀ-ﭏ"
  }, {
    "name": "InAnatolian_Hieroglyphs",
    "astral": "\uD811[\uDC00-\uDE7F]"
  }, {
    "name": "InAncient_Greek_Musical_Notation",
    "astral": "\uD834[\uDE00-\uDE4F]"
  }, {
    "name": "InAncient_Greek_Numbers",
    "astral": "\uD800[\uDD40-\uDD8F]"
  }, {
    "name": "InAncient_Symbols",
    "astral": "\uD800[\uDD90-\uDDCF]"
  }, {
    "name": "InArabic",
    "bmp": "؀-ۿ"
  }, {
    "name": "InArabic_Extended_A",
    "bmp": "ࢠ-ࣿ"
  }, {
    "name": "InArabic_Mathematical_Alphabetic_Symbols",
    "astral": "\uD83B[\uDE00-\uDEFF]"
  }, {
    "name": "InArabic_Presentation_Forms_A",
    "bmp": "ﭐ-﷿"
  }, {
    "name": "InArabic_Presentation_Forms_B",
    "bmp": "ﹰ-\uFEFF"
  }, {
    "name": "InArabic_Supplement",
    "bmp": "ݐ-ݿ"
  }, {
    "name": "InArmenian",
    "bmp": "԰-֏"
  }, {
    "name": "InArrows",
    "bmp": "←-⇿"
  }, {
    "name": "InAvestan",
    "astral": "\uD802[\uDF00-\uDF3F]"
  }, {
    "name": "InBalinese",
    "bmp": "ᬀ-᭿"
  }, {
    "name": "InBamum",
    "bmp": "ꚠ-꛿"
  }, {
    "name": "InBamum_Supplement",
    "astral": "\uD81A[\uDC00-\uDE3F]"
  }, {
    "name": "InBasic_Latin",
    "bmp": "\0-"
  }, {
    "name": "InBassa_Vah",
    "astral": "\uD81A[\uDED0-\uDEFF]"
  }, {
    "name": "InBatak",
    "bmp": "ᯀ-᯿"
  }, {
    "name": "InBengali",
    "bmp": "ঀ-৿"
  }, {
    "name": "InBhaiksuki",
    "astral": "\uD807[\uDC00-\uDC6F]"
  }, {
    "name": "InBlock_Elements",
    "bmp": "▀-▟"
  }, {
    "name": "InBopomofo",
    "bmp": "㄀-ㄯ"
  }, {
    "name": "InBopomofo_Extended",
    "bmp": "ㆠ-ㆿ"
  }, {
    "name": "InBox_Drawing",
    "bmp": "─-╿"
  }, {
    "name": "InBrahmi",
    "astral": "\uD804[\uDC00-\uDC7F]"
  }, {
    "name": "InBraille_Patterns",
    "bmp": "⠀-⣿"
  }, {
    "name": "InBuginese",
    "bmp": "ᨀ-᨟"
  }, {
    "name": "InBuhid",
    "bmp": "ᝀ-᝟"
  }, {
    "name": "InByzantine_Musical_Symbols",
    "astral": "\uD834[\uDC00-\uDCFF]"
  }, {
    "name": "InCJK_Compatibility",
    "bmp": "㌀-㏿"
  }, {
    "name": "InCJK_Compatibility_Forms",
    "bmp": "︰-﹏"
  }, {
    "name": "InCJK_Compatibility_Ideographs",
    "bmp": "豈-﫿"
  }, {
    "name": "InCJK_Compatibility_Ideographs_Supplement",
    "astral": "\uD87E[\uDC00-\uDE1F]"
  }, {
    "name": "InCJK_Radicals_Supplement",
    "bmp": "⺀-⻿"
  }, {
    "name": "InCJK_Strokes",
    "bmp": "㇀-㇯"
  }, {
    "name": "InCJK_Symbols_And_Punctuation",
    "bmp": "　-〿"
  }, {
    "name": "InCJK_Unified_Ideographs",
    "bmp": "一-鿿"
  }, {
    "name": "InCJK_Unified_Ideographs_Extension_A",
    "bmp": "㐀-䶿"
  }, {
    "name": "InCJK_Unified_Ideographs_Extension_B",
    "astral": "[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]"
  }, {
    "name": "InCJK_Unified_Ideographs_Extension_C",
    "astral": "\uD869[\uDF00-\uDFFF]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF3F]"
  }, {
    "name": "InCJK_Unified_Ideographs_Extension_D",
    "astral": "\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]"
  }, {
    "name": "InCJK_Unified_Ideographs_Extension_E",
    "astral": "\uD86E[\uDC20-\uDFFF]|[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]"
  }, {
    "name": "InCJK_Unified_Ideographs_Extension_F",
    "astral": "\uD873[\uDEB0-\uDFFF]|[\uD874-\uD879][\uDC00-\uDFFF]|\uD87A[\uDC00-\uDFEF]"
  }, {
    "name": "InCarian",
    "astral": "\uD800[\uDEA0-\uDEDF]"
  }, {
    "name": "InCaucasian_Albanian",
    "astral": "\uD801[\uDD30-\uDD6F]"
  }, {
    "name": "InChakma",
    "astral": "\uD804[\uDD00-\uDD4F]"
  }, {
    "name": "InCham",
    "bmp": "ꨀ-꩟"
  }, {
    "name": "InCherokee",
    "bmp": "Ꭰ-᏿"
  }, {
    "name": "InCherokee_Supplement",
    "bmp": "ꭰ-ꮿ"
  }, {
    "name": "InChess_Symbols",
    "astral": "\uD83E[\uDE00-\uDE6F]"
  }, {
    "name": "InCombining_Diacritical_Marks",
    "bmp": "̀-ͯ"
  }, {
    "name": "InCombining_Diacritical_Marks_Extended",
    "bmp": "᪰-᫿"
  }, {
    "name": "InCombining_Diacritical_Marks_For_Symbols",
    "bmp": "⃐-⃿"
  }, {
    "name": "InCombining_Diacritical_Marks_Supplement",
    "bmp": "᷀-᷿"
  }, {
    "name": "InCombining_Half_Marks",
    "bmp": "︠-︯"
  }, {
    "name": "InCommon_Indic_Number_Forms",
    "bmp": "꠰-꠿"
  }, {
    "name": "InControl_Pictures",
    "bmp": "␀-␿"
  }, {
    "name": "InCoptic",
    "bmp": "Ⲁ-⳿"
  }, {
    "name": "InCoptic_Epact_Numbers",
    "astral": "\uD800[\uDEE0-\uDEFF]"
  }, {
    "name": "InCounting_Rod_Numerals",
    "astral": "\uD834[\uDF60-\uDF7F]"
  }, {
    "name": "InCuneiform",
    "astral": "\uD808[\uDC00-\uDFFF]"
  }, {
    "name": "InCuneiform_Numbers_And_Punctuation",
    "astral": "\uD809[\uDC00-\uDC7F]"
  }, {
    "name": "InCurrency_Symbols",
    "bmp": "₠-⃏"
  }, {
    "name": "InCypriot_Syllabary",
    "astral": "\uD802[\uDC00-\uDC3F]"
  }, {
    "name": "InCyrillic",
    "bmp": "Ѐ-ӿ"
  }, {
    "name": "InCyrillic_Extended_A",
    "bmp": "ⷠ-ⷿ"
  }, {
    "name": "InCyrillic_Extended_B",
    "bmp": "Ꙁ-ꚟ"
  }, {
    "name": "InCyrillic_Extended_C",
    "bmp": "ᲀ-᲏"
  }, {
    "name": "InCyrillic_Supplement",
    "bmp": "Ԁ-ԯ"
  }, {
    "name": "InDeseret",
    "astral": "\uD801[\uDC00-\uDC4F]"
  }, {
    "name": "InDevanagari",
    "bmp": "ऀ-ॿ"
  }, {
    "name": "InDevanagari_Extended",
    "bmp": "꣠-ꣿ"
  }, {
    "name": "InDingbats",
    "bmp": "✀-➿"
  }, {
    "name": "InDogra",
    "astral": "\uD806[\uDC00-\uDC4F]"
  }, {
    "name": "InDomino_Tiles",
    "astral": "\uD83C[\uDC30-\uDC9F]"
  }, {
    "name": "InDuployan",
    "astral": "\uD82F[\uDC00-\uDC9F]"
  }, {
    "name": "InEarly_Dynastic_Cuneiform",
    "astral": "\uD809[\uDC80-\uDD4F]"
  }, {
    "name": "InEgyptian_Hieroglyphs",
    "astral": "\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]"
  }, {
    "name": "InElbasan",
    "astral": "\uD801[\uDD00-\uDD2F]"
  }, {
    "name": "InEmoticons",
    "astral": "\uD83D[\uDE00-\uDE4F]"
  }, {
    "name": "InEnclosed_Alphanumeric_Supplement",
    "astral": "\uD83C[\uDD00-\uDDFF]"
  }, {
    "name": "InEnclosed_Alphanumerics",
    "bmp": "①-⓿"
  }, {
    "name": "InEnclosed_CJK_Letters_And_Months",
    "bmp": "㈀-㋿"
  }, {
    "name": "InEnclosed_Ideographic_Supplement",
    "astral": "\uD83C[\uDE00-\uDEFF]"
  }, {
    "name": "InEthiopic",
    "bmp": "ሀ-፿"
  }, {
    "name": "InEthiopic_Extended",
    "bmp": "ⶀ-⷟"
  }, {
    "name": "InEthiopic_Extended_A",
    "bmp": "꬀-꬯"
  }, {
    "name": "InEthiopic_Supplement",
    "bmp": "ᎀ-᎟"
  }, {
    "name": "InGeneral_Punctuation",
    "bmp": " -⁯"
  }, {
    "name": "InGeometric_Shapes",
    "bmp": "■-◿"
  }, {
    "name": "InGeometric_Shapes_Extended",
    "astral": "\uD83D[\uDF80-\uDFFF]"
  }, {
    "name": "InGeorgian",
    "bmp": "Ⴀ-ჿ"
  }, {
    "name": "InGeorgian_Extended",
    "bmp": "Ა-Ჿ"
  }, {
    "name": "InGeorgian_Supplement",
    "bmp": "ⴀ-⴯"
  }, {
    "name": "InGlagolitic",
    "bmp": "Ⰰ-ⱟ"
  }, {
    "name": "InGlagolitic_Supplement",
    "astral": "\uD838[\uDC00-\uDC2F]"
  }, {
    "name": "InGothic",
    "astral": "\uD800[\uDF30-\uDF4F]"
  }, {
    "name": "InGrantha",
    "astral": "\uD804[\uDF00-\uDF7F]"
  }, {
    "name": "InGreek_And_Coptic",
    "bmp": "Ͱ-Ͽ"
  }, {
    "name": "InGreek_Extended",
    "bmp": "ἀ-῿"
  }, {
    "name": "InGujarati",
    "bmp": "઀-૿"
  }, {
    "name": "InGunjala_Gondi",
    "astral": "\uD807[\uDD60-\uDDAF]"
  }, {
    "name": "InGurmukhi",
    "bmp": "਀-੿"
  }, {
    "name": "InHalfwidth_And_Fullwidth_Forms",
    "bmp": "＀-￯"
  }, {
    "name": "InHangul_Compatibility_Jamo",
    "bmp": "㄰-㆏"
  }, {
    "name": "InHangul_Jamo",
    "bmp": "ᄀ-ᇿ"
  }, {
    "name": "InHangul_Jamo_Extended_A",
    "bmp": "ꥠ-꥿"
  }, {
    "name": "InHangul_Jamo_Extended_B",
    "bmp": "ힰ-퟿"
  }, {
    "name": "InHangul_Syllables",
    "bmp": "가-힯"
  }, {
    "name": "InHanifi_Rohingya",
    "astral": "\uD803[\uDD00-\uDD3F]"
  }, {
    "name": "InHanunoo",
    "bmp": "ᜠ-᜿"
  }, {
    "name": "InHatran",
    "astral": "\uD802[\uDCE0-\uDCFF]"
  }, {
    "name": "InHebrew",
    "bmp": "֐-׿"
  }, {
    "name": "InHigh_Private_Use_Surrogates",
    "bmp": "\uDB80-\uDBFF"
  }, {
    "name": "InHigh_Surrogates",
    "bmp": "\uD800-\uDB7F"
  }, {
    "name": "InHiragana",
    "bmp": "぀-ゟ"
  }, {
    "name": "InIPA_Extensions",
    "bmp": "ɐ-ʯ"
  }, {
    "name": "InIdeographic_Description_Characters",
    "bmp": "⿰-⿿"
  }, {
    "name": "InIdeographic_Symbols_And_Punctuation",
    "astral": "\uD81B[\uDFE0-\uDFFF]"
  }, {
    "name": "InImperial_Aramaic",
    "astral": "\uD802[\uDC40-\uDC5F]"
  }, {
    "name": "InIndic_Siyaq_Numbers",
    "astral": "\uD83B[\uDC70-\uDCBF]"
  }, {
    "name": "InInscriptional_Pahlavi",
    "astral": "\uD802[\uDF60-\uDF7F]"
  }, {
    "name": "InInscriptional_Parthian",
    "astral": "\uD802[\uDF40-\uDF5F]"
  }, {
    "name": "InJavanese",
    "bmp": "ꦀ-꧟"
  }, {
    "name": "InKaithi",
    "astral": "\uD804[\uDC80-\uDCCF]"
  }, {
    "name": "InKana_Extended_A",
    "astral": "\uD82C[\uDD00-\uDD2F]"
  }, {
    "name": "InKana_Supplement",
    "astral": "\uD82C[\uDC00-\uDCFF]"
  }, {
    "name": "InKanbun",
    "bmp": "㆐-㆟"
  }, {
    "name": "InKangxi_Radicals",
    "bmp": "⼀-⿟"
  }, {
    "name": "InKannada",
    "bmp": "ಀ-೿"
  }, {
    "name": "InKatakana",
    "bmp": "゠-ヿ"
  }, {
    "name": "InKatakana_Phonetic_Extensions",
    "bmp": "ㇰ-ㇿ"
  }, {
    "name": "InKayah_Li",
    "bmp": "꤀-꤯"
  }, {
    "name": "InKharoshthi",
    "astral": "\uD802[\uDE00-\uDE5F]"
  }, {
    "name": "InKhmer",
    "bmp": "ក-៿"
  }, {
    "name": "InKhmer_Symbols",
    "bmp": "᧠-᧿"
  }, {
    "name": "InKhojki",
    "astral": "\uD804[\uDE00-\uDE4F]"
  }, {
    "name": "InKhudawadi",
    "astral": "\uD804[\uDEB0-\uDEFF]"
  }, {
    "name": "InLao",
    "bmp": "຀-໿"
  }, {
    "name": "InLatin_1_Supplement",
    "bmp": "-ÿ"
  }, {
    "name": "InLatin_Extended_A",
    "bmp": "Ā-ſ"
  }, {
    "name": "InLatin_Extended_Additional",
    "bmp": "Ḁ-ỿ"
  }, {
    "name": "InLatin_Extended_B",
    "bmp": "ƀ-ɏ"
  }, {
    "name": "InLatin_Extended_C",
    "bmp": "Ⱡ-Ɀ"
  }, {
    "name": "InLatin_Extended_D",
    "bmp": "꜠-ꟿ"
  }, {
    "name": "InLatin_Extended_E",
    "bmp": "ꬰ-꭯"
  }, {
    "name": "InLepcha",
    "bmp": "ᰀ-ᱏ"
  }, {
    "name": "InLetterlike_Symbols",
    "bmp": "℀-⅏"
  }, {
    "name": "InLimbu",
    "bmp": "ᤀ-᥏"
  }, {
    "name": "InLinear_A",
    "astral": "\uD801[\uDE00-\uDF7F]"
  }, {
    "name": "InLinear_B_Ideograms",
    "astral": "\uD800[\uDC80-\uDCFF]"
  }, {
    "name": "InLinear_B_Syllabary",
    "astral": "\uD800[\uDC00-\uDC7F]"
  }, {
    "name": "InLisu",
    "bmp": "ꓐ-꓿"
  }, {
    "name": "InLow_Surrogates",
    "bmp": "\uDC00-\uDFFF"
  }, {
    "name": "InLycian",
    "astral": "\uD800[\uDE80-\uDE9F]"
  }, {
    "name": "InLydian",
    "astral": "\uD802[\uDD20-\uDD3F]"
  }, {
    "name": "InMahajani",
    "astral": "\uD804[\uDD50-\uDD7F]"
  }, {
    "name": "InMahjong_Tiles",
    "astral": "\uD83C[\uDC00-\uDC2F]"
  }, {
    "name": "InMakasar",
    "astral": "\uD807[\uDEE0-\uDEFF]"
  }, {
    "name": "InMalayalam",
    "bmp": "ഀ-ൿ"
  }, {
    "name": "InMandaic",
    "bmp": "ࡀ-࡟"
  }, {
    "name": "InManichaean",
    "astral": "\uD802[\uDEC0-\uDEFF]"
  }, {
    "name": "InMarchen",
    "astral": "\uD807[\uDC70-\uDCBF]"
  }, {
    "name": "InMasaram_Gondi",
    "astral": "\uD807[\uDD00-\uDD5F]"
  }, {
    "name": "InMathematical_Alphanumeric_Symbols",
    "astral": "\uD835[\uDC00-\uDFFF]"
  }, {
    "name": "InMathematical_Operators",
    "bmp": "∀-⋿"
  }, {
    "name": "InMayan_Numerals",
    "astral": "\uD834[\uDEE0-\uDEFF]"
  }, {
    "name": "InMedefaidrin",
    "astral": "\uD81B[\uDE40-\uDE9F]"
  }, {
    "name": "InMeetei_Mayek",
    "bmp": "ꯀ-꯿"
  }, {
    "name": "InMeetei_Mayek_Extensions",
    "bmp": "ꫠ-꫿"
  }, {
    "name": "InMende_Kikakui",
    "astral": "\uD83A[\uDC00-\uDCDF]"
  }, {
    "name": "InMeroitic_Cursive",
    "astral": "\uD802[\uDDA0-\uDDFF]"
  }, {
    "name": "InMeroitic_Hieroglyphs",
    "astral": "\uD802[\uDD80-\uDD9F]"
  }, {
    "name": "InMiao",
    "astral": "\uD81B[\uDF00-\uDF9F]"
  }, {
    "name": "InMiscellaneous_Mathematical_Symbols_A",
    "bmp": "⟀-⟯"
  }, {
    "name": "InMiscellaneous_Mathematical_Symbols_B",
    "bmp": "⦀-⧿"
  }, {
    "name": "InMiscellaneous_Symbols",
    "bmp": "☀-⛿"
  }, {
    "name": "InMiscellaneous_Symbols_And_Arrows",
    "bmp": "⬀-⯿"
  }, {
    "name": "InMiscellaneous_Symbols_And_Pictographs",
    "astral": "\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF]"
  }, {
    "name": "InMiscellaneous_Technical",
    "bmp": "⌀-⏿"
  }, {
    "name": "InModi",
    "astral": "\uD805[\uDE00-\uDE5F]"
  }, {
    "name": "InModifier_Tone_Letters",
    "bmp": "꜀-ꜟ"
  }, {
    "name": "InMongolian",
    "bmp": "᠀-᢯"
  }, {
    "name": "InMongolian_Supplement",
    "astral": "\uD805[\uDE60-\uDE7F]"
  }, {
    "name": "InMro",
    "astral": "\uD81A[\uDE40-\uDE6F]"
  }, {
    "name": "InMultani",
    "astral": "\uD804[\uDE80-\uDEAF]"
  }, {
    "name": "InMusical_Symbols",
    "astral": "\uD834[\uDD00-\uDDFF]"
  }, {
    "name": "InMyanmar",
    "bmp": "က-႟"
  }, {
    "name": "InMyanmar_Extended_A",
    "bmp": "ꩠ-ꩿ"
  }, {
    "name": "InMyanmar_Extended_B",
    "bmp": "ꧠ-꧿"
  }, {
    "name": "InNKo",
    "bmp": "߀-߿"
  }, {
    "name": "InNabataean",
    "astral": "\uD802[\uDC80-\uDCAF]"
  }, {
    "name": "InNew_Tai_Lue",
    "bmp": "ᦀ-᧟"
  }, {
    "name": "InNewa",
    "astral": "\uD805[\uDC00-\uDC7F]"
  }, {
    "name": "InNumber_Forms",
    "bmp": "⅐-↏"
  }, {
    "name": "InNushu",
    "astral": "\uD82C[\uDD70-\uDEFF]"
  }, {
    "name": "InOgham",
    "bmp": " -᚟"
  }, {
    "name": "InOl_Chiki",
    "bmp": "᱐-᱿"
  }, {
    "name": "InOld_Hungarian",
    "astral": "\uD803[\uDC80-\uDCFF]"
  }, {
    "name": "InOld_Italic",
    "astral": "\uD800[\uDF00-\uDF2F]"
  }, {
    "name": "InOld_North_Arabian",
    "astral": "\uD802[\uDE80-\uDE9F]"
  }, {
    "name": "InOld_Permic",
    "astral": "\uD800[\uDF50-\uDF7F]"
  }, {
    "name": "InOld_Persian",
    "astral": "\uD800[\uDFA0-\uDFDF]"
  }, {
    "name": "InOld_Sogdian",
    "astral": "\uD803[\uDF00-\uDF2F]"
  }, {
    "name": "InOld_South_Arabian",
    "astral": "\uD802[\uDE60-\uDE7F]"
  }, {
    "name": "InOld_Turkic",
    "astral": "\uD803[\uDC00-\uDC4F]"
  }, {
    "name": "InOptical_Character_Recognition",
    "bmp": "⑀-⑟"
  }, {
    "name": "InOriya",
    "bmp": "଀-୿"
  }, {
    "name": "InOrnamental_Dingbats",
    "astral": "\uD83D[\uDE50-\uDE7F]"
  }, {
    "name": "InOsage",
    "astral": "\uD801[\uDCB0-\uDCFF]"
  }, {
    "name": "InOsmanya",
    "astral": "\uD801[\uDC80-\uDCAF]"
  }, {
    "name": "InPahawh_Hmong",
    "astral": "\uD81A[\uDF00-\uDF8F]"
  }, {
    "name": "InPalmyrene",
    "astral": "\uD802[\uDC60-\uDC7F]"
  }, {
    "name": "InPau_Cin_Hau",
    "astral": "\uD806[\uDEC0-\uDEFF]"
  }, {
    "name": "InPhags_Pa",
    "bmp": "ꡀ-꡿"
  }, {
    "name": "InPhaistos_Disc",
    "astral": "\uD800[\uDDD0-\uDDFF]"
  }, {
    "name": "InPhoenician",
    "astral": "\uD802[\uDD00-\uDD1F]"
  }, {
    "name": "InPhonetic_Extensions",
    "bmp": "ᴀ-ᵿ"
  }, {
    "name": "InPhonetic_Extensions_Supplement",
    "bmp": "ᶀ-ᶿ"
  }, {
    "name": "InPlaying_Cards",
    "astral": "\uD83C[\uDCA0-\uDCFF]"
  }, {
    "name": "InPrivate_Use_Area",
    "bmp": "-"
  }, {
    "name": "InPsalter_Pahlavi",
    "astral": "\uD802[\uDF80-\uDFAF]"
  }, {
    "name": "InRejang",
    "bmp": "ꤰ-꥟"
  }, {
    "name": "InRumi_Numeral_Symbols",
    "astral": "\uD803[\uDE60-\uDE7F]"
  }, {
    "name": "InRunic",
    "bmp": "ᚠ-᛿"
  }, {
    "name": "InSamaritan",
    "bmp": "ࠀ-࠿"
  }, {
    "name": "InSaurashtra",
    "bmp": "ꢀ-꣟"
  }, {
    "name": "InSharada",
    "astral": "\uD804[\uDD80-\uDDDF]"
  }, {
    "name": "InShavian",
    "astral": "\uD801[\uDC50-\uDC7F]"
  }, {
    "name": "InShorthand_Format_Controls",
    "astral": "\uD82F[\uDCA0-\uDCAF]"
  }, {
    "name": "InSiddham",
    "astral": "\uD805[\uDD80-\uDDFF]"
  }, {
    "name": "InSinhala",
    "bmp": "඀-෿"
  }, {
    "name": "InSinhala_Archaic_Numbers",
    "astral": "\uD804[\uDDE0-\uDDFF]"
  }, {
    "name": "InSmall_Form_Variants",
    "bmp": "﹐-﹯"
  }, {
    "name": "InSogdian",
    "astral": "\uD803[\uDF30-\uDF6F]"
  }, {
    "name": "InSora_Sompeng",
    "astral": "\uD804[\uDCD0-\uDCFF]"
  }, {
    "name": "InSoyombo",
    "astral": "\uD806[\uDE50-\uDEAF]"
  }, {
    "name": "InSpacing_Modifier_Letters",
    "bmp": "ʰ-˿"
  }, {
    "name": "InSpecials",
    "bmp": "￰-￿"
  }, {
    "name": "InSundanese",
    "bmp": "ᮀ-ᮿ"
  }, {
    "name": "InSundanese_Supplement",
    "bmp": "᳀-᳏"
  }, {
    "name": "InSuperscripts_And_Subscripts",
    "bmp": "⁰-₟"
  }, {
    "name": "InSupplemental_Arrows_A",
    "bmp": "⟰-⟿"
  }, {
    "name": "InSupplemental_Arrows_B",
    "bmp": "⤀-⥿"
  }, {
    "name": "InSupplemental_Arrows_C",
    "astral": "\uD83E[\uDC00-\uDCFF]"
  }, {
    "name": "InSupplemental_Mathematical_Operators",
    "bmp": "⨀-⫿"
  }, {
    "name": "InSupplemental_Punctuation",
    "bmp": "⸀-⹿"
  }, {
    "name": "InSupplemental_Symbols_And_Pictographs",
    "astral": "\uD83E[\uDD00-\uDDFF]"
  }, {
    "name": "InSupplementary_Private_Use_Area_A",
    "astral": "[\uDB80-\uDBBF][\uDC00-\uDFFF]"
  }, {
    "name": "InSupplementary_Private_Use_Area_B",
    "astral": "[\uDBC0-\uDBFF][\uDC00-\uDFFF]"
  }, {
    "name": "InSutton_SignWriting",
    "astral": "\uD836[\uDC00-\uDEAF]"
  }, {
    "name": "InSyloti_Nagri",
    "bmp": "ꠀ-꠯"
  }, {
    "name": "InSyriac",
    "bmp": "܀-ݏ"
  }, {
    "name": "InSyriac_Supplement",
    "bmp": "ࡠ-࡯"
  }, {
    "name": "InTagalog",
    "bmp": "ᜀ-ᜟ"
  }, {
    "name": "InTagbanwa",
    "bmp": "ᝠ-᝿"
  }, {
    "name": "InTags",
    "astral": "\uDB40[\uDC00-\uDC7F]"
  }, {
    "name": "InTai_Le",
    "bmp": "ᥐ-᥿"
  }, {
    "name": "InTai_Tham",
    "bmp": "ᨠ-᪯"
  }, {
    "name": "InTai_Viet",
    "bmp": "ꪀ-꫟"
  }, {
    "name": "InTai_Xuan_Jing_Symbols",
    "astral": "\uD834[\uDF00-\uDF5F]"
  }, {
    "name": "InTakri",
    "astral": "\uD805[\uDE80-\uDECF]"
  }, {
    "name": "InTamil",
    "bmp": "஀-௿"
  }, {
    "name": "InTangut",
    "astral": "[\uD81C-\uD821][\uDC00-\uDFFF]"
  }, {
    "name": "InTangut_Components",
    "astral": "\uD822[\uDC00-\uDEFF]"
  }, {
    "name": "InTelugu",
    "bmp": "ఀ-౿"
  }, {
    "name": "InThaana",
    "bmp": "ހ-޿"
  }, {
    "name": "InThai",
    "bmp": "฀-๿"
  }, {
    "name": "InTibetan",
    "bmp": "ༀ-࿿"
  }, {
    "name": "InTifinagh",
    "bmp": "ⴰ-⵿"
  }, {
    "name": "InTirhuta",
    "astral": "\uD805[\uDC80-\uDCDF]"
  }, {
    "name": "InTransport_And_Map_Symbols",
    "astral": "\uD83D[\uDE80-\uDEFF]"
  }, {
    "name": "InUgaritic",
    "astral": "\uD800[\uDF80-\uDF9F]"
  }, {
    "name": "InUnified_Canadian_Aboriginal_Syllabics",
    "bmp": "᐀-ᙿ"
  }, {
    "name": "InUnified_Canadian_Aboriginal_Syllabics_Extended",
    "bmp": "ᢰ-᣿"
  }, {
    "name": "InVai",
    "bmp": "ꔀ-꘿"
  }, {
    "name": "InVariation_Selectors",
    "bmp": "︀-️"
  }, {
    "name": "InVariation_Selectors_Supplement",
    "astral": "\uDB40[\uDD00-\uDDEF]"
  }, {
    "name": "InVedic_Extensions",
    "bmp": "᳐-᳿"
  }, {
    "name": "InVertical_Forms",
    "bmp": "︐-︟"
  }, {
    "name": "InWarang_Citi",
    "astral": "\uD806[\uDCA0-\uDCFF]"
  }, {
    "name": "InYi_Radicals",
    "bmp": "꒐-꓏"
  }, {
    "name": "InYi_Syllables",
    "bmp": "ꀀ-꒏"
  }, {
    "name": "InYijing_Hexagram_Symbols",
    "bmp": "䷀-䷿"
  }, {
    "name": "InZanabazar_Square",
    "astral": "\uD806[\uDE00-\uDE4F]"
  }, {
    "name": "Inundefined",
    "astral": "\uD803[\uDE80-\uDEBF\uDFB0-\uDFFF]|\uD806[\uDD00-\uDD5F\uDDA0-\uDDFF]|\uD807[\uDFB0-\uDFFF]|\uD80D[\uDC30-\uDC3F]|\uD822[\uDF00-\uDFFF]|\uD823[\uDC00-\uDD8F]|\uD82C[\uDD30-\uDD6F]|\uD838[\uDD00-\uDD4F\uDEC0-\uDEFF]|\uD83B[\uDD00-\uDD4F]|\uD83E[\uDE70-\uDFFF]|[\uD880-\uD883][\uDC00-\uDFFF]|\uD884[\uDC00-\uDF4F]"
  }];
  return blocks;
}
var hasRequiredUnicodeBlocks;
function requireUnicodeBlocks() {
  if (hasRequiredUnicodeBlocks)
    return unicodeBlocksExports;
  hasRequiredUnicodeBlocks = 1;
  (function(module, exports) {
    var _interopRequireDefault = interopRequireDefaultExports;
    var _Object$defineProperty = definePropertyExports$1;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _blocks = _interopRequireDefault(requireBlocks());
    /*!
     * XRegExp Unicode Blocks 4.4.1
     * <xregexp.com>
     * Steven Levithan (c) 2010-present MIT License
     * Unicode data by Mathias Bynens <mathiasbynens.be>
     */
    var _default = function _default2(XRegExp2) {
      if (!XRegExp2.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Blocks");
      }
      XRegExp2.addUnicodeData(_blocks["default"]);
    };
    exports["default"] = _default;
    module.exports = exports.default;
  })(unicodeBlocks, unicodeBlocksExports);
  return unicodeBlocksExports;
}
var unicodeCategoriesExports = {};
var unicodeCategories$1 = {
  get exports() {
    return unicodeCategoriesExports;
  },
  set exports(v) {
    unicodeCategoriesExports = v;
  }
};
var categories$1;
var hasRequiredCategories;
function requireCategories() {
  if (hasRequiredCategories)
    return categories$1;
  hasRequiredCategories = 1;
  categories$1 = [{
    "name": "C",
    "alias": "Other",
    "isBmpLast": true,
    "bmp": "\0--­͸͹΀-΃΋΍΢԰՗՘֋֌֐׈-׏׫-׮׵-؅؜؝۝܎܏݋݌޲-޿߻߼࠮࠯࠿࡜࡝࡟࡫-࢟ࢵࣈ-࣒࣢঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥৿਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੷-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୔୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿఍఑఩఺-఼౅౉౎-౔౗౛-౟౤౥౰-౶಍಑಩಴಺಻೅೉೎-೔೗-ೝ೟೤೥೰ೳ-೿഍഑൅൉൐-൓൤൥඀඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅຋຤຦຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿ᜍ᜕-ᜟ᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠎᠏᠚-᠟᡹-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯᫁-᫿ᭌ-᭏᭽-᭿᯴-᯻᰸-᰺᱊-᱌Ᲊ-᲏᲻᲼᳈-᳏᳻-᳿᷺἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿​-‏‪-‮⁠-⁯⁲⁳₏₝-₟⃀-⃏⃱-⃿↌-↏␧-␿⑋-⑟⭴⭵⮖Ⱟⱟ⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹓-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄㄰㆏㇤-㇯㈟鿽-鿿꒍-꒏꓇-꓏꘬-꘿꛸-꛿ꟀꟁꟋ-ꟴ꠭-꠯꠺-꠿꡸-꡿꣆-꣍꣚-꣟꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭬-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯂-﯒﵀-﵏﶐﶑﷈-﷯﷾﷿︚-︟﹓﹧﹬-﹯﹵﻽-＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￻￾￿",
    "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDF\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDD79\uDDCC\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7B-\uDE7F\uDE87-\uDE8F\uDEA9-\uDEAF\uDEB7-\uDEBF\uDEC3-\uDECF\uDED7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]"
  }, {
    "name": "Cc",
    "alias": "Control",
    "bmp": "\0--"
  }, {
    "name": "Cf",
    "alias": "Format",
    "bmp": "­؀-؅؜۝܏࣢᠎​-‏‪-‮⁠-⁤⁦-⁯\uFEFF￹-￻",
    "astral": "\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC38]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]"
  }, {
    "name": "Cn",
    "alias": "Unassigned",
    "bmp": "͸͹΀-΃΋΍΢԰՗՘֋֌֐׈-׏׫-׮׵-׿؝܎݋݌޲-޿߻߼࠮࠯࠿࡜࡝࡟࡫-࢟ࢵࣈ-࣒঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥৿਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੷-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୔୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿఍఑఩఺-఼౅౉౎-౔౗౛-౟౤౥౰-౶಍಑಩಴಺಻೅೉೎-೔೗-ೝ೟೤೥೰ೳ-೿഍഑൅൉൐-൓൤൥඀඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅຋຤຦຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿ᜍ᜕-ᜟ᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠏᠚-᠟᡹-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯᫁-᫿ᭌ-᭏᭽-᭿᯴-᯻᰸-᰺᱊-᱌Ᲊ-᲏᲻᲼᳈-᳏᳻-᳿᷺἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿⁥⁲⁳₏₝-₟⃀-⃏⃱-⃿↌-↏␧-␿⑋-⑟⭴⭵⮖Ⱟⱟ⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹓-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄㄰㆏㇤-㇯㈟鿽-鿿꒍-꒏꓇-꓏꘬-꘿꛸-꛿ꟀꟁꟋ-ꟴ꠭-꠯꠺-꠿꡸-꡿꣆-꣍꣚-꣟꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭬-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-퟿﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯂-﯒﵀-﵏﶐﶑﷈-﷯﷾﷿︚-︟﹓﹧﹬-﹯﹵﻽﻾＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￸￾￿",
    "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCC\uDCCE\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80D[\uDC2F\uDC39-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDF\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDD79\uDDCC\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7B-\uDE7F\uDE87-\uDE8F\uDEA9-\uDEAF\uDEB7-\uDEBF\uDEC3-\uDECF\uDED7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]"
  }, {
    "name": "Co",
    "alias": "Private_Use",
    "bmp": "-",
    "astral": "[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]"
  }, {
    "name": "Cs",
    "alias": "Surrogate",
    "bmp": "\uD800-\uDFFF"
  }, {
    "name": "L",
    "alias": "Letter",
    "bmp": "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
    "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
  }, {
    "name": "LC",
    "alias": "Cased_Letter",
    "bmp": "A-Za-zµÀ-ÖØ-öø-ƺƼ-ƿǄ-ʓʕ-ʯͰ-ͳͶͷͻ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՠ-ֈႠ-ჅჇჍა-ჺჽ-ჿᎠ-Ᏽᏸ-ᏽᲀ-ᲈᲐ-ᲺᲽ-Ჿᴀ-ᴫᵫ-ᵷᵹ-ᶚḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℴℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⱻⱾ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭꙀ-ꙭꚀ-ꚛꜢ-ꝯꝱ-ꞇꞋ-ꞎꞐ-ꞿꟂ-ꟊꟵꟶꟺꬰ-ꭚꭠ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗＡ-Ｚａ-ｚ",
    "astral": "\uD801[\uDC00-\uDC4F\uDCB0-\uDCD3\uDCD8-\uDCFB]|\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD806[\uDCA0-\uDCDF]|\uD81B[\uDE40-\uDE7F]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDD00-\uDD43]"
  }, {
    "name": "Ll",
    "alias": "Lowercase_Letter",
    "bmp": "a-zµß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʯͱͳͷͻ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯՠ-ֈა-ჺჽ-ჿᏸ-ᏽᲀ-ᲈᴀ-ᴫᵫ-ᵷᵹ-ᶚḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎↄⰰ-ⱞⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱻⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯꝱ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞯꞵꞷꞹꞻꞽꞿꟃꟈꟊꟶꟺꬰ-ꭚꭠ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
    "astral": "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]"
  }, {
    "name": "Lm",
    "alias": "Modifier_Letter",
    "bmp": "ʰ-ˁˆ-ˑˠ-ˤˬˮʹͺՙـۥۦߴߵߺࠚࠤࠨॱๆໆჼៗᡃᪧᱸ-ᱽᴬ-ᵪᵸᶛ-ᶿⁱⁿₐ-ₜⱼⱽⵯⸯ々〱-〵〻ゝゞー-ヾꀕꓸ-ꓽꘌꙿꚜꚝꜗ-ꜟꝰꞈꟸꟹꧏꧦꩰꫝꫳꫴꭜ-ꭟꭩｰﾞﾟ",
    "astral": "\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD838[\uDD37-\uDD3D]|𞥋"
  }, {
    "name": "Lo",
    "alias": "Other_Letter",
    "bmp": "ªºƻǀ-ǃʔא-תׯ-ײؠ-ؿف-يٮٯٱ-ۓەۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪࠀ-ࠕࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॲ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๅກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎᄀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៜᠠ-ᡂᡄ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱷᳩ-ᳬᳮ-ᳳᳵᳶᳺℵ-ℸⴰ-ⵧⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ〆〼ぁ-ゖゟァ-ヺヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꀔꀖ-ꒌꓐ-ꓷꔀ-ꘋꘐ-ꘟꘪꘫꙮꚠ-ꛥꞏꟷꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧠ-ꧤꧧ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩯꩱ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛꫜꫠ-ꫪꫲꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎יִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼｦ-ｯｱ-ﾝﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
    "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF4A\uDF50]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD838[\uDD00-\uDD2C\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
  }, {
    "name": "Lt",
    "alias": "Titlecase_Letter",
    "bmp": "ǅǈǋǲᾈ-ᾏᾘ-ᾟᾨ-ᾯᾼῌῼ"
  }, {
    "name": "Lu",
    "alias": "Uppercase_Letter",
    "bmp": "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵᲐ-ᲺᲽ-ᲿḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅↃⰀ-ⰮⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞮꞰ-ꞴꞶꞸꞺꞼꞾꟂꟄ-ꟇꟉꟵＡ-Ｚ",
    "astral": "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]"
  }, {
    "name": "M",
    "alias": "Mark",
    "bmp": "̀-ͯ҃-҉֑-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣ৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఄా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣඁ-ඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍ᢅᢆᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-ᫀᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿⃐-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯-꙲ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯",
    "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDCE\uDDCF\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC5E\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD806[\uDC2C-\uDC3A\uDD30-\uDD35\uDD37\uDD38\uDD3B-\uDD3E\uDD40\uDD42\uDD43\uDDD1-\uDDD7\uDDDA-\uDDE0\uDDE4\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDEF3-\uDEF6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF51-\uDF87\uDF8F-\uDF92\uDFE4\uDFF0\uDFF1]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
  }, {
    "name": "Mc",
    "alias": "Spacing_Mark",
    "bmp": "ःऻा-ीॉ-ौॎॏংঃা-ীেৈোৌৗਃਾ-ੀઃા-ીૉોૌଂଃାୀେୈୋୌୗாிுூெ-ைொ-ௌௗఁ-ఃు-ౄಂಃಾೀ-ೄೇೈೊೋೕೖംഃാ-ീെ-ൈൊ-ൌൗංඃා-ෑෘ-ෟෲෳ༾༿ཿါာေးျြၖၗၢ-ၤၧ-ၭႃႄႇ-ႌႏႚ-ႜាើ-ៅះៈᤣ-ᤦᤩ-ᤫᤰᤱᤳ-ᤸᨙᨚᩕᩗᩡᩣᩤᩭ-ᩲᬄᬵᬻᬽ-ᭁᭃ᭄ᮂᮡᮦᮧ᮪ᯧᯪ-ᯬᯮ᯲᯳ᰤ-ᰫᰴᰵ᳡᳷〮〯ꠣꠤꠧꢀꢁꢴ-ꣃꥒ꥓ꦃꦴꦵꦺꦻꦾ-꧀ꨯꨰꨳꨴꩍꩻꩽꫫꫮꫯꫵꯣꯤꯦꯧꯩꯪ꯬",
    "astral": "\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD30-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]"
  }, {
    "name": "Me",
    "alias": "Enclosing_Mark",
    "bmp": "҈҉᪾⃝-⃠⃢-⃤꙰-꙲"
  }, {
    "name": "Mn",
    "alias": "Nonspacing_Mark",
    "bmp": "̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ंऺ़ु-ै्॑-ॗॢॣঁ়ু-ৄ্ৢৣ৾ਁਂ਼ੁੂੇੈੋ-੍ੑੰੱੵઁં઼ુ-ૅેૈ્ૢૣૺ-૿ଁ଼ିୁ-ୄ୍୕ୖୢୣஂீ்ఀఄా-ీె-ైొ-్ౕౖౢౣಁ಼ಿೆೌ್ೢೣഀഁ഻഼ു-ൄ്ൢൣඁ්ි-ුූัิ-ฺ็-๎ັິ-ຼ່-ໍཱ༹༘༙༵༷-ཾྀ-྄྆྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္်ွှၘၙၞ-ၠၱ-ၴႂႅႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴឵ិ-ួំ៉-៓៝᠋-᠍ᢅᢆᢩᤠ-ᤢᤧᤨᤲ᤹-᤻ᨘᨗᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽ᪿᫀᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀᮁᮢ-ᮥᮨᮩ᮫-ᮭ᯦ᯨᯩᯭᯯ-ᯱᰬ-ᰳᰶ᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷹᷻-᷿⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〭꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠥꠦ꠬꣄ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꦽꧥꨩ-ꨮꨱꨲꨵꨶꩃꩌꩼꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫬꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯",
    "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
  }, {
    "name": "N",
    "alias": "Number",
    "bmp": "0-9²³¹¼-¾٠-٩۰-۹߀-߉०-९০-৯৴-৹੦-੯૦-૯୦-୯୲-୷௦-௲౦-౯౸-౾೦-೯൘-൞൦-൸෦-෯๐-๙໐-໙༠-༳၀-၉႐-႙፩-፼ᛮ-ᛰ០-៩៰-៹᠐-᠙᥆-᥏᧐-᧚᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙⁰⁴-⁹₀-₉⅐-ↂↅ-↉①-⒛⓪-⓿❶-➓⳽〇〡-〩〸-〺㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꘠-꘩ꛦ-ꛯ꠰-꠵꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
    "astral": "\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2\uDD50-\uDD59]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]"
  }, {
    "name": "Nd",
    "alias": "Decimal_Number",
    "bmp": "0-9٠-٩۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯෦-෯๐-๙໐-໙༠-༩၀-၉႐-႙០-៩᠐-᠙᥆-᥏᧐-᧙᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙꘠-꘩꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
    "astral": "\uD801[\uDCA0-\uDCA9]|\uD803[\uDD30-\uDD39]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9\uDD50-\uDD59]|\uD807[\uDC50-\uDC59\uDD50-\uDD59\uDDA0-\uDDA9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDD50-\uDD59]|\uD83E[\uDFF0-\uDFF9]"
  }, {
    "name": "Nl",
    "alias": "Letter_Number",
    "bmp": "ᛮ-ᛰⅠ-ↂↅ-ↈ〇〡-〩〸-〺ꛦ-ꛯ",
    "astral": "\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]"
  }, {
    "name": "No",
    "alias": "Other_Number",
    "bmp": "²³¹¼-¾৴-৹୲-୷௰-௲౸-౾൘-൞൰-൸༪-༳፩-፼៰-៹᧚⁰⁴-⁹₀-₉⅐-⅟↉①-⒛⓪-⓿❶-➓⳽㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꠰-꠵",
    "astral": "\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C\uDFC0-\uDFD4]|\uD81A[\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD83A[\uDCC7-\uDCCF]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]"
  }, {
    "name": "P",
    "alias": "Punctuation",
    "bmp": "!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}¡§«¶·»¿;·՚-՟։֊־׀׃׆׳״؉؊،؍؛؞؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰৽੶૰౷಄෴๏๚๛༄-༒༔༺-༽྅࿐-࿔࿙࿚၊-၏჻፠-፨᐀᙮᚛᚜᛫-᛭᜵᜶។-៖៘-៚᠀-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‐-‧‰-⁃⁅-⁑⁓-⁞⁽⁾₍₎⌈-⌋〈〉❨-❵⟅⟆⟦-⟯⦃-⦘⧘-⧛⧼⧽⳹-⳼⳾⳿⵰⸀-⸮⸰-⹏⹒、-〃〈-】〔-〟〰〽゠・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫﴾﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪﹫！-＃％-＊，-／：；？＠［-］＿｛｝｟-･",
    "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|𐕯|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|𛲟|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
  }, {
    "name": "Pc",
    "alias": "Connector_Punctuation",
    "bmp": "_‿⁀⁔︳︴﹍-﹏＿"
  }, {
    "name": "Pd",
    "alias": "Dash_Punctuation",
    "bmp": "\\-֊־᐀᠆‐-―⸗⸚⸺⸻⹀〜〰゠︱︲﹘﹣－",
    "astral": "𐺭"
  }, {
    "name": "Pe",
    "alias": "Close_Punctuation",
    "bmp": "\\)\\]\\}༻༽᚜⁆⁾₎⌉⌋〉❩❫❭❯❱❳❵⟆⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽⸣⸥⸧⸩〉》」』】〕〗〙〛〞〟﴾︘︶︸︺︼︾﹀﹂﹄﹈﹚﹜﹞）］｝｠｣"
  }, {
    "name": "Pf",
    "alias": "Final_Punctuation",
    "bmp": "»’”›⸃⸅⸊⸍⸝⸡"
  }, {
    "name": "Pi",
    "alias": "Initial_Punctuation",
    "bmp": "«‘‛“‟‹⸂⸄⸉⸌⸜⸠"
  }, {
    "name": "Po",
    "alias": "Other_Punctuation",
    "bmp": "!-#%-'\\*,\\.\\/:;\\?@\\¡§¶·¿;·՚-՟։׀׃׆׳״؉؊،؍؛؞؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰৽੶૰౷಄෴๏๚๛༄-༒༔྅࿐-࿔࿙࿚၊-၏჻፠-፨᙮᛫-᛭᜵᜶។-៖៘-៚᠀-᠅᠇-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‖‗†-‧‰-‸※-‾⁁-⁃⁇-⁑⁓⁕-⁞⳹-⳼⳾⳿⵰⸀⸁⸆-⸈⸋⸎-⸖⸘⸙⸛⸞⸟⸪-⸮⸰-⸹⸼-⸿⹁⹃-⹏⹒、-〃〽・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫︐-︖︙︰﹅﹆﹉-﹌﹐-﹒﹔-﹗﹟-﹡﹨﹪﹫！-＃％-＇＊，．／：；？＠＼｡､･",
    "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|𐕯|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|𛲟|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
  }, {
    "name": "Ps",
    "alias": "Open_Punctuation",
    "bmp": "\\(\\[\\{༺༼᚛‚„⁅⁽₍⌈⌊〈❨❪❬❮❰❲❴⟅⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼⸢⸤⸦⸨⹂〈《「『【〔〖〘〚〝﴿︗︵︷︹︻︽︿﹁﹃﹇﹙﹛﹝（［｛｟｢"
  }, {
    "name": "S",
    "alias": "Symbol",
    "bmp": "\\$\\+<->\\^`\\|~¢-¦¨©¬®-±´¸×÷˂-˅˒-˟˥-˫˭˯-˿͵΄΅϶҂֍-֏؆-؈؋؎؏۞۩۽۾߶߾߿৲৳৺৻૱୰௳-௺౿൏൹฿༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᙭៛᥀᧞-᧿᭡-᭪᭴-᭼᾽᾿-῁῍-῏῝-῟῭-`´῾⁄⁒⁺-⁼₊-₌₠-₿℀℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊↋←-⌇⌌-⌨⌫-␦⑀-⑊⒜-ⓩ─-❧➔-⟄⟇-⟥⟰-⦂⦙-⧗⧜-⧻⧾-⭳⭶-⮕⮗-⯿⳥-⳪⹐⹑⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿゛゜㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䷀-䷿꒐-꓆꜀-꜖꜠꜡꞉꞊꠨-꠫꠶-꠹꩷-꩹꭛꭪꭫﬩﮲-﯁﷼﷽﹢﹤-﹦﹩＄＋＜-＞＾｀｜～￠-￦￨-￮￼�",
    "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|𑜿|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|𛲜|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEE0-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDD78\uDD7A-\uDDCB\uDDCD-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6\uDF00-\uDF92\uDF94-\uDFCA]"
  }, {
    "name": "Sc",
    "alias": "Currency_Symbol",
    "bmp": "\\$¢-¥֏؋߾߿৲৳৻૱௹฿៛₠-₿꠸﷼﹩＄￠￡￥￦",
    "astral": "\uD807[\uDFDD-\uDFE0]|𞋿|𞲰"
  }, {
    "name": "Sk",
    "alias": "Modifier_Symbol",
    "bmp": "\\^`¨¯´¸˂-˅˒-˟˥-˫˭˯-˿͵΄΅᾽᾿-῁῍-῏῝-῟῭-`´῾゛゜꜀-꜖꜠꜡꞉꞊꭛꭪꭫﮲-﯁＾｀￣",
    "astral": "\uD83C[\uDFFB-\uDFFF]"
  }, {
    "name": "Sm",
    "alias": "Math_Symbol",
    "bmp": "\\+<->\\|~¬±×÷϶؆-؈⁄⁒⁺-⁼₊-₌℘⅀-⅄⅋←-↔↚↛↠↣↦↮⇎⇏⇒⇔⇴-⋿⌠⌡⍼⎛-⎳⏜-⏡▷◁◸-◿♯⟀-⟄⟇-⟥⟰-⟿⤀-⦂⦙-⧗⧜-⧻⧾-⫿⬰-⭄⭇-⭌﬩﹢﹤-﹦＋＜-＞｜～￢￩-￬",
    "astral": "\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]"
  }, {
    "name": "So",
    "alias": "Other_Symbol",
    "bmp": "¦©®°҂֍֎؎؏۞۩۽۾߶৺୰௳-௸௺౿൏൹༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᙭᥀᧞-᧿᭡-᭪᭴-᭼℀℁℃-℆℈℉℔№℗℞-℣℥℧℩℮℺℻⅊⅌⅍⅏↊↋↕-↙↜-↟↡↢↤↥↧-↭↯-⇍⇐⇑⇓⇕-⇳⌀-⌇⌌-⌟⌢-⌨⌫-⍻⍽-⎚⎴-⏛⏢-␦⑀-⑊⒜-ⓩ─-▶▸-◀◂-◷☀-♮♰-❧➔-➿⠀-⣿⬀-⬯⭅⭆⭍-⭳⭶-⮕⮗-⯿⳥-⳪⹐⹑⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䷀-䷿꒐-꓆꠨-꠫꠶꠷꠹꩷-꩹﷽￤￨￭￮￼�",
    "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|𑜿|\uD807[\uDFD5-\uDFDC\uDFE1-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|𛲜|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|𞅏|\uD83B[\uDCAC\uDD2E]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED7\uDEE0-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDD78\uDD7A-\uDDCB\uDDCD-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6\uDF00-\uDF92\uDF94-\uDFCA]"
  }, {
    "name": "Z",
    "alias": "Separator",
    "bmp": "    - \u2028\u2029  　"
  }, {
    "name": "Zl",
    "alias": "Line_Separator",
    "bmp": "\u2028"
  }, {
    "name": "Zp",
    "alias": "Paragraph_Separator",
    "bmp": "\u2029"
  }, {
    "name": "Zs",
    "alias": "Space_Separator",
    "bmp": "    -   　"
  }];
  return categories$1;
}
var hasRequiredUnicodeCategories;
function requireUnicodeCategories() {
  if (hasRequiredUnicodeCategories)
    return unicodeCategoriesExports;
  hasRequiredUnicodeCategories = 1;
  (function(module, exports) {
    var _interopRequireDefault = interopRequireDefaultExports;
    var _Object$defineProperty = definePropertyExports$1;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _categories = _interopRequireDefault(requireCategories());
    /*!
     * XRegExp Unicode Categories 4.4.1
     * <xregexp.com>
     * Steven Levithan (c) 2010-present MIT License
     * Unicode data by Mathias Bynens <mathiasbynens.be>
     */
    var _default = function _default2(XRegExp2) {
      if (!XRegExp2.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Categories");
      }
      XRegExp2.addUnicodeData(_categories["default"]);
    };
    exports["default"] = _default;
    module.exports = exports.default;
  })(unicodeCategories$1, unicodeCategoriesExports);
  return unicodeCategoriesExports;
}
var unicodePropertiesExports = {};
var unicodeProperties$1 = {
  get exports() {
    return unicodePropertiesExports;
  },
  set exports(v) {
    unicodePropertiesExports = v;
  }
};
var properties$1;
var hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties)
    return properties$1;
  hasRequiredProperties = 1;
  properties$1 = [{
    "name": "ASCII",
    "bmp": "\0-"
  }, {
    "name": "Alphabetic",
    "bmp": "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͅͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈְ-ׇֽֿׁׂׅׄא-תׯ-ײؐ-ؚؠ-ٗٙ-ٟٮ-ۓە-ۜۡ-ۭۨ-ۯۺ-ۼۿܐ-ܿݍ-ޱߊ-ߪߴߵߺࠀ-ࠗࠚ-ࠬࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇࣔ-ࣣࣟ-ࣰࣩ-ऻऽ-ौॎ-ॐॕ-ॣॱ-ঃঅ-ঌএঐও-নপ-রলশ-হঽ-ৄেৈোৌৎৗড়ঢ়য়-ৣৰৱৼਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਾ-ੂੇੈੋੌੑਖ਼-ੜਫ਼ੰ-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽ-ૅે-ૉોૌૐૠ-ૣૹ-ૼଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽ-ୄେୈୋୌୖୗଡ଼ଢ଼ୟ-ୣୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-ௌௐௗఀ-ఃఅ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-ౌౕౖౘ-ౚౠ-ౣಀ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ-ೄೆ-ೈೊ-ೌೕೖೞೠ-ೣೱೲഀ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൌൎൔ-ൗൟ-ൣൺ-ൿඁ-ඃඅ-ඖක-නඳ-රලව-ෆා-ුූෘ-ෟෲෳก-ฺเ-ๆํກຂຄຆ-ຊຌ-ຣລວ-ູົ-ຽເ-ໄໆໍໜ-ໟༀཀ-ཇཉ-ཬཱ-ཱྀྈ-ྗྙ-ྼက-ံးျ-ဿၐ-ႏႚ-ႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜓᜠ-ᜳᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-ឳា-ៈៗៜᠠ-ᡸᢀ-ᢪᢰ-ᣵᤀ-ᤞᤠ-ᤫᤰ-ᤸᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨛᨠ-ᩞᩡ-ᩴᪧᪿᫀᬀ-ᬳᬵ-ᭃᭅ-ᭋᮀ-ᮩᮬ-ᮯᮺ-ᯥᯧ-ᯱᰀ-ᰶᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿᷧ-ᷴḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⒶ-ⓩⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙴ-ꙻꙿ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠅꠇ-ꠧꡀ-ꡳꢀ-ꣃꣅꣲ-ꣷꣻꣽ-ꣿꤊ-ꤪꤰ-ꥒꥠ-ꥼꦀ-ꦲꦴ-ꦿꧏꧠ-ꧯꧺ-ꧾꨀ-ꨶꩀ-ꩍꩠ-ꩶꩺ-ꪾꫀꫂꫛ-ꫝꫠ-ꫯꫲ-ꫵꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯪ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
    "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD44-\uDD47\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDCE\uDDCF\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDEB8\uDF00-\uDF1A\uDF1D-\uDF2A]|\uD806[\uDC00-\uDC38\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B\uDD3C\uDD3F-\uDD42\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDDF\uDDE1\uDDE3\uDDE4\uDE00-\uDE32\uDE35-\uDE3E\uDE50-\uDE97\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD41\uDD43\uDD46\uDD47\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD96\uDD98\uDEE0-\uDEF6\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD47\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
  }, {
    "name": "Any",
    "isBmpLast": true,
    "bmp": "\0-￿",
    "astral": "[\uD800-\uDBFF][\uDC00-\uDFFF]"
  }, {
    "name": "Default_Ignorable_Code_Point",
    "bmp": "­͏؜ᅟᅠ឴឵᠋-᠎​-‏‪-‮⁠-⁯ㅤ︀-️\uFEFFﾠ￰-￸",
    "astral": "\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|[\uDB40-\uDB43][\uDC00-\uDFFF]"
  }, {
    "name": "Lowercase",
    "bmp": "a-zªµºß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʸˀˁˠ-ˤͅͱͳͷͺ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯՠ-ֈა-ჺჽ-ჿᏸ-ᏽᲀ-ᲈᴀ-ᶿḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷⁱⁿₐ-ₜℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎⅰ-ⅿↄⓐ-ⓩⰰ-ⱞⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱽⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛ-ꚝꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞯꞵꞷꞹꞻꞽꞿꟃꟈꟊꟶꟸ-ꟺꬰ-ꭚꭜ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
    "astral": "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]"
  }, {
    "name": "Noncharacter_Code_Point",
    "bmp": "﷐-﷯￾￿",
    "astral": "[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]"
  }, {
    "name": "Uppercase",
    "bmp": "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵᲐ-ᲺᲽ-ᲿḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅⅠ-ⅯↃⒶ-ⓏⰀ-ⰮⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞮꞰ-ꞴꞶꞸꞺꞼꞾꟂꟄ-ꟇꟉꟵＡ-Ｚ",
    "astral": "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]"
  }, {
    "name": "White_Space",
    "bmp": "	-\r    - \u2028\u2029  　"
  }];
  return properties$1;
}
var hasRequiredUnicodeProperties;
function requireUnicodeProperties() {
  if (hasRequiredUnicodeProperties)
    return unicodePropertiesExports;
  hasRequiredUnicodeProperties = 1;
  (function(module, exports) {
    var _interopRequireDefault = interopRequireDefaultExports;
    var _Object$defineProperty = definePropertyExports$1;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _properties = _interopRequireDefault(requireProperties());
    /*!
     * XRegExp Unicode Properties 4.4.1
     * <xregexp.com>
     * Steven Levithan (c) 2012-present MIT License
     * Unicode data by Mathias Bynens <mathiasbynens.be>
     */
    var _default = function _default2(XRegExp2) {
      if (!XRegExp2.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Properties");
      }
      var unicodeData = _properties["default"];
      unicodeData.push({
        name: "Assigned",
        // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
        // Categories addon is required to use this property
        inverseOf: "Cn"
      });
      XRegExp2.addUnicodeData(unicodeData);
    };
    exports["default"] = _default;
    module.exports = exports.default;
  })(unicodeProperties$1, unicodePropertiesExports);
  return unicodePropertiesExports;
}
var unicodeScriptsExports = {};
var unicodeScripts$1 = {
  get exports() {
    return unicodeScriptsExports;
  },
  set exports(v) {
    unicodeScriptsExports = v;
  }
};
var scripts$1;
var hasRequiredScripts;
function requireScripts() {
  if (hasRequiredScripts)
    return scripts$1;
  hasRequiredScripts = 1;
  scripts$1 = [{
    "name": "Adlam",
    "astral": "\uD83A[\uDD00-\uDD4B\uDD50-\uDD59\uDD5E\uDD5F]"
  }, {
    "name": "Ahom",
    "astral": "\uD805[\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3F]"
  }, {
    "name": "Anatolian_Hieroglyphs",
    "astral": "\uD811[\uDC00-\uDE46]"
  }, {
    "name": "Arabic",
    "bmp": "؀-؄؆-؋؍-ؚ؜؞ؠ-ؿف-يٖ-ٯٱ-ۜ۞-ۿݐ-ݿࢠ-ࢴࢶ-ࣇ࣓-ࣣ࣡-ࣿﭐ-﯁ﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-﷽ﹰ-ﹴﹶ-ﻼ",
    "astral": "\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]"
  }, {
    "name": "Armenian",
    "bmp": "Ա-Ֆՙ-֊֍-֏ﬓ-ﬗ"
  }, {
    "name": "Avestan",
    "astral": "\uD802[\uDF00-\uDF35\uDF39-\uDF3F]"
  }, {
    "name": "Balinese",
    "bmp": "ᬀ-ᭋ᭐-᭼"
  }, {
    "name": "Bamum",
    "bmp": "ꚠ-꛷",
    "astral": "\uD81A[\uDC00-\uDE38]"
  }, {
    "name": "Bassa_Vah",
    "astral": "\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]"
  }, {
    "name": "Batak",
    "bmp": "ᯀ-᯳᯼-᯿"
  }, {
    "name": "Bengali",
    "bmp": "ঀ-ঃঅ-ঌএঐও-নপ-রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-৾"
  }, {
    "name": "Bhaiksuki",
    "astral": "\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]"
  }, {
    "name": "Bopomofo",
    "bmp": "˪˫ㄅ-ㄯㆠ-ㆿ"
  }, {
    "name": "Brahmi",
    "astral": "\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]"
  }, {
    "name": "Braille",
    "bmp": "⠀-⣿"
  }, {
    "name": "Buginese",
    "bmp": "ᨀ-ᨛ᨞᨟"
  }, {
    "name": "Buhid",
    "bmp": "ᝀ-ᝓ"
  }, {
    "name": "Canadian_Aboriginal",
    "bmp": "᐀-ᙿᢰ-ᣵ"
  }, {
    "name": "Carian",
    "astral": "\uD800[\uDEA0-\uDED0]"
  }, {
    "name": "Caucasian_Albanian",
    "astral": "\uD801[\uDD30-\uDD63\uDD6F]"
  }, {
    "name": "Chakma",
    "astral": "\uD804[\uDD00-\uDD34\uDD36-\uDD47]"
  }, {
    "name": "Cham",
    "bmp": "ꨀ-ꨶꩀ-ꩍ꩐-꩙꩜-꩟"
  }, {
    "name": "Cherokee",
    "bmp": "Ꭰ-Ᏽᏸ-ᏽꭰ-ꮿ"
  }, {
    "name": "Chorasmian",
    "astral": "\uD803[\uDFB0-\uDFCB]"
  }, {
    "name": "Common",
    "bmp": "\0-@\\[-`\\{-©«-¹»-¿×÷ʹ-˟˥-˩ˬ-˿ʹ;΅·؅،؛؟ـ۝࣢।॥฿࿕-࿘჻᛫-᛭᜵᜶᠂᠃᠅᳓᳡ᳩ-ᳬᳮ-ᳳᳵ-᳷ᳺ -​‎-⁤⁦-⁰⁴-⁾₀-₎₠-₿℀-℥℧-℩ℬ-ℱℳ-⅍⅏-⅟↉-↋←-␦⑀-⑊①-⟿⤀-⭳⭶-⮕⮗-⯿⸀-⹒⿰-⿻　-〄〆〈-〠〰-〷〼-〿゛゜゠・ー㆐-㆟㇀-㇣㈠-㉟㉿-㋏㋿㍘-㏿䷀-䷿꜀-꜡ꞈ-꞊꠰-꠹꤮ꧏ꭛꭪꭫﴾﴿︐-︙︰-﹒﹔-﹦﹨-﹫\uFEFF！-＠［-｀｛-･ｰﾞﾟ￠-￦￨-￮￹-�",
    "astral": "\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9C\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD81B[\uDFE2\uDFE3]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDEE0-\uDEF3\uDF00-\uDF56\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83B[\uDC71-\uDCB4\uDD01-\uDD3D]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDDAD\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEE0-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDD78\uDD7A-\uDDCB\uDDCD-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6\uDF00-\uDF92\uDF94-\uDFCA\uDFF0-\uDFF9]|\uDB40[\uDC01\uDC20-\uDC7F]"
  }, {
    "name": "Coptic",
    "bmp": "Ϣ-ϯⲀ-ⳳ⳹-⳿"
  }, {
    "name": "Cuneiform",
    "astral": "\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]"
  }, {
    "name": "Cypriot",
    "astral": "\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]"
  }, {
    "name": "Cyrillic",
    "bmp": "Ѐ-҄҇-ԯᲀ-ᲈᴫᵸⷠ-ⷿꙀ-ꚟ︮︯"
  }, {
    "name": "Deseret",
    "astral": "\uD801[\uDC00-\uDC4F]"
  }, {
    "name": "Devanagari",
    "bmp": "ऀ-ॐॕ-ॣ०-ॿ꣠-ꣿ"
  }, {
    "name": "Dives_Akuru",
    "astral": "\uD806[\uDD00-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD46\uDD50-\uDD59]"
  }, {
    "name": "Dogra",
    "astral": "\uD806[\uDC00-\uDC3B]"
  }, {
    "name": "Duployan",
    "astral": "\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]"
  }, {
    "name": "Egyptian_Hieroglyphs",
    "astral": "\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E\uDC30-\uDC38]"
  }, {
    "name": "Elbasan",
    "astral": "\uD801[\uDD00-\uDD27]"
  }, {
    "name": "Elymaic",
    "astral": "\uD803[\uDFE0-\uDFF6]"
  }, {
    "name": "Ethiopic",
    "bmp": "ሀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፼ᎀ-᎙ⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮ"
  }, {
    "name": "Georgian",
    "bmp": "Ⴀ-ჅჇჍა-ჺჼ-ჿᲐ-ᲺᲽ-Ჿⴀ-ⴥⴧⴭ"
  }, {
    "name": "Glagolitic",
    "bmp": "Ⰰ-Ⱞⰰ-ⱞ",
    "astral": "\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]"
  }, {
    "name": "Gothic",
    "astral": "\uD800[\uDF30-\uDF4A]"
  }, {
    "name": "Grantha",
    "astral": "\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]"
  }, {
    "name": "Greek",
    "bmp": "Ͱ-ͳ͵-ͷͺ-ͽͿ΄ΆΈ-ΊΌΎ-ΡΣ-ϡϰ-Ͽᴦ-ᴪᵝ-ᵡᵦ-ᵪᶿἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ῄῆ-ΐῖ-Ί῝-`ῲ-ῴῶ-῾Ωꭥ",
    "astral": "\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]"
  }, {
    "name": "Gujarati",
    "bmp": "ઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉો-્ૐૠ-ૣ૦-૱ૹ-૿"
  }, {
    "name": "Gunjala_Gondi",
    "astral": "\uD807[\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9]"
  }, {
    "name": "Gurmukhi",
    "bmp": "ਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-੶"
  }, {
    "name": "Han",
    "bmp": "⺀-⺙⺛-⻳⼀-⿕々〇〡-〩〸-〻㐀-䶿一-鿼豈-舘並-龎",
    "astral": "\uD81B[\uDFF0\uDFF1]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
  }, {
    "name": "Hangul",
    "bmp": "ᄀ-ᇿ〮〯ㄱ-ㆎ㈀-㈞㉠-㉾ꥠ-ꥼ가-힣ힰ-ퟆퟋ-ퟻﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ"
  }, {
    "name": "Hanifi_Rohingya",
    "astral": "\uD803[\uDD00-\uDD27\uDD30-\uDD39]"
  }, {
    "name": "Hanunoo",
    "bmp": "ᜠ-᜴"
  }, {
    "name": "Hatran",
    "astral": "\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]"
  }, {
    "name": "Hebrew",
    "bmp": "֑-ׇא-תׯ-״יִ-זּטּ-לּמּנּסּףּפּצּ-ﭏ"
  }, {
    "name": "Hiragana",
    "bmp": "ぁ-ゖゝ-ゟ",
    "astral": "\uD82C[\uDC01-\uDD1E\uDD50-\uDD52]|🈀"
  }, {
    "name": "Imperial_Aramaic",
    "astral": "\uD802[\uDC40-\uDC55\uDC57-\uDC5F]"
  }, {
    "name": "Inherited",
    "bmp": "̀-ًͯ҅҆-ٰٕ॑-॔᪰-ᫀ᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷹᷻-᷿‌‍⃐-〪⃰-゙゚〭︀-️︠-︭",
    "astral": "\uD800[\uDDFD\uDEE0]|𑌻|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]"
  }, {
    "name": "Inscriptional_Pahlavi",
    "astral": "\uD802[\uDF60-\uDF72\uDF78-\uDF7F]"
  }, {
    "name": "Inscriptional_Parthian",
    "astral": "\uD802[\uDF40-\uDF55\uDF58-\uDF5F]"
  }, {
    "name": "Javanese",
    "bmp": "ꦀ-꧍꧐-꧙꧞꧟"
  }, {
    "name": "Kaithi",
    "astral": "\uD804[\uDC80-\uDCC1\uDCCD]"
  }, {
    "name": "Kannada",
    "bmp": "ಀ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೞೠ-ೣ೦-೯ೱೲ"
  }, {
    "name": "Katakana",
    "bmp": "ァ-ヺヽ-ヿㇰ-ㇿ㋐-㋾㌀-㍗ｦ-ｯｱ-ﾝ",
    "astral": "\uD82C[\uDC00\uDD64-\uDD67]"
  }, {
    "name": "Kayah_Li",
    "bmp": "꤀-꤭꤯"
  }, {
    "name": "Kharoshthi",
    "astral": "\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE50-\uDE58]"
  }, {
    "name": "Khitan_Small_Script",
    "astral": "𖿤|\uD822[\uDF00-\uDFFF]|\uD823[\uDC00-\uDCD5]"
  }, {
    "name": "Khmer",
    "bmp": "ក-៝០-៩៰-៹᧠-᧿"
  }, {
    "name": "Khojki",
    "astral": "\uD804[\uDE00-\uDE11\uDE13-\uDE3E]"
  }, {
    "name": "Khudawadi",
    "astral": "\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]"
  }, {
    "name": "Lao",
    "bmp": "ກຂຄຆ-ຊຌ-ຣລວ-ຽເ-ໄໆ່-ໍ໐-໙ໜ-ໟ"
  }, {
    "name": "Latin",
    "bmp": "A-Za-zªºÀ-ÖØ-öø-ʸˠ-ˤᴀ-ᴥᴬ-ᵜᵢ-ᵥᵫ-ᵷᵹ-ᶾḀ-ỿⁱⁿₐ-ₜKÅℲⅎⅠ-ↈⱠ-ⱿꜢ-ꞇꞋ-ꞿꟂ-ꟊꟵ-ꟿꬰ-ꭚꭜ-ꭤꭦ-ꭩﬀ-ﬆＡ-Ｚａ-ｚ"
  }, {
    "name": "Lepcha",
    "bmp": "ᰀ-᰷᰻-᱉ᱍ-ᱏ"
  }, {
    "name": "Limbu",
    "bmp": "ᤀ-ᤞᤠ-ᤫᤰ-᤻᥀᥄-᥏"
  }, {
    "name": "Linear_A",
    "astral": "\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]"
  }, {
    "name": "Linear_B",
    "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]"
  }, {
    "name": "Lisu",
    "bmp": "ꓐ-꓿",
    "astral": "𑾰"
  }, {
    "name": "Lycian",
    "astral": "\uD800[\uDE80-\uDE9C]"
  }, {
    "name": "Lydian",
    "astral": "\uD802[\uDD20-\uDD39\uDD3F]"
  }, {
    "name": "Mahajani",
    "astral": "\uD804[\uDD50-\uDD76]"
  }, {
    "name": "Makasar",
    "astral": "\uD807[\uDEE0-\uDEF8]"
  }, {
    "name": "Malayalam",
    "bmp": "ഀ-ഌഎ-ഐഒ-ൄെ-ൈൊ-൏ൔ-ൣ൦-ൿ"
  }, {
    "name": "Mandaic",
    "bmp": "ࡀ-࡛࡞"
  }, {
    "name": "Manichaean",
    "astral": "\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]"
  }, {
    "name": "Marchen",
    "astral": "\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]"
  }, {
    "name": "Masaram_Gondi",
    "astral": "\uD807[\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]"
  }, {
    "name": "Medefaidrin",
    "astral": "\uD81B[\uDE40-\uDE9A]"
  }, {
    "name": "Meetei_Mayek",
    "bmp": "ꫠ-꫶ꯀ-꯭꯰-꯹"
  }, {
    "name": "Mende_Kikakui",
    "astral": "\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]"
  }, {
    "name": "Meroitic_Cursive",
    "astral": "\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]"
  }, {
    "name": "Meroitic_Hieroglyphs",
    "astral": "\uD802[\uDD80-\uDD9F]"
  }, {
    "name": "Miao",
    "astral": "\uD81B[\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F]"
  }, {
    "name": "Modi",
    "astral": "\uD805[\uDE00-\uDE44\uDE50-\uDE59]"
  }, {
    "name": "Mongolian",
    "bmp": "᠀᠁᠄᠆-᠎᠐-᠙ᠠ-ᡸᢀ-ᢪ",
    "astral": "\uD805[\uDE60-\uDE6C]"
  }, {
    "name": "Mro",
    "astral": "\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]"
  }, {
    "name": "Multani",
    "astral": "\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]"
  }, {
    "name": "Myanmar",
    "bmp": "က-႟ꧠ-ꧾꩠ-ꩿ"
  }, {
    "name": "Nabataean",
    "astral": "\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]"
  }, {
    "name": "Nandinagari",
    "astral": "\uD806[\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE4]"
  }, {
    "name": "New_Tai_Lue",
    "bmp": "ᦀ-ᦫᦰ-ᧉ᧐-᧚᧞᧟"
  }, {
    "name": "Newa",
    "astral": "\uD805[\uDC00-\uDC5B\uDC5D-\uDC61]"
  }, {
    "name": "Nko",
    "bmp": "߀-ߺ߽-߿"
  }, {
    "name": "Nushu",
    "astral": "𖿡|\uD82C[\uDD70-\uDEFB]"
  }, {
    "name": "Nyiakeng_Puachue_Hmong",
    "astral": "\uD838[\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDD4F]"
  }, {
    "name": "Ogham",
    "bmp": " -᚜"
  }, {
    "name": "Ol_Chiki",
    "bmp": "᱐-᱿"
  }, {
    "name": "Old_Hungarian",
    "astral": "\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]"
  }, {
    "name": "Old_Italic",
    "astral": "\uD800[\uDF00-\uDF23\uDF2D-\uDF2F]"
  }, {
    "name": "Old_North_Arabian",
    "astral": "\uD802[\uDE80-\uDE9F]"
  }, {
    "name": "Old_Permic",
    "astral": "\uD800[\uDF50-\uDF7A]"
  }, {
    "name": "Old_Persian",
    "astral": "\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]"
  }, {
    "name": "Old_Sogdian",
    "astral": "\uD803[\uDF00-\uDF27]"
  }, {
    "name": "Old_South_Arabian",
    "astral": "\uD802[\uDE60-\uDE7F]"
  }, {
    "name": "Old_Turkic",
    "astral": "\uD803[\uDC00-\uDC48]"
  }, {
    "name": "Oriya",
    "bmp": "ଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହ଼-ୄେୈୋ-୍୕-ୗଡ଼ଢ଼ୟ-ୣ୦-୷"
  }, {
    "name": "Osage",
    "astral": "\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]"
  }, {
    "name": "Osmanya",
    "astral": "\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]"
  }, {
    "name": "Pahawh_Hmong",
    "astral": "\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]"
  }, {
    "name": "Palmyrene",
    "astral": "\uD802[\uDC60-\uDC7F]"
  }, {
    "name": "Pau_Cin_Hau",
    "astral": "\uD806[\uDEC0-\uDEF8]"
  }, {
    "name": "Phags_Pa",
    "bmp": "ꡀ-꡷"
  }, {
    "name": "Phoenician",
    "astral": "\uD802[\uDD00-\uDD1B\uDD1F]"
  }, {
    "name": "Psalter_Pahlavi",
    "astral": "\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]"
  }, {
    "name": "Rejang",
    "bmp": "ꤰ-꥓꥟"
  }, {
    "name": "Runic",
    "bmp": "ᚠ-ᛪᛮ-ᛸ"
  }, {
    "name": "Samaritan",
    "bmp": "ࠀ-࠭࠰-࠾"
  }, {
    "name": "Saurashtra",
    "bmp": "ꢀ-ꣅ꣎-꣙"
  }, {
    "name": "Sharada",
    "astral": "\uD804[\uDD80-\uDDDF]"
  }, {
    "name": "Shavian",
    "astral": "\uD801[\uDC50-\uDC7F]"
  }, {
    "name": "Siddham",
    "astral": "\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]"
  }, {
    "name": "SignWriting",
    "astral": "\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]"
  }, {
    "name": "Sinhala",
    "bmp": "ඁ-ඃඅ-ඖක-නඳ-රලව-ෆ්ා-ුූෘ-ෟ෦-෯ෲ-෴",
    "astral": "\uD804[\uDDE1-\uDDF4]"
  }, {
    "name": "Sogdian",
    "astral": "\uD803[\uDF30-\uDF59]"
  }, {
    "name": "Sora_Sompeng",
    "astral": "\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]"
  }, {
    "name": "Soyombo",
    "astral": "\uD806[\uDE50-\uDEA2]"
  }, {
    "name": "Sundanese",
    "bmp": "ᮀ-ᮿ᳀-᳇"
  }, {
    "name": "Syloti_Nagri",
    "bmp": "ꠀ-꠬"
  }, {
    "name": "Syriac",
    "bmp": "܀-܍܏-݊ݍ-ݏࡠ-ࡪ"
  }, {
    "name": "Tagalog",
    "bmp": "ᜀ-ᜌᜎ-᜔"
  }, {
    "name": "Tagbanwa",
    "bmp": "ᝠ-ᝬᝮ-ᝰᝲᝳ"
  }, {
    "name": "Tai_Le",
    "bmp": "ᥐ-ᥭᥰ-ᥴ"
  }, {
    "name": "Tai_Tham",
    "bmp": "ᨠ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪠-᪭"
  }, {
    "name": "Tai_Viet",
    "bmp": "ꪀ-ꫂꫛ-꫟"
  }, {
    "name": "Takri",
    "astral": "\uD805[\uDE80-\uDEB8\uDEC0-\uDEC9]"
  }, {
    "name": "Tamil",
    "bmp": "ஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-௺",
    "astral": "\uD807[\uDFC0-\uDFF1\uDFFF]"
  }, {
    "name": "Tangut",
    "astral": "𖿠|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEFF]|\uD823[\uDD00-\uDD08]"
  }, {
    "name": "Telugu",
    "bmp": "ఀ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-్ౕౖౘ-ౚౠ-ౣ౦-౯౷-౿"
  }, {
    "name": "Thaana",
    "bmp": "ހ-ޱ"
  }, {
    "name": "Thai",
    "bmp": "ก-ฺเ-๛"
  }, {
    "name": "Tibetan",
    "bmp": "ༀ-ཇཉ-ཬཱ-ྗྙ-ྼ྾-࿌࿎-࿔࿙࿚"
  }, {
    "name": "Tifinagh",
    "bmp": "ⴰ-ⵧⵯ⵰⵿"
  }, {
    "name": "Tirhuta",
    "astral": "\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]"
  }, {
    "name": "Ugaritic",
    "astral": "\uD800[\uDF80-\uDF9D\uDF9F]"
  }, {
    "name": "Vai",
    "bmp": "ꔀ-ꘫ"
  }, {
    "name": "Wancho",
    "astral": "\uD838[\uDEC0-\uDEF9\uDEFF]"
  }, {
    "name": "Warang_Citi",
    "astral": "\uD806[\uDCA0-\uDCF2\uDCFF]"
  }, {
    "name": "Yezidi",
    "astral": "\uD803[\uDE80-\uDEA9\uDEAB-\uDEAD\uDEB0\uDEB1]"
  }, {
    "name": "Yi",
    "bmp": "ꀀ-ꒌ꒐-꓆"
  }, {
    "name": "Zanabazar_Square",
    "astral": "\uD806[\uDE00-\uDE47]"
  }];
  return scripts$1;
}
var hasRequiredUnicodeScripts;
function requireUnicodeScripts() {
  if (hasRequiredUnicodeScripts)
    return unicodeScriptsExports;
  hasRequiredUnicodeScripts = 1;
  (function(module, exports) {
    var _interopRequireDefault = interopRequireDefaultExports;
    var _Object$defineProperty = definePropertyExports$1;
    _Object$defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _scripts = _interopRequireDefault(requireScripts());
    /*!
     * XRegExp Unicode Scripts 4.4.1
     * <xregexp.com>
     * Steven Levithan (c) 2010-present MIT License
     * Unicode data by Mathias Bynens <mathiasbynens.be>
     */
    var _default = function _default2(XRegExp2) {
      if (!XRegExp2.addUnicodeData) {
        throw new ReferenceError("Unicode Base must be loaded before Unicode Scripts");
      }
      XRegExp2.addUnicodeData(_scripts["default"]);
    };
    exports["default"] = _default;
    module.exports = exports.default;
  })(unicodeScripts$1, unicodeScriptsExports);
  return unicodeScriptsExports;
}
(function(module, exports) {
  var _interopRequireDefault = interopRequireDefaultExports;
  var _Object$defineProperty = definePropertyExports$1;
  _Object$defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _xregexp = _interopRequireDefault(requireXregexp());
  var _build = _interopRequireDefault(requireBuild());
  var _matchrecursive = _interopRequireDefault(requireMatchrecursive());
  var _unicodeBase = _interopRequireDefault(requireUnicodeBase());
  var _unicodeBlocks = _interopRequireDefault(requireUnicodeBlocks());
  var _unicodeCategories = _interopRequireDefault(requireUnicodeCategories());
  var _unicodeProperties = _interopRequireDefault(requireUnicodeProperties());
  var _unicodeScripts = _interopRequireDefault(requireUnicodeScripts());
  (0, _build["default"])(_xregexp["default"]);
  (0, _matchrecursive["default"])(_xregexp["default"]);
  (0, _unicodeBase["default"])(_xregexp["default"]);
  (0, _unicodeBlocks["default"])(_xregexp["default"]);
  (0, _unicodeCategories["default"])(_xregexp["default"]);
  (0, _unicodeProperties["default"])(_xregexp["default"]);
  (0, _unicodeScripts["default"])(_xregexp["default"]);
  var _default = _xregexp["default"];
  exports["default"] = _default;
  module.exports = exports.default;
})(lib, libExports);
var occurrences = {};
var hasRequiredOccurrences;
function requireOccurrences() {
  if (hasRequiredOccurrences)
    return occurrences;
  hasRequiredOccurrences = 1;
  Object.defineProperty(occurrences, "__esModule", {
    value: true
  });
  occurrences.occurrencesInString = occurrences.occurrenceInString = occurrences.occurrencesInTokens = occurrences.occurrenceInTokens = void 0;
  var _tokenizers = requireTokenizers();
  var occurrenceInTokens = function occurrenceInTokens2(tokens2, currentWordIndex, subString) {
    var occurrence = 0;
    for (var i = 0; i <= currentWordIndex; i++) {
      if (tokens2[i].token === subString)
        occurrence++;
    }
    return occurrence;
  };
  occurrences.occurrenceInTokens = occurrenceInTokens;
  var occurrencesInTokens = function occurrencesInTokens2(tokens2, subString) {
    var occurrences2 = 0;
    tokens2.forEach(function(token) {
      if (token && token.token === subString)
        occurrences2++;
    });
    return occurrences2;
  };
  occurrences.occurrencesInTokens = occurrencesInTokens;
  var occurrenceInString = function occurrenceInString2(text, currentWordIndex, subString) {
    var tokens2 = (0, _tokenizers.tokenize)({
      text,
      verbose: true
    });
    var occurrence = occurrenceInTokens(tokens2, currentWordIndex, subString);
    return occurrence;
  };
  occurrences.occurrenceInString = occurrenceInString;
  var occurrencesInString = function occurrencesInString2(text, subString) {
    var tokens2 = (0, _tokenizers.tokenize)({
      text,
      verbose: true
    });
    var occurrences2 = occurrencesInTokens(tokens2, subString);
    return occurrences2;
  };
  occurrences.occurrencesInString = occurrencesInString;
  return occurrences;
}
var normalizers = {};
Object.defineProperty(normalizers, "__esModule", {
  value: true
});
normalizers.normalizer = normalizers.normalizerDestructive = normalizers.normalizationsDestructive = normalizers._spaceNonSemanticGlyphs = normalizers._greekNonSemanticGlyphs = normalizers._hebrewNonSemanticGlyphs = void 0;
var _hebrewNonSemanticGlyphs = [{
  inputs: [/[\u0591-\u05AF\u05BD\u05C0\u05C3-\u05C5\u2060]/gi],
  output: ""
}];
normalizers._hebrewNonSemanticGlyphs = _hebrewNonSemanticGlyphs;
var _greekNonSemanticGlyphs = [{
  inputs: [/[\u0300-\u0362\u0374-\u0375\u037a\u0384-\u0385\u0387]/g],
  output: ""
}];
normalizers._greekNonSemanticGlyphs = _greekNonSemanticGlyphs;
var _spaceNonSemanticGlyphs = [{
  inputs: [/(\u200B)/g],
  output: ""
}, {
  inputs: [/\s+/g],
  output: " "
}];
normalizers._spaceNonSemanticGlyphs = _spaceNonSemanticGlyphs;
var normalizationsDestructive = [].concat(_hebrewNonSemanticGlyphs).concat(_greekNonSemanticGlyphs).concat(_spaceNonSemanticGlyphs);
normalizers.normalizationsDestructive = normalizationsDestructive;
var normalizerDestructive = function normalizerDestructive2(string) {
  var normalizations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : normalizationsDestructive;
  var _string = normalizer(string);
  if (string && normalizations) {
    _string = _string.slice(0);
    normalizations.forEach(function(_ref) {
      var inputs = _ref.inputs, output = _ref.output;
      inputs.forEach(function(input) {
        _string = _string.replace(input, output);
      });
    });
  }
  return _string;
};
normalizers.normalizerDestructive = normalizerDestructive;
var normalizer = function normalizer2() {
  var text = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var form = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "NFKD";
  text = text.normalize(form);
  return text;
};
normalizers.normalizer = normalizer;
var hasRequiredTokenizers;
function requireTokenizers() {
  if (hasRequiredTokenizers)
    return tokenizers;
  hasRequiredTokenizers = 1;
  Object.defineProperty(tokenizers, "__esModule", {
    value: true
  });
  tokenizers.classifyTokens = tokenizers.tokenize = tokenizers.tokenizeOrigLang = tokenizers.number_ = tokenizers.greedyNumber = tokenizers.number = tokenizers.whitespace = tokenizers.punctuation = tokenizers.origGreedyWord = tokenizers.greedyWord = tokenizers.origWord = tokenizers.word = tokenizers._greedyNumber = tokenizers._origGreedyWord = tokenizers._greedyWord = tokenizers._origWordOrNumber = tokenizers._wordOrNumber = tokenizers._number = tokenizers._origWord = tokenizers._word = void 0;
  var _xregexp = _interopRequireDefault(libExports);
  var _occurrences2 = requireOccurrences();
  var _normalizers = normalizers;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty2(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _word = "[\\pL\\pM\\u200D\\u2060]+";
  tokenizers._word = _word;
  var _origWord = "[\\pL\\pM\\u200D\\u2060\\u2019]+";
  tokenizers._origWord = _origWord;
  var _number = "[\\pN\\pNd\\pNl\\pNo]+";
  tokenizers._number = _number;
  var _wordOrNumber = "(" + _word + "|" + _number + ")";
  tokenizers._wordOrNumber = _wordOrNumber;
  var _origWordOrNumber = "(" + _origWord + "|" + _number + ")";
  tokenizers._origWordOrNumber = _origWordOrNumber;
  var _greedyWord = "(" + _wordOrNumber + "([-'’]" + _word + ")+|" + _word + "’?)";
  tokenizers._greedyWord = _greedyWord;
  var _origGreedyWord = "(" + _origWordOrNumber + "([-'’]" + _origWord + ")+|" + _origWord + "’?)";
  tokenizers._origGreedyWord = _origGreedyWord;
  var _greedyNumber = "(" + _number + "([:.,]?" + _number + ")+|" + _number + ")";
  tokenizers._greedyNumber = _greedyNumber;
  var word = (0, _xregexp["default"])(_word, "");
  tokenizers.word = word;
  var origWord = (0, _xregexp["default"])(_origWord, "");
  tokenizers.origWord = origWord;
  var greedyWord = (0, _xregexp["default"])(_greedyWord, "");
  tokenizers.greedyWord = greedyWord;
  var origGreedyWord = (0, _xregexp["default"])(_origGreedyWord, "");
  tokenizers.origGreedyWord = origGreedyWord;
  var punctuation = (0, _xregexp["default"])("(^\\p{P}|[<>]{2})", "");
  tokenizers.punctuation = punctuation;
  var whitespace = /\s+/;
  tokenizers.whitespace = whitespace;
  var number = (0, _xregexp["default"])(_number);
  tokenizers.number = number;
  var greedyNumber = (0, _xregexp["default"])(_greedyNumber);
  tokenizers.greedyNumber = greedyNumber;
  var number_ = (0, _xregexp["default"])(number);
  tokenizers.number_ = number_;
  var tokenizeOrigLang = function tokenizeOrigLang2(params) {
    return tokenize(_objectSpread2({
      parsers: {
        word: origWord,
        greedyWord: origGreedyWord,
        whitespace,
        punctuation,
        number
      }
    }, params));
  };
  tokenizers.tokenizeOrigLang = tokenizeOrigLang;
  var tokenize = function tokenize2(_ref) {
    var _ref$text = _ref.text, text = _ref$text === void 0 ? "" : _ref$text, _ref$includeWords = _ref.includeWords, includeWords = _ref$includeWords === void 0 ? true : _ref$includeWords, _ref$includeNumbers = _ref.includeNumbers, includeNumbers = _ref$includeNumbers === void 0 ? true : _ref$includeNumbers, _ref$includePunctuati = _ref.includePunctuation, includePunctuation = _ref$includePunctuati === void 0 ? false : _ref$includePunctuati, _ref$includeWhitespac = _ref.includeWhitespace, includeWhitespace = _ref$includeWhitespac === void 0 ? false : _ref$includeWhitespac, _ref$includeUnknown = _ref.includeUnknown, includeUnknown = _ref$includeUnknown === void 0 ? false : _ref$includeUnknown, _ref$greedy = _ref.greedy, greedy = _ref$greedy === void 0 ? false : _ref$greedy, _ref$verbose = _ref.verbose, verbose = _ref$verbose === void 0 ? false : _ref$verbose, _ref$occurrences = _ref.occurrences, occurrences2 = _ref$occurrences === void 0 ? false : _ref$occurrences, _ref$parsers = _ref.parsers, parsers = _ref$parsers === void 0 ? {
      word,
      greedyWord,
      whitespace,
      punctuation,
      number
    } : _ref$parsers, _ref$normalize = _ref.normalize, normalize2 = _ref$normalize === void 0 ? false : _ref$normalize, _ref$normalizations = _ref.normalizations, normalizations = _ref$normalizations === void 0 ? null : _ref$normalizations;
    var string = text.slice(0);
    if (normalize2)
      string = (0, _normalizers.normalizer)(string);
    if (normalize2 && normalizations) {
      string = (0, _normalizers.normalizerDestructive)(string, normalizations);
    }
    var greedyParsers = _objectSpread2({}, parsers, {
      word: parsers.greedyWord,
      number: greedyNumber
    });
    var _parsers = greedy ? greedyParsers : parsers;
    delete _parsers.greedyWord;
    var tokens2 = classifyTokens(string, _parsers, "unknown");
    var types = [];
    if (includeWords)
      types.push("word");
    if (includeNumbers)
      types.push("number");
    if (includeWhitespace)
      types.push("whitespace");
    if (includePunctuation)
      types.push("punctuation");
    if (includeUnknown)
      types.push("unknown");
    tokens2 = tokens2.filter(function(token) {
      return types.includes(token.type);
    });
    if (occurrences2) {
      tokens2 = tokens2.map(function(token, index) {
        var _occurrences3 = (0, _occurrences2.occurrencesInTokens)(tokens2, token.token);
        var _occurrence = (0, _occurrences2.occurrenceInTokens)(tokens2, index, token.token);
        return _objectSpread2({}, token, {
          occurrence: _occurrence,
          occurrences: _occurrences3
        });
      });
    }
    if (verbose) {
      tokens2 = tokens2.map(function(token) {
        delete token.matches;
        return token;
      });
    } else {
      tokens2 = tokens2.map(function(token) {
        return token.token;
      });
    }
    return tokens2;
  };
  tokenizers.tokenize = tokenize;
  var classifyTokens = function classifyTokens2(string, parsers, deftok) {
    string = !string ? "" : string;
    if (typeof string !== "string") {
      throw new Error("tokenizer.tokenize() string is not String: ".concat(string));
    }
    var m;
    var r;
    var t;
    var tokens2 = [];
    while (string) {
      t = null;
      m = string.length;
      var key = void 0;
      for (key in parsers) {
        if (Object.prototype.hasOwnProperty.call(parsers, key)) {
          r = parsers[key].exec(string);
          if (r && r.index < m) {
            var token = r[0];
            t = {
              token,
              type: key,
              matches: r.slice(1)
            };
            m = r.index;
          }
        }
      }
      if (m) {
        tokens2.push({
          token: string.substr(0, m),
          type: deftok || "unknown"
        });
      }
      if (t) {
        tokens2.push(t);
      }
      string = string.substr(m + (t ? t.token.length : 0));
    }
    return tokens2;
  };
  tokenizers.classifyTokens = classifyTokens;
  return tokenizers;
}
var selectionHelpers = {};
Object.defineProperty(selectionHelpers, "__esModule", {
  value: true
});
selectionHelpers.selectionArray = selectionHelpers.selectionsToRanges = selectionHelpers.spliceStringOnRanges = void 0;
var _occurrences = requireOccurrences();
var spliceStringOnRanges = function spliceStringOnRanges2(string, ranges) {
  var selectionArray3 = [];
  var remainingString = string;
  var rangeShift = 0;
  ranges.forEach(function(range) {
    var firstCharacterPosition = range[0] - rangeShift;
    var beforeSelection = remainingString.slice(0, firstCharacterPosition);
    if (beforeSelection) {
      selectionArray3.push({
        text: beforeSelection,
        selected: false
      });
    }
    var shiftedRangeStart = range[0] - rangeShift;
    var shiftedRangeEnd = range[1] + 1 - rangeShift;
    var selection = remainingString.slice(shiftedRangeStart, shiftedRangeEnd);
    var stringBeforeRange = string.slice(0, range[0]);
    var occurrence = (0, _occurrences.occurrencesInString)(stringBeforeRange, selection) + 1;
    var occurrences2 = (0, _occurrences.occurrencesInString)(string, selection);
    var selectionObject = {
      text: selection,
      selected: true,
      occurrence,
      occurrences: occurrences2
    };
    selectionArray3.push(selectionObject);
    var lastCharacterPosition = range[1] - rangeShift + 1;
    remainingString = remainingString.slice(lastCharacterPosition);
    rangeShift += beforeSelection.length;
    rangeShift += selection.length;
  });
  if (remainingString) {
    selectionArray3.push({
      text: remainingString,
      selected: false
    });
  }
  return selectionArray3;
};
selectionHelpers.spliceStringOnRanges = spliceStringOnRanges;
var selectionsToRanges = function selectionsToRanges2(string, selections) {
  var ranges = [];
  selections.forEach(function(selection) {
    if (string && string.includes(selection.text)) {
      var splitArray = string.split(selection.text);
      var beforeSelection = splitArray.slice(0, selection.occurrence);
      beforeSelection = beforeSelection.join(selection.text);
      var start = beforeSelection.length;
      var end = start + selection.text.length - 1;
      var range = [start, end];
      ranges.push(range);
    }
  });
  return ranges;
};
selectionHelpers.selectionsToRanges = selectionsToRanges;
var selectionArray = function selectionArray2(string, selections) {
  var selectionArray3 = [];
  var ranges = selectionsToRanges(string, selections);
  selectionArray3 = spliceStringOnRanges(string, ranges);
  return selectionArray3;
};
selectionHelpers.selectionArray = selectionArray;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "tokenize", {
    enumerable: true,
    get: function get() {
      return _tokenizers.tokenize;
    }
  });
  Object.defineProperty(exports, "tokenizeOrigLang", {
    enumerable: true,
    get: function get() {
      return _tokenizers.tokenizeOrigLang;
    }
  });
  Object.defineProperty(exports, "word", {
    enumerable: true,
    get: function get() {
      return _tokenizers.word;
    }
  });
  Object.defineProperty(exports, "punctuation", {
    enumerable: true,
    get: function get() {
      return _tokenizers.punctuation;
    }
  });
  Object.defineProperty(exports, "whitespace", {
    enumerable: true,
    get: function get() {
      return _tokenizers.whitespace;
    }
  });
  Object.defineProperty(exports, "number", {
    enumerable: true,
    get: function get() {
      return _tokenizers.number_;
    }
  });
  Object.defineProperty(exports, "normalizer", {
    enumerable: true,
    get: function get() {
      return _normalizers.normalizer;
    }
  });
  Object.defineProperty(exports, "normalizerDestructive", {
    enumerable: true,
    get: function get() {
      return _normalizers.normalizerDestructive;
    }
  });
  Object.defineProperty(exports, "normalizationsDestructive", {
    enumerable: true,
    get: function get() {
      return _normalizers.normalizationsDestructive;
    }
  });
  Object.defineProperty(exports, "occurrenceInString", {
    enumerable: true,
    get: function get() {
      return _occurrences2.occurrenceInString;
    }
  });
  Object.defineProperty(exports, "occurrencesInString", {
    enumerable: true,
    get: function get() {
      return _occurrences2.occurrencesInString;
    }
  });
  Object.defineProperty(exports, "selectionArray", {
    enumerable: true,
    get: function get() {
      return _selectionHelpers.selectionArray;
    }
  });
  Object.defineProperty(exports, "spliceStringOnRanges", {
    enumerable: true,
    get: function get() {
      return _selectionHelpers.spliceStringOnRanges;
    }
  });
  Object.defineProperty(exports, "selectionsToRanges", {
    enumerable: true,
    get: function get() {
      return _selectionHelpers.selectionsToRanges;
    }
  });
  var _tokenizers = requireTokenizers();
  var _normalizers = normalizers;
  var _occurrences2 = requireOccurrences();
  var _selectionHelpers = selectionHelpers;
})(lib$1);
var QUOTE_ELLIPSIS = "&";
var DEFAULT_SEPARATOR = " ";
var dist = {};
var referenceHelpers = {};
Object.defineProperty(referenceHelpers, "__esModule", {
  value: true
});
referenceHelpers.characterizeReference = characterizeReference;
referenceHelpers.cleanupReference = cleanupReference;
referenceHelpers.convertReferenceChunksToString = convertReferenceChunksToString;
referenceHelpers.getVerseList = getVerseList;
referenceHelpers.getVerseSpanRange = getVerseSpanRange;
referenceHelpers.getVerses = getVerses;
referenceHelpers.isVerseInRange = isVerseInRange;
referenceHelpers.isVerseList = isVerseList;
referenceHelpers.isVerseSet = isVerseSet;
referenceHelpers.isVerseSpan = isVerseSpan;
referenceHelpers.parseReferenceToList = parseReferenceToList;
referenceHelpers.toInt = toInt;
referenceHelpers.toIntIfValid = toIntIfValid;
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return {
        s: F,
        n: function n() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e2) {
          throw _e2;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e3) {
      didErr = true;
      err = _e3;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var RANGE_SEPARATORS = [
  "-",
  // HYPHEN-MINUS
  "­",
  // SOFT HYPHEN
  "‐",
  // HYPHEN
  "‑",
  // NON-BREAKING HYPHEN
  "‒",
  // FIGURE DASH
  "–",
  // EN DASH
  "—"
  // EM DASH
];
function parseReferenceToList(ref) {
  try {
    var verseChunks = [];
    var refChunks = ref.split(";");
    var lastChapter = 1;
    var _iterator = _createForOfIteratorHelper$1(refChunks), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var refChunk = _step.value;
        if (!refChunk) {
          continue;
        }
        if (!refChunk.includes(":")) {
          verseChunks = addChapterReference(verseChunks, refChunk);
          continue;
        }
        var verseParts = refChunk.split(",");
        var _getChapterVerse = getChapterVerse(verseParts[0]), chapter = _getChapterVerse.chapter, verse = _getChapterVerse.verse, foundChapterVerse = _getChapterVerse.foundChapterVerse;
        if (!foundChapterVerse) {
          chapter = verse;
          verse = null;
        }
        lastChapter = chapter;
        var range = getRange(verse);
        verseChunks.push(_objectSpread(_objectSpread({}, range), {}, {
          chapter
        }));
        if (range.endChapter) {
          lastChapter = range.endChapter;
        }
        for (var i = 1; i < verseParts.length; i++) {
          var versePart = verseParts[i];
          if (!versePart) {
            continue;
          }
          var _getChapterVerse2 = getChapterVerse(versePart), chapter_ = _getChapterVerse2.chapter, verse_ = _getChapterVerse2.verse, _foundChapterVerse = _getChapterVerse2.foundChapterVerse;
          if (_foundChapterVerse) {
            chapter = chapter_;
            verse = verse_;
            lastChapter = chapter;
          } else {
            chapter = lastChapter;
            verse = verse_;
          }
          var _range = getRange(verse);
          if (_range.endVerse) {
            verseChunks.push(_objectSpread(_objectSpread({}, _range), {}, {
              chapter
            }));
            if (_range.endChapter) {
              lastChapter = _range.endChapter;
            }
          } else {
            verseChunks.push({
              verse: _range.verse,
              chapter
            });
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return verseChunks;
  } catch (e) {
    console.warn('parseReferenceToList() - invalid ref: "'.concat(ref, '"'), e);
  }
  return null;
}
function addChapterReference(verseChunks, chapterRef) {
  var isRange = getRangeSeparator(chapterRef) >= 0;
  if (isRange) {
    var pos = getRangeSeparator(chapterRef);
    var foundRange = pos >= 0;
    if (foundRange) {
      var start = toIntIfValid(chapterRef.substring(0, pos));
      var end = toIntIfValid(chapterRef.substring(pos + 1));
      return [].concat(_toConsumableArray(verseChunks), [{
        chapter: start,
        endChapter: end
      }]);
    }
  } else {
    return [].concat(_toConsumableArray(verseChunks), [{
      chapter: toIntIfValid(chapterRef)
    }]);
  }
  return verseChunks;
}
function convertReferenceChunksToString(chunks) {
  var result = "";
  try {
    var lastChapter = null;
    var lastChunk = null;
    if (Array.isArray(chunks)) {
      var _iterator2 = _createForOfIteratorHelper$1(chunks), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var chunk = _step2.value;
          if (chunk.endChapter) {
            if (result) {
              result += ";";
            }
            if (!chunk.verse) {
              result += "".concat(chunk.chapter, "-").concat(chunk.endChapter);
            } else {
              result += "".concat(chunk.chapter, ":").concat(chunk.verse, "-").concat(chunk.endChapter, ":").concat(chunk.endVerse);
            }
            lastChapter = chunk.endChapter;
          } else {
            if (lastChapter !== chunk.chapter || lastChunk && lastChunk.endChapter) {
              if (result) {
                result += ";";
              }
              result += "".concat(chunk.chapter) + (chunk.verse ? ":" : "");
              lastChapter = chunk.chapter;
            } else {
              if (result) {
                result += ",";
              }
            }
            if (chunk.verse) {
              result += "".concat(chunk.verse);
            }
            if (chunk.endVerse) {
              if (chunk.endVerse === "ff") {
                result += chunk.endVerse;
              } else {
                result += "-".concat(chunk.endVerse);
              }
            }
          }
          lastChunk = chunk;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (e) {
    console.warn('convertReferenceChunksToString() - invalid chunks: "'.concat(JSON.stringify(chunks), '"'));
  }
  return result;
}
function characterizeReference(chunks, refStr) {
  var results = {};
  if (chunks && chunks.length && refStr) {
    var multiverse = false;
    var verseStr = null;
    results.chapter = chunks[0].chapter;
    results.verse = chunks[0].verse;
    var pos = refStr.indexOf(":");
    if (pos >= 0) {
      verseStr = refStr.substring(pos + 1);
    }
    if (chunks.length > 1) {
      multiverse = true;
    } else if (chunks[0].endVerse) {
      multiverse = true;
    }
    if (multiverse) {
      results.verseStr = verseStr;
      results.verse = verseStr;
    }
  }
  return results;
}
function cleanupReference(ref) {
  var chunks = parseReferenceToList(ref);
  var cleanedRef = convertReferenceChunksToString(chunks);
  var results = characterizeReference(chunks, cleanedRef);
  results.cleanedRef = cleanedRef;
  return results;
}
function getVerseList(verseStr) {
  var verses = verseStr.toString().split(",");
  return verses;
}
function isVerseSpan(verse) {
  var isSpan = typeof verse === "string" && verse.includes("-");
  return isSpan;
}
function isVerseList(verse) {
  var isList = typeof verse === "string" && verse.includes(",");
  return isList;
}
function isVerseSet(verse) {
  var isSet = isVerseSpan(verse) || isVerseList(verse);
  return isSet;
}
function getVerseSpanRange(verseSpan) {
  var _verseSpan$split = verseSpan.split("-"), _verseSpan$split2 = _slicedToArray(_verseSpan$split, 2), low = _verseSpan$split2[0], high = _verseSpan$split2[1];
  if (low && high) {
    low = parseInt(low, 10);
    high = parseInt(high, 10);
    if (low > 0 && high >= low) {
      return {
        low,
        high
      };
    }
  }
  return {};
}
function isVerseInRange(chapter, verse, endChapter, endVerse) {
  if (chapter < endChapter) {
    return true;
  }
  if (chapter === endChapter) {
    if (verse <= endVerse) {
      return true;
    }
  }
  return false;
}
function getRange(ref) {
  var refType = _typeof(ref);
  var isNumber = refType === "number";
  if (!isNumber) {
    var pos = getRangeSeparator(ref);
    var foundRange = pos >= 0;
    if (foundRange) {
      var start = toIntIfValid(ref.substring(0, pos));
      var endStr = ref.substring(pos + 1);
      var _getChapterVerse3 = getChapterVerse(endStr), chapter = _getChapterVerse3.chapter, verse = _getChapterVerse3.verse, foundChapterVerse = _getChapterVerse3.foundChapterVerse;
      if (foundChapterVerse) {
        return {
          verse: start,
          endChapter: chapter,
          endVerse: verse
        };
      } else {
        return {
          verse: start,
          endVerse: toIntIfValid(endStr)
        };
      }
    } else if (ref.toLowerCase().includes("ff")) {
      var followingPos = ref.indexOf("ff");
      var _start = toIntIfValid(ref.substring(0, followingPos));
      return {
        verse: _start,
        endVerse: "ff"
      };
    }
  }
  return {
    verse: ref
  };
}
function getChapterVerse(ref) {
  if (typeof ref !== "string") {
    return {
      verse: ref
    };
  }
  var pos = (ref || "").indexOf(":");
  var foundChapterVerse = pos >= 0;
  var chapter, verse;
  if (foundChapterVerse) {
    chapter = toIntIfValid(ref.substring(0, pos));
    verse = toIntIfValid(ref.substring(pos + 1));
  } else {
    verse = toIntIfValid(ref);
  }
  return {
    chapter,
    verse,
    foundChapterVerse
  };
}
function toInt(value) {
  return typeof value === "string" ? parseInt(value, 10) : value;
}
function toIntIfValid(value) {
  if (typeof value === "string") {
    var pos = getRangeSeparator(value);
    if (pos >= 0) {
      return value;
    }
    if (value.includes("ff")) {
      return value;
    }
    var intValue = toInt(value);
    if (!isNaN(intValue)) {
      return intValue;
    }
  }
  return value;
}
function getRangeSeparator(versePart) {
  var _iterator3 = _createForOfIteratorHelper$1(RANGE_SEPARATORS), _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
      var separator = _step3.value;
      var pos = versePart.indexOf(separator);
      if (pos >= 0) {
        return pos;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return -1;
}
function findVerseInVerseRange(chapterData, verse, chapter) {
  var verseKeys = Object.keys(chapterData);
  var foundVerseKey, verseData, verseKey, nextVerse;
  for (var _i2 = 0, _verseKeys = verseKeys; _i2 < _verseKeys.length; _i2++) {
    verseKey = _verseKeys[_i2];
    if (isVerseSpan(verseKey)) {
      var _getVerseSpanRange = getVerseSpanRange(verseKey), low = _getVerseSpanRange.low, high = _getVerseSpanRange.high;
      if (verse >= low && verse <= high) {
        verseData = chapterData[verseKey];
        foundVerseKey = verse;
        nextVerse = high + 1;
        break;
      }
    }
  }
  return {
    foundVerseKey,
    verse: verseKey,
    verseData,
    nextVerse
  };
}
function getVerses(bookData, ref) {
  var verses = [];
  var chunks = parseReferenceToList(ref);
  var chapterData, verseData;
  var _iterator4 = _createForOfIteratorHelper$1(chunks), _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
      var chunk = _step4.value;
      if (!chunk.endVerse) {
        var chapter = chunk.chapter;
        chapterData = bookData[chapter];
        var verseKey = chunk.verse;
        verseData = chapterData && chapterData[verseKey];
        if (!verseData && chapterData) {
          var __ret = findVerseInVerseRange(chapterData, verseKey, chapter);
          if (__ret.foundVerseKey) {
            verseKey = __ret.verse;
            verseData = __ret.verseData;
          }
        }
        verses.push({
          chapter,
          verse: verseKey,
          verseData
        });
      } else {
        var _chapter = chunk.chapter;
        var verse = chunk.verse;
        var endVerse = chunk.endVerse;
        var endChapter = chunk.endChapter || _chapter;
        while (isVerseInRange(_chapter, verse, endChapter, endVerse)) {
          chapterData = bookData[_chapter];
          verseData = chapterData && chapterData[verse];
          var _verseKey = verse;
          if (!verseData && chapterData) {
            var _ret = findVerseInVerseRange(chapterData, _verseKey, _chapter);
            if (_ret.foundVerseKey) {
              _verseKey = _ret.verse;
              verseData = _ret.verseData;
              verse = _ret.nextVerse - 1;
            }
          }
          if (!verseData) {
            _chapter += 1;
            verse = 1;
            continue;
          }
          verses.push({
            chapter: _chapter,
            verse: _verseKey,
            verseData
          });
          verse += 1;
        }
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return verses;
}
var doesReferenceContain$1 = {};
Object.defineProperty(doesReferenceContain$1, "__esModule", {
  value: true
});
doesReferenceContain$1.doesReferenceContain = doesReferenceContain;
var _referenceHelpers = referenceHelpers;
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return {
        s: F,
        n: function n() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function doesReferenceContain(refToSearch, refSearchTerm) {
  var strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var verseChunksToSearch = (0, _referenceHelpers.parseReferenceToList)(refToSearch);
  var refSearchChunks = (0, _referenceHelpers.parseReferenceToList)(refSearchTerm);
  var _iterator = _createForOfIteratorHelper(refSearchChunks), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var searchChunk = _step.value;
      if (doChunksContainChunk(verseChunksToSearch, searchChunk, strict)) {
        if (!strict)
          return true;
      } else {
        if (strict)
          return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return strict ? true : false;
}
function doChunksContainChunk(verseChunks, searchChunk, strict) {
  var _iterator2 = _createForOfIteratorHelper(verseChunks), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var verseChunk = _step2.value;
      if (searchChunk.endVerse) {
        if (chunkContainsVerseRange(verseChunk, searchChunk, strict)) {
          return true;
        }
      } else {
        if (chunkContainsVerse(verseChunk, searchChunk.chapter, searchChunk.verse)) {
          return true;
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return false;
}
function chunkContainsVerse(verseChunk, searchChapter, searchVerse) {
  if (!verseChunk.endChapter) {
    if (searchChapter === verseChunk.chapter) {
      if (verseChunk.verse) {
        if (!verseChunk.endVerse) {
          return searchVerse === verseChunk.verse;
        } else {
          if (verseChunk.endVerse === "ff") {
            return verseChunk.verse <= searchVerse;
          } else {
            return verseChunk.verse <= searchVerse && searchVerse <= verseChunk.endVerse;
          }
        }
      } else
        return true;
    } else
      return false;
  } else {
    if (verseChunk.chapter <= searchChapter && searchChapter <= verseChunk.endChapter) {
      if (verseChunk.verse) {
        if (searchChapter === verseChunk.chapter) {
          return searchVerse >= verseChunk.verse;
        } else if (searchChapter === verseChunk.endChapter) {
          return searchVerse <= verseChunk.endVerse;
        } else
          return true;
      } else
        return true;
    } else
      return false;
  }
}
function chunkContainsVerseRange(verseChunk, searchChunk, strict) {
  if (!verseChunk.endChapter) {
    if (searchChunk.endChapter) {
      return chapterRangeContainedInChapter(verseChunk, searchChunk, strict);
    }
    return chapterVerseRangeContainedInChapter(verseChunk, searchChunk, strict);
  } else {
    if (searchChunk.endChapter) {
      return chapterRangeContainedInChapterRange(verseChunk, searchChunk, strict);
    } else if (verseChunk.chapter <= searchChunk.chapter && searchChunk.chapter <= verseChunk.endChapter) {
      return chapterVerseRangeContainedInChapterRange(verseChunk, searchChunk, strict);
    }
    return false;
  }
}
function chapterRangeContainedInChapter(chapter, searchChapterRange) {
  var strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (strict) {
    return false;
  } else {
    if (searchChapterRange.endChapter < chapter.chapter || searchChapterRange.chapter > chapter.chapter) {
      return false;
    }
    if (searchChapterRange.endChapter === chapter.chapter) {
      if (!chapter.verse) {
        return true;
      }
      if (!chapter.endVerse && searchChapterRange.endVerse < chapter.verse) {
        return false;
      }
      if (chapter.endVerse === "ff") {
        return searchChapterRange.endVerse >= chapter.verse;
      }
      if (searchChapterRange.endVerse < chapter.verse) {
        return false;
      }
      return true;
    }
    if (searchChapterRange.chapter === chapter.chapter) {
      if (!chapter.verse) {
        return true;
      }
      if (!chapter.endVerse) {
        if (searchChapterRange.verse > chapter.verse) {
          return false;
        }
        return true;
      }
      if (chapter.endVerse === "ff") {
        return true;
      }
      if (searchChapterRange.verse > chapter.endVerse) {
        return false;
      }
      return true;
    } else
      return true;
  }
}
function chapterVerseRangeContainedInChapter(chapterVerseRange, searchRange) {
  var strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (searchRange.chapter === chapterVerseRange.chapter) {
    if (chapterVerseRange.verse) {
      if (!chapterVerseRange.endVerse) {
        if (strict)
          return false;
        if (searchRange.endVerse < chapterVerseRange.verse || searchRange.verse > chapterVerseRange.verse) {
          return false;
        }
        return true;
      }
      if (chapterVerseRange.endVerse === "ff") {
        if (strict) {
          return chapterVerseRange.verse <= searchRange.verse;
        } else {
          return searchRange.endVerse >= chapterVerseRange.verse;
        }
      } else {
        if (strict) {
          return chapterVerseRange.verse <= searchRange.verse && searchRange.endVerse <= chapterVerseRange.endVerse;
        } else {
          if (searchRange.endVerse < chapterVerseRange.verse || searchRange.verse > chapterVerseRange.endVerse) {
            return false;
          } else
            return true;
        }
      }
    } else
      return true;
  } else
    return false;
}
function chapterRangeContainedInChapterRange(chapterRange, rangeSearchChunk) {
  var strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (strict) {
    if (chapterRange.chapter <= rangeSearchChunk.chapter && rangeSearchChunk.endChapter <= chapterRange.endChapter) {
      if (chapterRange.verse) {
        if (rangeSearchChunk.chapter === chapterRange.chapter && rangeSearchChunk.endChapter === chapterRange.endChapter) {
          return rangeSearchChunk.verse >= chapterRange.verse && rangeSearchChunk.endVerse <= chapterRange.endVerse;
        }
        if (rangeSearchChunk.chapter === chapterRange.chapter) {
          return rangeSearchChunk.verse >= chapterRange.verse;
        }
        if (rangeSearchChunk.endChapter === chapterRange.endChapter) {
          return rangeSearchChunk.endVerse <= chapterRange.endVerse;
        }
        return true;
      } else
        return true;
    }
    return false;
  } else {
    if (rangeSearchChunk.endChapter < chapterRange.chapter || rangeSearchChunk.chapter > chapterRange.endChapter) {
      return false;
    }
    if (rangeSearchChunk.endChapter === chapterRange.chapter) {
      if (!chapterRange.verse) {
        return true;
      }
      if (rangeSearchChunk.endVerse < chapterRange.verse) {
        return false;
      }
    }
    if (rangeSearchChunk.chapter === chapterRange.endChapter) {
      if (!chapterRange.verse) {
        return true;
      }
      if (rangeSearchChunk.verse > chapterRange.endVerse) {
        return false;
      }
    }
    return true;
  }
}
function chapterVerseRangeContainedInChapterRange(chapterRange, chapterSearchChunk, strict) {
  if (strict) {
    if (chapterSearchChunk.chapter === chapterRange.chapter) {
      return chapterSearchChunk.verse >= chapterRange.verse;
    }
    if (chapterSearchChunk.chapter === chapterRange.endChapter) {
      return chapterSearchChunk.endVerse <= chapterRange.endVerse;
    }
    return true;
  } else {
    if (chapterSearchChunk.chapter > chapterRange.endChapter || chapterSearchChunk.chapter < chapterRange.chapter) {
      return false;
    }
    if (chapterSearchChunk.chapter === chapterRange.endChapter) {
      if (!chapterRange.verse) {
        return true;
      }
      if (chapterSearchChunk.verse > chapterRange.endVerse) {
        return false;
      }
    }
    if (chapterSearchChunk.chapter === chapterRange.chapter) {
      if (!chapterRange.verse) {
        return true;
      }
      if (chapterSearchChunk.endVerse < chapterRange.verse) {
        return false;
      }
    }
    return true;
  }
}
(function(exports) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof2(obj);
  }
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "cleanupReference", {
    enumerable: true,
    get: function get() {
      return referenceHelpers$1.cleanupReference;
    }
  });
  Object.defineProperty(exports, "doesReferenceContain", {
    enumerable: true,
    get: function get() {
      return _doesReferenceContain.doesReferenceContain;
    }
  });
  Object.defineProperty(exports, "getVerses", {
    enumerable: true,
    get: function get() {
      return referenceHelpers$1.getVerses;
    }
  });
  Object.defineProperty(exports, "parseReferenceToList", {
    enumerable: true,
    get: function get() {
      return referenceHelpers$1.parseReferenceToList;
    }
  });
  exports.referenceHelpers = void 0;
  var referenceHelpers$1 = _interopRequireWildcard(referenceHelpers);
  exports.referenceHelpers = referenceHelpers$1;
  var _doesReferenceContain = doesReferenceContain$1;
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj["default"] = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
})(dist);
var setBook = function setBook2(bookData, ref) {
  var Book = /* @__PURE__ */ function() {
    function Book2(verses) {
      _classCallCheck(this, Book2);
      this.verses = verses;
    }
    _createClass(Book2, [{
      key: "forEachVerse",
      value: function forEachVerse() {
        var callback = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(verseObjects2, verseRef2) {
          return null;
        };
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          failOnMissingVerse: true
        }, _ref$failOnMissingVer = _ref.failOnMissingVerse, failOnMissingVerse = _ref$failOnMissingVer === void 0 ? true : _ref$failOnMissingVer;
        var verseRefs = this.verses;
        var _iterator = _createForOfIteratorHelper$2(verseRefs), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var verseRef = _step.value;
            if (!verseRef.verseData && failOnMissingVerse) {
              return null;
            }
            var verseData = verseRef.verseData;
            var verseObjects = void 0;
            if (verseData) {
              if (typeof verseData === "string") {
                verseObjects = [{
                  text: verseData
                }];
              } else if (Array.isArray(verseData)) {
                verseObjects = verseData;
              } else if (verseData.verseObjects) {
                verseObjects = verseData.verseObjects;
              }
              callback(verseObjects, verseRef);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }]);
    return Book2;
  }();
  return new Book(dist.getVerses(bookData, ref));
};
function verseObjectsToString(verseObjects, map2) {
  return verseObjects.map(function(verseObject, index) {
    var previousVerseObject = verseObjects[index - 1];
    if (previousVerseObject && previousVerseObject.children) {
      var _previousVerseObject = previousVerseObject, children = _previousVerseObject.children;
      previousVerseObject = children[children.length - 1];
      if (previousVerseObject.children) {
        var grandChildren = previousVerseObject.children;
        previousVerseObject = grandChildren[grandChildren.length - 1];
      }
    }
    if (previousVerseObject && previousVerseObject.text === " " && verseObject.text === " ") {
      return "";
    }
    if (verseObject.text) {
      var text = verseObject.text;
      if (text.includes("\n")) {
        text = text.replace("\n", " ");
      }
      return map2 ? map2(text) : text;
    } else if (verseObject.children) {
      return verseObjectsToString(verseObject.children, map2);
    }
    return "";
  }).join("").replace(/ {2}/gi, " ").replace(/ , /gi, ", ").replace(/ ."/gi, '."').replace(/ ’./gi, "’.").replace(/ ; /gi, "; ").replace(/\s+([?])/gi, "$1").trimLeft();
}
var refToString = function refToString2(_ref2) {
  var chapter = _ref2.chapter, verse = _ref2.verse;
  return "".concat(chapter, ":").concat(verse);
};
function getParsedUSFM(usfmData) {
  try {
    if (usfmData) {
      return toJSON(usfmData, {
        convertToInt: ["occurrence", "occurrences"]
      });
    }
  } catch (e) {
    console.error(e);
  }
}
/*!
 * XRegExp 5.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2007-present MIT License
 */
var REGEX_DATA = "xregexp";
var features = {
  astral: false,
  namespacing: true
};
var fixed = {};
var regexCache = {};
var patternCache = {};
var tokens = [];
var defaultScope = "default";
var classScope = "class";
var nativeTokens = {
  // Any native multicharacter token in default scope, or any single character
  "default": /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
  // Any native multicharacter token in character class scope, or any single character
  "class": /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
};
var replacementToken = /\$(?:\{([^\}]+)\}|<([^>]+)>|(\d\d?|[\s\S]?))/g;
var correctExecNpcg = /()??/.exec("")[1] === void 0;
var hasFlagsProp = /x/.flags !== void 0;
function hasNativeFlag(flag) {
  var isSupported = true;
  try {
    new RegExp("", flag);
    if (flag === "y") {
      var gy = function() {
        return "gy";
      }();
      var incompleteY = ".a".replace(new RegExp("a", gy), ".") === "..";
      if (incompleteY) {
        isSupported = false;
      }
    }
  } catch (exception) {
    isSupported = false;
  }
  return isSupported;
}
var hasNativeD = hasNativeFlag("d");
var hasNativeS = hasNativeFlag("s");
var hasNativeU = hasNativeFlag("u");
var hasNativeY = hasNativeFlag("y");
var registeredFlags = {
  d: hasNativeD,
  g: true,
  i: true,
  m: true,
  s: hasNativeS,
  u: hasNativeU,
  y: hasNativeY
};
var nonnativeFlags = hasNativeS ? /[^dgimsuy]+/g : /[^dgimuy]+/g;
function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
  regex[REGEX_DATA] = {
    captureNames
  };
  if (isInternalOnly) {
    return regex;
  }
  if (regex.__proto__) {
    regex.__proto__ = XRegExp.prototype;
  } else {
    for (var p in XRegExp.prototype) {
      regex[p] = XRegExp.prototype[p];
    }
  }
  regex[REGEX_DATA].source = xSource;
  regex[REGEX_DATA].flags = xFlags ? xFlags.split("").sort().join("") : xFlags;
  return regex;
}
function clipDuplicates(str) {
  return str.replace(/([\s\S])(?=[\s\S]*\1)/g, "");
}
function copyRegex(regex, options) {
  if (!XRegExp.isRegExp(regex)) {
    throw new TypeError("Type RegExp expected");
  }
  var xData = regex[REGEX_DATA] || {};
  var flags2 = getNativeFlags(regex);
  var flagsToAdd = "";
  var flagsToRemove = "";
  var xregexpSource = null;
  var xregexpFlags = null;
  options = options || {};
  if (options.removeG) {
    flagsToRemove += "g";
  }
  if (options.removeY) {
    flagsToRemove += "y";
  }
  if (flagsToRemove) {
    flags2 = flags2.replace(new RegExp("[".concat(flagsToRemove, "]+"), "g"), "");
  }
  if (options.addG) {
    flagsToAdd += "g";
  }
  if (options.addY) {
    flagsToAdd += "y";
  }
  if (flagsToAdd) {
    flags2 = clipDuplicates(flags2 + flagsToAdd);
  }
  if (!options.isInternalOnly) {
    if (xData.source !== void 0) {
      xregexpSource = xData.source;
    }
    if (xData.flags != null) {
      xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
    }
  }
  regex = augment(new RegExp(options.source || regex.source, flags2), hasNamedCapture(regex) ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);
  return regex;
}
function dec(hex2) {
  return parseInt(hex2, 16);
}
function getContextualTokenSeparator(match, scope, flags2) {
  var matchEndPos = match.index + match[0].length;
  var precedingChar = match.input[match.index - 1];
  var followingChar = match.input[matchEndPos];
  if (
    // No need to separate tokens if at the beginning or end of a group, before or after a
    // group, or before or after a `|`
    /^[()|]$/.test(precedingChar) || /^[()|]$/.test(followingChar) || // No need to separate tokens if at the beginning or end of the pattern
    match.index === 0 || matchEndPos === match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookaround.
    // Looks only at the last 4 chars (at most) for perf when constructing long regexes.
    /\(\?(?:[:=!]|<[=!])$/.test(match.input.substring(match.index - 4, match.index)) || // Avoid separating tokens when the following token is a quantifier
    isQuantifierNext(match.input, matchEndPos, flags2)
  ) {
    return "";
  }
  return "(?:)";
}
function getNativeFlags(regex) {
  return hasFlagsProp ? regex.flags : (
    // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
    // with an empty string) allows this to continue working predictably when
    // `XRegExp.proptotype.toString` is overridden
    /\/([a-z]*)$/i.exec(RegExp.prototype.toString.call(regex))[1]
  );
}
function hasNamedCapture(regex) {
  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
}
function hex(dec2) {
  return parseInt(dec2, 10).toString(16);
}
function isQuantifierNext(pattern, pos, flags2) {
  var inlineCommentPattern = "\\(\\?#[^)]*\\)";
  var lineCommentPattern = "#[^#\\n]*";
  var quantifierPattern = "[?*+]|{\\d+(?:,\\d*)?}";
  var regex = flags2.includes("x") ? (
    // Ignore any leading whitespace, line comments, and inline comments
    new RegExp("^(?:\\s|".concat(lineCommentPattern, "|").concat(inlineCommentPattern, ")*(?:").concat(quantifierPattern, ")"))
  ) : (
    // Ignore any leading inline comments
    new RegExp("^(?:".concat(inlineCommentPattern, ")*(?:").concat(quantifierPattern, ")"))
  );
  return regex.test(pattern.slice(pos));
}
function isType(value, type) {
  return Object.prototype.toString.call(value) === "[object ".concat(type, "]");
}
function nullThrows(value) {
  if (value == null) {
    throw new TypeError("Cannot convert null or undefined to object");
  }
  return value;
}
function pad4(str) {
  while (str.length < 4) {
    str = "0".concat(str);
  }
  return str;
}
function prepareFlags(pattern, flags2) {
  if (clipDuplicates(flags2) !== flags2) {
    throw new SyntaxError("Invalid duplicate regex flag ".concat(flags2));
  }
  pattern = pattern.replace(/^\(\?([\w$]+)\)/, function($0, $1) {
    if (/[dgy]/.test($1)) {
      throw new SyntaxError("Cannot use flags dgy in mode modifier ".concat($0));
    }
    flags2 = clipDuplicates(flags2 + $1);
    return "";
  });
  var _iterator = _createForOfIteratorHelper$2(flags2), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var flag = _step.value;
      if (!registeredFlags[flag]) {
        throw new SyntaxError("Unknown regex flag ".concat(flag));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    pattern,
    flags: flags2
  };
}
function prepareOptions(value) {
  var options = {};
  if (isType(value, "String")) {
    XRegExp.forEach(value, /[^\s,]+/, function(match) {
      options[match] = true;
    });
    return options;
  }
  return value;
}
function registerFlag(flag) {
  if (!/^[\w$]$/.test(flag)) {
    throw new Error("Flag must be a single character A-Za-z0-9_$");
  }
  registeredFlags[flag] = true;
}
function runTokens(pattern, flags2, pos, scope, context) {
  var i = tokens.length;
  var leadChar = pattern[pos];
  var result = null;
  var match;
  var t;
  while (i--) {
    t = tokens[i];
    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== "all" || t.flag && !flags2.includes(t.flag)) {
      continue;
    }
    match = XRegExp.exec(pattern, t.regex, pos, "sticky");
    if (match) {
      result = {
        matchLength: match[0].length,
        output: t.handler.call(context, match, scope, flags2),
        reparse: t.reparse
      };
      break;
    }
  }
  return result;
}
function setAstral(on) {
  features.astral = on;
}
function setNamespacing(on) {
  features.namespacing = on;
}
function XRegExp(pattern, flags2) {
  if (XRegExp.isRegExp(pattern)) {
    if (flags2 !== void 0) {
      throw new TypeError("Cannot supply flags when copying a RegExp");
    }
    return copyRegex(pattern);
  }
  pattern = pattern === void 0 ? "" : String(pattern);
  flags2 = flags2 === void 0 ? "" : String(flags2);
  if (XRegExp.isInstalled("astral") && !flags2.includes("A")) {
    flags2 += "A";
  }
  if (!patternCache[pattern]) {
    patternCache[pattern] = {};
  }
  if (!patternCache[pattern][flags2]) {
    var context = {
      hasNamedCapture: false,
      captureNames: []
    };
    var scope = defaultScope;
    var output = "";
    var pos = 0;
    var result;
    var applied = prepareFlags(pattern, flags2);
    var appliedPattern = applied.pattern;
    var appliedFlags = applied.flags;
    while (pos < appliedPattern.length) {
      do {
        result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
        if (result && result.reparse) {
          appliedPattern = appliedPattern.slice(0, pos) + result.output + appliedPattern.slice(pos + result.matchLength);
        }
      } while (result && result.reparse);
      if (result) {
        output += result.output;
        pos += result.matchLength || 1;
      } else {
        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, "sticky"), _XRegExp$exec2 = _slicedToArray$1(_XRegExp$exec, 1), token = _XRegExp$exec2[0];
        output += token;
        pos += token.length;
        if (token === "[" && scope === defaultScope) {
          scope = classScope;
        } else if (token === "]" && scope === classScope) {
          scope = defaultScope;
        }
      }
    }
    patternCache[pattern][flags2] = {
      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
      // groups are sometimes inserted during regex transpilation in order to keep tokens
      // separated. However, more than one empty group in a row is never needed.
      pattern: output.replace(/(?:\(\?:\))+/g, "(?:)"),
      // Strip all but native flags
      flags: appliedFlags.replace(nonnativeFlags, ""),
      // `context.captureNames` has an item for each capturing group, even if unnamed
      captures: context.hasNamedCapture ? context.captureNames : null
    };
  }
  var generated = patternCache[pattern][flags2];
  return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags2);
}
XRegExp.prototype = new RegExp();
XRegExp.version = "5.1.1";
XRegExp._clipDuplicates = clipDuplicates;
XRegExp._hasNativeFlag = hasNativeFlag;
XRegExp._dec = dec;
XRegExp._hex = hex;
XRegExp._pad4 = pad4;
XRegExp.addToken = function(regex, handler, options) {
  options = options || {};
  var _options = options, optionalFlags = _options.optionalFlags;
  if (options.flag) {
    registerFlag(options.flag);
  }
  if (optionalFlags) {
    optionalFlags = optionalFlags.split("");
    var _iterator2 = _createForOfIteratorHelper$2(optionalFlags), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var flag = _step2.value;
        registerFlag(flag);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  tokens.push({
    regex: copyRegex(regex, {
      addG: true,
      addY: hasNativeY,
      isInternalOnly: true
    }),
    handler,
    scope: options.scope || defaultScope,
    flag: options.flag,
    reparse: options.reparse,
    leadChar: options.leadChar
  });
  XRegExp.cache.flush("patterns");
};
XRegExp.cache = function(pattern, flags2) {
  if (!regexCache[pattern]) {
    regexCache[pattern] = {};
  }
  return regexCache[pattern][flags2] || (regexCache[pattern][flags2] = XRegExp(pattern, flags2));
};
XRegExp.cache.flush = function(cacheName) {
  if (cacheName === "patterns") {
    patternCache = {};
  } else {
    regexCache = {};
  }
};
XRegExp.escape = function(str) {
  return String(nullThrows(str)).replace(/[\\\[\]{}()*+?.^$|]/g, "\\$&").replace(/[\s#\-,]/g, function(match) {
    return "\\u".concat(pad4(hex(match.charCodeAt(0))));
  });
};
XRegExp.exec = function(str, regex, pos, sticky) {
  var cacheKey = "g";
  var addY = false;
  var fakeY = false;
  var match;
  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);
  if (addY) {
    cacheKey += "y";
  } else if (sticky) {
    fakeY = true;
    cacheKey += "FakeY";
  }
  regex[REGEX_DATA] = regex[REGEX_DATA] || {};
  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
    addG: true,
    addY,
    source: fakeY ? "".concat(regex.source, "|()") : void 0,
    removeY: sticky === false,
    isInternalOnly: true
  }));
  pos = pos || 0;
  r2.lastIndex = pos;
  match = fixed.exec.call(r2, str);
  if (fakeY && match && match.pop() === "") {
    match = null;
  }
  if (regex.global) {
    regex.lastIndex = match ? r2.lastIndex : 0;
  }
  return match;
};
XRegExp.forEach = function(str, regex, callback) {
  var pos = 0;
  var i = -1;
  var match;
  while (match = XRegExp.exec(str, regex, pos)) {
    callback(match, ++i, str, regex);
    pos = match.index + (match[0].length || 1);
  }
};
XRegExp.globalize = function(regex) {
  return copyRegex(regex, {
    addG: true
  });
};
XRegExp.install = function(options) {
  options = prepareOptions(options);
  if (!features.astral && options.astral) {
    setAstral(true);
  }
  if (!features.namespacing && options.namespacing) {
    setNamespacing(true);
  }
};
XRegExp.isInstalled = function(feature) {
  return !!features[feature];
};
XRegExp.isRegExp = function(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
};
XRegExp.match = function(str, regex, scope) {
  var global2 = regex.global && scope !== "one" || scope === "all";
  var cacheKey = (global2 ? "g" : "") + (regex.sticky ? "y" : "") || "noGY";
  regex[REGEX_DATA] = regex[REGEX_DATA] || {};
  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
    addG: !!global2,
    removeG: scope === "one",
    isInternalOnly: true
  }));
  var result = String(nullThrows(str)).match(r2);
  if (regex.global) {
    regex.lastIndex = scope === "one" && result ? (
      // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
      result.index + result[0].length
    ) : 0;
  }
  return global2 ? result || [] : result && result[0];
};
XRegExp.matchChain = function(str, chain) {
  return function recurseChain(values, level) {
    var item = chain[level].regex ? chain[level] : {
      regex: chain[level]
    };
    var matches = [];
    function addMatch(match) {
      if (item.backref) {
        var ERR_UNDEFINED_GROUP = "Backreference to undefined group: ".concat(item.backref);
        var isNamedBackref = isNaN(item.backref);
        if (isNamedBackref && XRegExp.isInstalled("namespacing")) {
          if (!(match.groups && item.backref in match.groups)) {
            throw new ReferenceError(ERR_UNDEFINED_GROUP);
          }
        } else if (!match.hasOwnProperty(item.backref)) {
          throw new ReferenceError(ERR_UNDEFINED_GROUP);
        }
        var backrefValue = isNamedBackref && XRegExp.isInstalled("namespacing") ? match.groups[item.backref] : match[item.backref];
        matches.push(backrefValue || "");
      } else {
        matches.push(match[0]);
      }
    }
    var _iterator3 = _createForOfIteratorHelper$2(values), _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
        var value = _step3.value;
        XRegExp.forEach(value, item.regex, addMatch);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);
  }([str], 0);
};
XRegExp.replace = function(str, search, replacement2, scope) {
  var isRegex = XRegExp.isRegExp(search);
  var global2 = search.global && scope !== "one" || scope === "all";
  var cacheKey = (global2 ? "g" : "") + (search.sticky ? "y" : "") || "noGY";
  var s2 = search;
  if (isRegex) {
    search[REGEX_DATA] = search[REGEX_DATA] || {};
    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
      addG: !!global2,
      removeG: scope === "one",
      isInternalOnly: true
    }));
  } else if (global2) {
    s2 = new RegExp(XRegExp.escape(String(search)), "g");
  }
  var result = fixed.replace.call(nullThrows(str), s2, replacement2);
  if (isRegex && search.global) {
    search.lastIndex = 0;
  }
  return result;
};
XRegExp.replaceEach = function(str, replacements) {
  var _iterator4 = _createForOfIteratorHelper$2(replacements), _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
      var r = _step4.value;
      str = XRegExp.replace(str, r[0], r[1], r[2]);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return str;
};
XRegExp.split = function(str, separator, limit) {
  return fixed.split.call(nullThrows(str), separator, limit);
};
XRegExp.test = function(str, regex, pos, sticky) {
  return !!XRegExp.exec(str, regex, pos, sticky);
};
XRegExp.uninstall = function(options) {
  options = prepareOptions(options);
  if (features.astral && options.astral) {
    setAstral(false);
  }
  if (features.namespacing && options.namespacing) {
    setNamespacing(false);
  }
};
XRegExp.union = function(patterns, flags2, options) {
  options = options || {};
  var conjunction = options.conjunction || "or";
  var numCaptures = 0;
  var numPriorCaptures;
  var captureNames;
  function rewrite(match, paren, backref) {
    var name = captureNames[numCaptures - numPriorCaptures];
    if (paren) {
      ++numCaptures;
      if (name) {
        return "(?<".concat(name, ">");
      }
    } else if (backref) {
      return "\\".concat(+backref + numPriorCaptures);
    }
    return match;
  }
  if (!(isType(patterns, "Array") && patterns.length)) {
    throw new TypeError("Must provide a nonempty array of patterns to merge");
  }
  var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
  var output = [];
  var _iterator5 = _createForOfIteratorHelper$2(patterns), _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
      var pattern = _step5.value;
      if (XRegExp.isRegExp(pattern)) {
        numPriorCaptures = numCaptures;
        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || [];
        output.push(XRegExp(pattern.source).source.replace(parts, rewrite));
      } else {
        output.push(XRegExp.escape(pattern));
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  var separator = conjunction === "none" ? "" : "|";
  return XRegExp(output.join(separator), flags2);
};
fixed.exec = function(str) {
  var origLastIndex = this.lastIndex;
  var match = RegExp.prototype.exec.apply(this, arguments);
  if (match) {
    if (!correctExecNpcg && match.length > 1 && match.includes("")) {
      var r2 = copyRegex(this, {
        removeG: true,
        isInternalOnly: true
      });
      String(str).slice(match.index).replace(r2, function() {
        var len = arguments.length;
        for (var i2 = 1; i2 < len - 2; ++i2) {
          if ((i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]) === void 0) {
            match[i2] = void 0;
          }
        }
      });
    }
    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
      var groupsObject = match;
      if (XRegExp.isInstalled("namespacing")) {
        match.groups = /* @__PURE__ */ Object.create(null);
        groupsObject = match.groups;
      }
      for (var i = 1; i < match.length; ++i) {
        var name = this[REGEX_DATA].captureNames[i - 1];
        if (name) {
          groupsObject[name] = match[i];
        }
      }
    } else if (!match.groups && XRegExp.isInstalled("namespacing")) {
      match.groups = void 0;
    }
    if (this.global && !match[0].length && this.lastIndex > match.index) {
      this.lastIndex = match.index;
    }
  }
  if (!this.global) {
    this.lastIndex = origLastIndex;
  }
  return match;
};
fixed.test = function(str) {
  return !!fixed.exec.call(this, str);
};
fixed.match = function(regex) {
  if (!XRegExp.isRegExp(regex)) {
    regex = new RegExp(regex);
  } else if (regex.global) {
    var result = String.prototype.match.apply(this, arguments);
    regex.lastIndex = 0;
    return result;
  }
  return fixed.exec.call(regex, nullThrows(this));
};
fixed.replace = function(search, replacement2) {
  var isRegex = XRegExp.isRegExp(search);
  var origLastIndex;
  var captureNames;
  var result;
  if (isRegex) {
    if (search[REGEX_DATA]) {
      captureNames = search[REGEX_DATA].captureNames;
    }
    origLastIndex = search.lastIndex;
  } else {
    search += "";
  }
  if (isType(replacement2, "Function")) {
    result = String(this).replace(search, function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (captureNames) {
        var groupsObject;
        if (XRegExp.isInstalled("namespacing")) {
          groupsObject = /* @__PURE__ */ Object.create(null);
          args.push(groupsObject);
        } else {
          args[0] = new String(args[0]);
          groupsObject = args[0];
        }
        for (var i = 0; i < captureNames.length; ++i) {
          if (captureNames[i]) {
            groupsObject[captureNames[i]] = args[i + 1];
          }
        }
      }
      return replacement2.apply(void 0, args);
    });
  } else {
    result = String(nullThrows(this)).replace(search, function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return String(replacement2).replace(replacementToken, replacer);
      function replacer($0, bracketed, angled, dollarToken) {
        bracketed = bracketed || angled;
        var numNonCaptureArgs = isType(args[args.length - 1], "Object") ? 4 : 3;
        var numCaptures = args.length - numNonCaptureArgs;
        if (bracketed) {
          if (/^\d+$/.test(bracketed)) {
            var _n = +bracketed;
            if (_n <= numCaptures) {
              return args[_n] || "";
            }
          }
          var n = captureNames ? captureNames.indexOf(bracketed) : -1;
          if (n < 0) {
            throw new SyntaxError("Backreference to undefined group ".concat($0));
          }
          return args[n + 1] || "";
        }
        if (dollarToken === "" || dollarToken === " ") {
          throw new SyntaxError("Invalid token ".concat($0));
        }
        if (dollarToken === "&" || +dollarToken === 0) {
          return args[0];
        }
        if (dollarToken === "$") {
          return "$";
        }
        if (dollarToken === "`") {
          return args[args.length - 1].slice(0, args[args.length - 2]);
        }
        if (dollarToken === "'") {
          return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
        }
        dollarToken = +dollarToken;
        if (!isNaN(dollarToken)) {
          if (dollarToken > numCaptures) {
            throw new SyntaxError("Backreference to undefined group ".concat($0));
          }
          return args[dollarToken] || "";
        }
        throw new SyntaxError("Invalid token ".concat($0));
      }
    });
  }
  if (isRegex) {
    if (search.global) {
      search.lastIndex = 0;
    } else {
      search.lastIndex = origLastIndex;
    }
  }
  return result;
};
fixed.split = function(separator, limit) {
  if (!XRegExp.isRegExp(separator)) {
    return String.prototype.split.apply(this, arguments);
  }
  var str = String(this);
  var output = [];
  var origLastIndex = separator.lastIndex;
  var lastLastIndex = 0;
  var lastLength;
  limit = (limit === void 0 ? -1 : limit) >>> 0;
  XRegExp.forEach(str, separator, function(match) {
    if (match.index + match[0].length > lastLastIndex) {
      output.push(str.slice(lastLastIndex, match.index));
      if (match.length > 1 && match.index < str.length) {
        Array.prototype.push.apply(output, match.slice(1));
      }
      lastLength = match[0].length;
      lastLastIndex = match.index + lastLength;
    }
  });
  if (lastLastIndex === str.length) {
    if (!separator.test("") || lastLength) {
      output.push("");
    }
  } else {
    output.push(str.slice(lastLastIndex));
  }
  separator.lastIndex = origLastIndex;
  return output.length > limit ? output.slice(0, limit) : output;
};
XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function(match, scope) {
  if (match[1] === "B" && scope === defaultScope) {
    return match[0];
  }
  throw new SyntaxError("Invalid escape ".concat(match[0]));
}, {
  scope: "all",
  leadChar: "\\"
});
XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function(match, scope, flags2) {
  var code = dec(match[1]);
  if (code > 1114111) {
    throw new SyntaxError("Invalid Unicode code point ".concat(match[0]));
  }
  if (code <= 65535) {
    return "\\u".concat(pad4(hex(code)));
  }
  if (hasNativeU && flags2.includes("u")) {
    return match[0];
  }
  throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u");
}, {
  scope: "all",
  leadChar: "\\"
});
XRegExp.addToken(/\(\?#[^)]*\)/, getContextualTokenSeparator, {
  leadChar: "("
});
XRegExp.addToken(/\s+|#[^\n]*\n?/, getContextualTokenSeparator, {
  flag: "x"
});
if (!hasNativeS) {
  XRegExp.addToken(/\./, function() {
    return "[\\s\\S]";
  }, {
    flag: "s",
    leadChar: "."
  });
}
XRegExp.addToken(/\\k<([^>]+)>/, function(match) {
  var index = isNaN(match[1]) ? this.captureNames.indexOf(match[1]) + 1 : +match[1];
  var endIndex = match.index + match[0].length;
  if (!index || index > this.captureNames.length) {
    throw new SyntaxError("Backreference to undefined group ".concat(match[0]));
  }
  return "\\".concat(index).concat(endIndex === match.input.length || isNaN(match.input[endIndex]) ? "" : "(?:)");
}, {
  leadChar: "\\"
});
XRegExp.addToken(/\\(\d+)/, function(match, scope) {
  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== "0") {
    throw new SyntaxError("Cannot use octal escape or backreference to undefined group ".concat(match[0]));
  }
  return match[0];
}, {
  scope: "all",
  leadChar: "\\"
});
XRegExp.addToken(/\(\?P?<((?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[\$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u0870-\u0887\u0889-\u088E\u0898-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1715\u171F-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B4C\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA827\uA82C\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDD30-\uDD39\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDEFD-\uDF1C\uDF27\uDF30-\uDF50\uDF70-\uDF85\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC66-\uDC75\uDC7F-\uDCBA\uDCC2\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD47\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDCE-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E-\uDE41\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E-\uDC61\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF39\uDF40-\uDF46]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCE9\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD43\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDF00-\uDF10\uDF12-\uDF3A\uDF3E-\uDF42\uDF50-\uDF59\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC40-\uDC55]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFE4\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC30-\uDC6D\uDC8F\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAE\uDEC0-\uDEF9]|\uD839[\uDCD0-\uDCF9\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]|\uDB40[\uDD00-\uDDEF])*)>/, function(match) {
  if (!XRegExp.isInstalled("namespacing") && (match[1] === "length" || match[1] === "__proto__")) {
    throw new SyntaxError("Cannot use reserved word as capture name ".concat(match[0]));
  }
  if (this.captureNames.includes(match[1])) {
    throw new SyntaxError("Cannot use same name for multiple groups ".concat(match[0]));
  }
  this.captureNames.push(match[1]);
  this.hasNamedCapture = true;
  return "(";
}, {
  leadChar: "("
});
XRegExp.addToken(/\((?!\?)/, function(match, scope, flags2) {
  if (flags2.includes("n")) {
    return "(?:";
  }
  this.captureNames.push(null);
  return "(";
}, {
  optionalFlags: "n",
  leadChar: "("
});
/*!
 * XRegExp.build 5.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2012-present MIT License
 */
const build = function(XRegExp2) {
  var REGEX_DATA2 = "xregexp";
  var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
  var parts = XRegExp2.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], "g", {
    conjunction: "or"
  });
  function deanchor(pattern) {
    var leadingAnchor = /^(?:\(\?:\))*\^/;
    var trailingAnchor = /\$(?:\(\?:\))*$/;
    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped
    trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ""))) {
      return pattern.replace(leadingAnchor, "").replace(trailingAnchor, "");
    }
    return pattern;
  }
  function asXRegExp(value, addFlagX) {
    var flags2 = addFlagX ? "x" : "";
    return XRegExp2.isRegExp(value) ? value[REGEX_DATA2] && value[REGEX_DATA2].captureNames ? (
      // Don't recompile, to preserve capture names
      value
    ) : (
      // Recompile as XRegExp
      XRegExp2(value.source, flags2)
    ) : (
      // Compile string as XRegExp
      XRegExp2(value, flags2)
    );
  }
  function interpolate(substitution) {
    return substitution instanceof RegExp ? substitution : XRegExp2.escape(substitution);
  }
  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {
    subpatterns["subpattern".concat(subpatternIndex)] = interpolated;
    return subpatterns;
  }
  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {
    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;
    return raw + (hasSubpattern ? "{{subpattern".concat(subpatternIndex, "}}") : "");
  }
  XRegExp2.tag = function(flags2) {
    return function(literals) {
      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        substitutions[_key - 1] = arguments[_key];
      }
      var subpatterns = substitutions.map(interpolate).reduce(reduceToSubpatternsObject, {});
      var pattern = literals.raw.map(embedSubpatternAfter).join("");
      return XRegExp2.build(pattern, subpatterns, flags2);
    };
  };
  XRegExp2.build = function(pattern, subs, flags2) {
    flags2 = flags2 || "";
    var addFlagX = flags2.includes("x");
    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
    if (inlineFlags) {
      flags2 = XRegExp2._clipDuplicates(flags2 + inlineFlags[1]);
    }
    var data2 = {};
    for (var p in subs) {
      if (subs.hasOwnProperty(p)) {
        var sub = asXRegExp(subs[p], addFlagX);
        data2[p] = {
          // Deanchoring allows embedding independently useful anchored regexes. If you
          // really need to keep your anchors, double them (i.e., `^^...$$`).
          pattern: deanchor(sub.source),
          names: sub[REGEX_DATA2].captureNames || []
        };
      }
    }
    var patternAsRegex = asXRegExp(pattern, addFlagX);
    var numCaps = 0;
    var numPriorCaps;
    var numOuterCaps = 0;
    var outerCapsMap = [0];
    var outerCapNames = patternAsRegex[REGEX_DATA2].captureNames || [];
    var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
      var subName = $1 || $2;
      var capName;
      var intro;
      var localCapIndex;
      if (subName) {
        if (!data2.hasOwnProperty(subName)) {
          throw new ReferenceError("Undefined property ".concat($0));
        }
        if ($1) {
          capName = outerCapNames[numOuterCaps];
          outerCapsMap[++numOuterCaps] = ++numCaps;
          intro = "(?<".concat(capName || subName, ">");
        } else {
          intro = "(?:";
        }
        numPriorCaps = numCaps;
        var rewrittenSubpattern = data2[subName].pattern.replace(subParts, function(match, paren, backref) {
          if (paren) {
            capName = data2[subName].names[numCaps - numPriorCaps];
            ++numCaps;
            if (capName) {
              return "(?<".concat(capName, ">");
            }
          } else if (backref) {
            localCapIndex = +backref - 1;
            return data2[subName].names[localCapIndex] ? (
              // Need to preserve the backreference name in case using flag `n`
              "\\k<".concat(data2[subName].names[localCapIndex], ">")
            ) : "\\".concat(+backref + numPriorCaps);
          }
          return match;
        });
        return "".concat(intro).concat(rewrittenSubpattern, ")");
      }
      if ($3) {
        capName = outerCapNames[numOuterCaps];
        outerCapsMap[++numOuterCaps] = ++numCaps;
        if (capName) {
          return "(?<".concat(capName, ">");
        }
      } else if ($4) {
        localCapIndex = +$4 - 1;
        return outerCapNames[localCapIndex] ? (
          // Need to preserve the backreference name in case using flag `n`
          "\\k<".concat(outerCapNames[localCapIndex], ">")
        ) : "\\".concat(outerCapsMap[+$4]);
      }
      return $0;
    });
    return XRegExp2(output, flags2);
  };
};
/*!
 * XRegExp.matchRecursive 5.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2009-present MIT License
 */
const matchRecursive = function(XRegExp2) {
  function row(name, value, start, end) {
    return {
      name,
      value,
      start,
      end
    };
  }
  XRegExp2.matchRecursive = function(str, left, right, flags2, options) {
    flags2 = flags2 || "";
    options = options || {};
    var global2 = flags2.includes("g");
    var sticky = flags2.includes("y");
    var basicFlags = flags2.replace(/y/g, "");
    left = XRegExp2(left, basicFlags);
    right = XRegExp2(right, basicFlags);
    var esc;
    var _options = options, escapeChar = _options.escapeChar;
    if (escapeChar) {
      if (escapeChar.length > 1) {
        throw new Error("Cannot use more than one escape character");
      }
      escapeChar = XRegExp2.escape(escapeChar);
      esc = new RegExp(
        "(?:".concat(escapeChar, "[\\S\\s]|(?:(?!").concat(
          // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
          // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
          // transformation resulting from those flags was already applied to `left` and
          // `right` when they were passed through the XRegExp constructor above.
          XRegExp2.union([left, right], "", {
            conjunction: "or"
          }).source,
          ")[^"
        ).concat(escapeChar, "])+)+"),
        // Flags `dgy` not needed here
        flags2.replace(XRegExp2._hasNativeFlag("s") ? /[^imsu]/g : /[^imu]/g, "")
      );
    }
    var openTokens = 0;
    var delimStart = 0;
    var delimEnd = 0;
    var lastOuterEnd = 0;
    var outerStart;
    var innerStart;
    var leftMatch;
    var rightMatch;
    var vN = options.valueNames;
    var output = [];
    while (true) {
      if (escapeChar) {
        delimEnd += (XRegExp2.exec(str, esc, delimEnd, "sticky") || [""])[0].length;
      }
      leftMatch = XRegExp2.exec(str, left, delimEnd);
      rightMatch = XRegExp2.exec(str, right, delimEnd);
      if (leftMatch && rightMatch) {
        if (leftMatch.index <= rightMatch.index) {
          rightMatch = null;
        } else {
          leftMatch = null;
        }
      }
      if (leftMatch || rightMatch) {
        delimStart = (leftMatch || rightMatch).index;
        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
      } else if (!openTokens) {
        break;
      }
      if (sticky && !openTokens && delimStart > lastOuterEnd) {
        break;
      }
      if (leftMatch) {
        if (!openTokens) {
          outerStart = delimStart;
          innerStart = delimEnd;
        }
        openTokens += 1;
      } else if (rightMatch && openTokens) {
        openTokens -= 1;
        if (!openTokens) {
          if (vN) {
            if (vN[0] && outerStart > lastOuterEnd) {
              output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
            }
            if (vN[1]) {
              output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
            }
            if (vN[2]) {
              output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
            }
            if (vN[3]) {
              output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
            }
          } else {
            output.push(str.slice(innerStart, delimStart));
          }
          lastOuterEnd = delimEnd;
          if (!global2) {
            break;
          }
        }
      } else {
        var unbalanced = options.unbalanced || "error";
        if (unbalanced === "skip" || unbalanced === "skip-lazy") {
          if (rightMatch) {
            rightMatch = null;
          } else {
            if (unbalanced === "skip") {
              var outerStartDelimLength = XRegExp2.exec(str, left, outerStart, "sticky")[0].length;
              delimEnd = outerStart + (outerStartDelimLength || 1);
            } else {
              delimEnd = outerStart + 1;
            }
            openTokens = 0;
          }
        } else if (unbalanced === "error") {
          var delimSide = rightMatch ? "right" : "left";
          var errorPos = rightMatch ? delimStart : outerStart;
          throw new Error("Unbalanced ".concat(delimSide, " delimiter found in string at position ").concat(errorPos));
        } else {
          throw new Error("Unsupported value for unbalanced: ".concat(unbalanced));
        }
      }
      if (delimStart === delimEnd) {
        delimEnd += 1;
      }
    }
    if (global2 && output.length > 0 && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
      output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
    }
    return output;
  };
};
/*!
 * XRegExp Unicode Base 5.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2008-present MIT License
 */
const unicodeBase = function(XRegExp2) {
  var unicode = {};
  var unicodeTypes = {};
  var dec2 = XRegExp2._dec;
  var hex2 = XRegExp2._hex;
  var pad42 = XRegExp2._pad4;
  function normalize2(name) {
    return name.replace(/[- _]+/g, "").toLowerCase();
  }
  function charCode(chr) {
    var esc = /^\\[xu](.+)/.exec(chr);
    return esc ? dec2(esc[1]) : chr.charCodeAt(chr[0] === "\\" ? 1 : 0);
  }
  function invertBmp(range) {
    var output = "";
    var lastEnd = -1;
    XRegExp2.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function(m) {
      var start = charCode(m[1]);
      if (start > lastEnd + 1) {
        output += "\\u".concat(pad42(hex2(lastEnd + 1)));
        if (start > lastEnd + 2) {
          output += "-\\u".concat(pad42(hex2(start - 1)));
        }
      }
      lastEnd = charCode(m[2] || m[1]);
    });
    if (lastEnd < 65535) {
      output += "\\u".concat(pad42(hex2(lastEnd + 1)));
      if (lastEnd < 65534) {
        output += "-\\uFFFF";
      }
    }
    return output;
  }
  function cacheInvertedBmp(slug) {
    var prop = "b!";
    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));
  }
  function buildAstral(slug, isNegated) {
    var item = unicode[slug];
    var combined = "";
    if (item.bmp && !item.isBmpLast) {
      combined = "[".concat(item.bmp, "]").concat(item.astral ? "|" : "");
    }
    if (item.astral) {
      combined += item.astral;
    }
    if (item.isBmpLast && item.bmp) {
      combined += "".concat(item.astral ? "|" : "", "[").concat(item.bmp, "]");
    }
    return isNegated ? "(?:(?!".concat(combined, ")(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-￿]))") : "(?:".concat(combined, ")");
  }
  function cacheAstral(slug, isNegated) {
    var prop = isNegated ? "a!" : "a=";
    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));
  }
  XRegExp2.addToken(
    // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
    /\\([pP])(?:{(\^?)(?:(\w+)=)?([^}]*)}|([A-Za-z]))/,
    function(match, scope, flags2) {
      var ERR_DOUBLE_NEG = "Invalid double negation ";
      var ERR_UNKNOWN_NAME = "Unknown Unicode token ";
      var ERR_UNKNOWN_REF = "Unicode token missing data ";
      var ERR_ASTRAL_ONLY = "Astral mode required for Unicode token ";
      var ERR_ASTRAL_IN_CLASS = "Astral mode does not support Unicode tokens within character classes";
      var _match = _slicedToArray$1(match, 6), fullToken = _match[0], pPrefix = _match[1], caretNegation = _match[2], typePrefix = _match[3], tokenName = _match[4], tokenSingleCharName = _match[5];
      var isNegated = pPrefix === "P" || !!caretNegation;
      var isAstralMode = flags2.includes("A");
      var slug = normalize2(tokenSingleCharName || tokenName);
      var item = unicode[slug];
      if (pPrefix === "P" && caretNegation) {
        throw new SyntaxError(ERR_DOUBLE_NEG + fullToken);
      }
      if (!unicode.hasOwnProperty(slug)) {
        throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);
      }
      if (typePrefix) {
        if (!(unicodeTypes[typePrefix] && unicodeTypes[typePrefix][slug])) {
          throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);
        }
      }
      if (item.inverseOf) {
        slug = normalize2(item.inverseOf);
        if (!unicode.hasOwnProperty(slug)) {
          throw new ReferenceError("".concat(ERR_UNKNOWN_REF + fullToken, " -> ").concat(item.inverseOf));
        }
        item = unicode[slug];
        isNegated = !isNegated;
      }
      if (!(item.bmp || isAstralMode)) {
        throw new SyntaxError(ERR_ASTRAL_ONLY + fullToken);
      }
      if (isAstralMode) {
        if (scope === "class") {
          throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
        }
        return cacheAstral(slug, isNegated);
      }
      return scope === "class" ? isNegated ? cacheInvertedBmp(slug) : item.bmp : "".concat((isNegated ? "[^" : "[") + item.bmp, "]");
    },
    {
      scope: "all",
      optionalFlags: "A",
      leadChar: "\\"
    }
  );
  XRegExp2.addUnicodeData = function(data2, typePrefix) {
    var ERR_NO_NAME = "Unicode token requires name";
    var ERR_NO_DATA = "Unicode token has no character data ";
    if (typePrefix) {
      unicodeTypes[typePrefix] = {};
    }
    var _iterator = _createForOfIteratorHelper$2(data2), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var item = _step.value;
        if (!item.name) {
          throw new Error(ERR_NO_NAME);
        }
        if (!(item.inverseOf || item.bmp || item.astral)) {
          throw new Error(ERR_NO_DATA + item.name);
        }
        var normalizedName = normalize2(item.name);
        unicode[normalizedName] = item;
        if (typePrefix) {
          unicodeTypes[typePrefix][normalizedName] = true;
        }
        if (item.alias) {
          var normalizedAlias = normalize2(item.alias);
          unicode[normalizedAlias] = item;
          if (typePrefix) {
            unicodeTypes[typePrefix][normalizedAlias] = true;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    XRegExp2.cache.flush("patterns");
  };
  XRegExp2._getUnicodeProperty = function(name) {
    var slug = normalize2(name);
    return unicode[slug];
  };
};
var categories = [{
  "name": "C",
  "alias": "Other",
  "isBmpLast": true,
  "bmp": "\0--­͸͹΀-΃΋΍΢԰՗՘֋֌֐׈-׏׫-׮׵-؅؜۝܎܏݋݌޲-޿߻߼࠮࠯࠿࡜࡝࡟࡫-࡯࢏-ࢗ࣢঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥৿਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੷-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୔୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿఍఑఩఺఻౅౉౎-౔౗౛౜౞౟౤౥౰-౶಍಑಩಴಺಻೅೉೎-೔೗-೜೟೤೥೰ೳ-೿഍഑൅൉൐-൓൤൥඀඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅຋຤຦຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿᜖-᜞᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠎᠚-᠟᡹-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯᫏-᫿᭍-᭏᭿᯴-᯻᰸-᰺᱊-᱌Ᲊ-᲏᲻᲼᳈-᳏᳻-᳿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿​-‏‪-‮⁠-⁯⁲⁳₏₝-₟⃁-⃏⃱-⃿↌-↏␧-␿⑋-⑟⭴⭵⮖⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹞-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄㄰㆏㇤-㇯㈟꒍-꒏꓇-꓏꘬-꘿꛸-꛿Ɤ-꟏꟒꟔Ꟛ-꟱꠭-꠯꠺-꠿꡸-꡿꣆-꣍꣚-꣟꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭬-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯃-﯒﶐﶑﷈-﷎﷐-﷯︚-︟﹓﹧﹬-﹯﹵﻽-＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￻￾￿",
  "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDF6F\uDF8A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC76-\uDC7E\uDCBD\uDCC3-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEBA-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF47-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD832\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF3-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDEBF\uDECA-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD833[\uDC00-\uDEFF\uDF2E\uDF2F\uDF47-\uDF4F\uDFC4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDEB-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDE8F\uDEAF-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD839[\uDC00-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDC\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFEF\uDFF1-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7D-\uDE7F\uDE87-\uDE8F\uDEAD-\uDEAF\uDEBB-\uDEBF\uDEC6-\uDECF\uDEDA-\uDEDF\uDEE8-\uDEEF\uDEF7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF39-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]"
}, {
  "name": "Cc",
  "alias": "Control",
  "bmp": "\0--"
}, {
  "name": "Cf",
  "alias": "Format",
  "bmp": "­؀-؅؜۝܏࢐࢑࣢᠎​-‏‪-‮⁠-⁤⁦-⁯\uFEFF￹-￻",
  "astral": "\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC38]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]"
}, {
  "name": "Cn",
  "alias": "Unassigned",
  "bmp": "͸͹΀-΃΋΍΢԰՗՘֋֌֐׈-׏׫-׮׵-׿܎݋݌޲-޿߻߼࠮࠯࠿࡜࡝࡟࡫-࡯࢏࢒-ࢗ঄঍঎঑঒঩঱঳-঵঺঻৅৆৉৊৏-৖৘-৛৞৤৥৿਀਄਋-਎਑਒਩਱਴਷਺਻਽੃-੆੉੊੎-੐੒-੘੝੟-੥੷-઀઄઎઒઩઱઴઺઻૆૊૎૏૑-૟૤૥૲-૸଀଄଍଎଑଒଩଱଴଺଻୅୆୉୊୎-୔୘-୛୞୤୥୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉௎௏௑-௖௘-௥௻-௿఍఑఩఺఻౅౉౎-౔౗౛౜౞౟౤౥౰-౶಍಑಩಴಺಻೅೉೎-೔೗-೜೟೤೥೰ೳ-೿഍഑൅൉൐-൓൤൥඀඄඗-඙඲඼඾඿෇-෉෋-෎෕෗෠-෥෰෱෵-฀฻-฾๜-຀຃຅຋຤຦຾຿໅໇໎໏໚໛໠-໿཈཭-཰྘྽࿍࿛-࿿჆჈-჌჎჏቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛፜፽-፿᎚-᎟᏶᏷᏾᏿᚝-᚟᛹-᛿᜖-᜞᜷-᜿᝔-᝟᝭᝱᝴-᝿៞៟៪-៯៺-៿᠚-᠟᡹-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤼-᤿᥁-᥃᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧝᨜᨝᩟᩽᩾᪊-᪏᪚-᪟᪮᪯᫏-᫿᭍-᭏᭿᯴-᯻᰸-᰺᱊-᱌Ᲊ-᲏᲻᲼᳈-᳏᳻-᳿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵῅῔῕῜῰῱῵῿⁥⁲⁳₏₝-₟⃁-⃏⃱-⃿↌-↏␧-␿⑋-⑟⭴⭵⮖⳴-⳸⴦⴨-⴬⴮⴯⵨-⵮⵱-⵾⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⹞-⹿⺚⻴-⻿⿖-⿯⿼-⿿぀゗゘㄀-㄄㄰㆏㇤-㇯㈟꒍-꒏꓇-꓏꘬-꘿꛸-꛿Ɤ-꟏꟒꟔Ꟛ-꟱꠭-꠯꠺-꠿꡸-꡿꣆-꣍꣚-꣟꥔-꥞꥽-꥿꧎꧚-꧝꧿꨷-꨿꩎꩏꩚꩛꫃-꫚꫷-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭬-꭯꯮꯯꯺-꯿힤-힯퟇-퟊퟼-퟿﩮﩯﫚-﫿﬇-﬒﬘-﬜﬷﬽﬿﭂﭅﯃-﯒﶐﶑﷈-﷎﷐-﷯︚-︟﹓﹧﹬-﹯﹵﻽﻾＀﾿-￁￈￉￐￑￘￙￝-￟￧￯-￸￾￿",
  "astral": "\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9D-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD7B\uDD8B\uDD93\uDD96\uDDA2\uDDB2\uDDBA\uDDBD-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDF7F\uDF86\uDFB1\uDFBB-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F\uDEAA\uDEAE\uDEAF\uDEB2-\uDEFF\uDF28-\uDF2F\uDF5A-\uDF6F\uDF8A-\uDFAF\uDFCC-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC76-\uDC7E\uDCC3-\uDCCC\uDCCE\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD48-\uDD4F\uDD77-\uDD7F\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5C\uDC62-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEBA-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF47-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD47-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE5-\uDDFF\uDE48-\uDE4F\uDEA3-\uDEAF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFAF\uDFB1-\uDFBF\uDFF2-\uDFFE]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80E-\uD810\uD812-\uD819\uD824-\uD82A\uD82D\uD82E\uD830-\uD832\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80B[\uDC00-\uDF8F\uDFF3-\uDFFF]|\uD80D[\uDC2F\uDC39-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDEBF\uDECA-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82B[\uDC00-\uDFEF\uDFF4\uDFFC\uDFFF]|\uD82C[\uDD23-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD833[\uDC00-\uDEFF\uDF2E\uDF2F\uDF47-\uDF4F\uDFC4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDEB-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD837[\uDC00-\uDEFF\uDF1F-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD50-\uDE8F\uDEAF-\uDEBF\uDEFA-\uDEFE\uDF00-\uDFFF]|\uD839[\uDC00-\uDFDF\uDFE7\uDFEC\uDFEF\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDD00\uDD3E-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDDAE-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED8-\uDEDC\uDEED-\uDEEF\uDEFD-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFDF\uDFEC-\uDFEF\uDFF1-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE\uDCAF\uDCB2-\uDCFF\uDE54-\uDE5F\uDE6E\uDE6F\uDE75-\uDE77\uDE7D-\uDE7F\uDE87-\uDE8F\uDEAD-\uDEAF\uDEBB-\uDEBF\uDEC6-\uDECF\uDEDA-\uDEDF\uDEE8-\uDEEF\uDEF7-\uDEFF\uDF93\uDFCB-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEE0-\uDEFF]|\uD86D[\uDF39-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]"
}, {
  "name": "Co",
  "alias": "Private_Use",
  "bmp": "-",
  "astral": "[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]"
}, {
  "name": "Cs",
  "alias": "Surrogate",
  "bmp": "\uD800-\uDFFF"
}, {
  "name": "L",
  "alias": "Letter",
  "bmp": "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
  "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
}, {
  "name": "LC",
  "alias": "Cased_Letter",
  "bmp": "A-Za-zµÀ-ÖØ-öø-ƺƼ-ƿǄ-ʓʕ-ʯͰ-ͳͶͷͻ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՠ-ֈႠ-ჅჇჍა-ჺჽ-ჿᎠ-Ᏽᏸ-ᏽᲀ-ᲈᲐ-ᲺᲽ-Ჿᴀ-ᴫᵫ-ᵷᵹ-ᶚḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℴℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-ⱻⱾ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭꙀ-ꙭꚀ-ꚛꜢ-ꝯꝱ-ꞇꞋ-ꞎꞐ-ꟊꟐꟑꟓꟕ-ꟙꟵꟶꟺꬰ-ꭚꭠ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗＡ-Ｚａ-ｚ",
  "astral": "\uD801[\uDC00-\uDC4F\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD806[\uDCA0-\uDCDF]|\uD81B[\uDE40-\uDE7F]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD00-\uDD43]"
}, {
  "name": "Ll",
  "alias": "Lowercase_Letter",
  "bmp": "a-zµß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʯͱͳͷͻ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯՠ-ֈა-ჺჽ-ჿᏸ-ᏽᲀ-ᲈᴀ-ᴫᵫ-ᵷᵹ-ᶚḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎↄⰰ-ⱟⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱻⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯꝱ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞯꞵꞷꞹꞻꞽꞿꟁꟃꟈꟊꟑꟓꟕꟗꟙꟶꟺꬰ-ꭚꭠ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
  "astral": "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD22-\uDD43]"
}, {
  "name": "Lm",
  "alias": "Modifier_Letter",
  "bmp": "ʰ-ˁˆ-ˑˠ-ˤˬˮʹͺՙـۥۦߴߵߺࠚࠤࠨࣉॱๆໆჼៗᡃᪧᱸ-ᱽᴬ-ᵪᵸᶛ-ᶿⁱⁿₐ-ₜⱼⱽⵯⸯ々〱-〵〻ゝゞー-ヾꀕꓸ-ꓽꘌꙿꚜꚝꜗ-ꜟꝰꞈꟲ-ꟴꟸꟹꧏꧦꩰꫝꫳꫴꭜ-ꭟꭩｰﾞﾟ",
  "astral": "\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD838[\uDD37-\uDD3D]|𞥋"
}, {
  "name": "Lo",
  "alias": "Other_Letter",
  "bmp": "ªºƻǀ-ǃʔא-תׯ-ײؠ-ؿف-يٮٯٱ-ۓەۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪࠀ-ࠕࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣈऄ-हऽॐक़-ॡॲ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๅກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎᄀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៜᠠ-ᡂᡄ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱷᳩ-ᳬᳮ-ᳳᳵᳶᳺℵ-ℸⴰ-ⵧⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ〆〼ぁ-ゖゟァ-ヺヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꀔꀖ-ꒌꓐ-ꓷꔀ-ꘋꘐ-ꘟꘪꘫꙮꚠ-ꛥꞏꟷꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧠ-ꧤꧧ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩯꩱ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛꫜꫠ-ꫪꫲꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎יִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼｦ-ｯｱ-ﾝﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
  "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF4A\uDF50]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|𝼊|\uD838[\uDD00-\uDD2C\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
}, {
  "name": "Lt",
  "alias": "Titlecase_Letter",
  "bmp": "ǅǈǋǲᾈ-ᾏᾘ-ᾟᾨ-ᾯᾼῌῼ"
}, {
  "name": "Lu",
  "alias": "Uppercase_Letter",
  "bmp": "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵᲐ-ᲺᲽ-ᲿḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅↃⰀ-ⰯⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞮꞰ-ꞴꞶꞸꞺꞼꞾꟀꟂꟄ-ꟇꟉꟐꟖꟘꟵＡ-Ｚ",
  "astral": "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]"
}, {
  "name": "M",
  "alias": "Mark",
  "bmp": "̀-ͯ҃-҉֑-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣঁ-ঃ়া-ৄেৈো-্ৗৢৣ৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑੰੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣஂா-ூெ-ைொ-்ௗఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣඁ-ඃ්ා-ුූෘ-ෟෲෳัิ-ฺ็-๎ັິ-ຼ່-ໍ༹༘༙༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏႚ-ႝ፝-፟ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝᠋-᠍᠏ᢅᢆᢩᤠ-ᤫᤰ-᤻ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼᪰-ᫎᬀ-ᬄ᬴-᭄᭫-᭳ᮀ-ᮂᮡ-ᮭ᯦-᯳ᰤ-᰷᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿⃐-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꙯-꙲ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀ꧥꨩ-ꨶꩃꩌꩍꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭ﬞ︀-️︠-︯",
  "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC82\uDCB0-\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD34\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDCE\uDDCF\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC5E\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD806[\uDC2C-\uDC3A\uDD30-\uDD35\uDD37\uDD38\uDD3B-\uDD3E\uDD40\uDD42\uDD43\uDDD1-\uDDD7\uDDDA-\uDDE0\uDDE4\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDEF3-\uDEF6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF51-\uDF87\uDF8F-\uDF92\uDFE4\uDFF0\uDFF1]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
}, {
  "name": "Mc",
  "alias": "Spacing_Mark",
  "bmp": "ःऻा-ीॉ-ौॎॏংঃা-ীেৈোৌৗਃਾ-ੀઃા-ીૉોૌଂଃାୀେୈୋୌୗாிுூெ-ைொ-ௌௗఁ-ఃు-ౄಂಃಾೀ-ೄೇೈೊೋೕೖംഃാ-ീെ-ൈൊ-ൌൗංඃා-ෑෘ-ෟෲෳ༾༿ཿါာေးျြၖၗၢ-ၤၧ-ၭႃႄႇ-ႌႏႚ-ႜ᜕᜴ាើ-ៅះៈᤣ-ᤦᤩ-ᤫᤰᤱᤳ-ᤸᨙᨚᩕᩗᩡᩣᩤᩭ-ᩲᬄᬵᬻᬽ-ᭁᭃ᭄ᮂᮡᮦᮧ᮪ᯧᯪ-ᯬᯮ᯲᯳ᰤ-ᰫᰴᰵ᳡᳷〮〯ꠣꠤꠧꢀꢁꢴ-ꣃꥒ꥓ꦃꦴꦵꦺꦻꦾ-꧀ꨯꨰꨳꨴꩍꩻꩽꫫꫮꫯꫵꯣꯤꯦꯧꯩꯪ꯬",
  "astral": "\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD30-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]"
}, {
  "name": "Me",
  "alias": "Enclosing_Mark",
  "bmp": "҈҉᪾⃝-⃠⃢-⃤꙰-꙲"
}, {
  "name": "Mn",
  "alias": "Nonspacing_Mark",
  "bmp": "̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-ٰٟۖ-ۜ۟-۪ۤۧۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ंऺ़ु-ै्॑-ॗॢॣঁ়ু-ৄ্ৢৣ৾ਁਂ਼ੁੂੇੈੋ-੍ੑੰੱੵઁં઼ુ-ૅેૈ્ૢૣૺ-૿ଁ଼ିୁ-ୄ୍୕ୖୢୣஂீ்ఀఄ఼ా-ీె-ైొ-్ౕౖౢౣಁ಼ಿೆೌ್ೢೣഀഁ഻഼ു-ൄ്ൢൣඁ්ි-ුූัิ-ฺ็-๎ັິ-ຼ່-ໍཱ༹༘༙༵༷-ཾྀ-྄྆྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္်ွှၘၙၞ-ၠၱ-ၴႂႅႆႍႝ፝-፟ᜒ-᜔ᜲᜳᝒᝓᝲᝳ឴឵ិ-ួំ៉-៓៝᠋-᠍᠏ᢅᢆᢩᤠ-ᤢᤧᤨᤲ᤹-᤻ᨘᨗᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽ᪿ-ᫎᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀᮁᮢ-ᮥᮨᮩ᮫-ᮭ᯦ᯨᯩᯭᯯ-ᯱᰬ-ᰳᰶ᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷿⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〭꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠥꠦ꠬꣄ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꦽꧥꨩ-ꨮꨱꨲꨵꨶꩃꩌꩼꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫬꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯",
  "astral": "\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]"
}, {
  "name": "N",
  "alias": "Number",
  "bmp": "0-9²³¹¼-¾٠-٩۰-۹߀-߉०-९০-৯৴-৹੦-੯૦-૯୦-୯୲-୷௦-௲౦-౯౸-౾೦-೯൘-൞൦-൸෦-෯๐-๙໐-໙༠-༳၀-၉႐-႙፩-፼ᛮ-ᛰ០-៩៰-៹᠐-᠙᥆-᥏᧐-᧚᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙⁰⁴-⁹₀-₉⅐-ↂↅ-↉①-⒛⓪-⓿❶-➓⳽〇〡-〩〸-〺㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꘠-꘩ꛦ-ꛯ꠰-꠵꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
  "astral": "\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2\uDD50-\uDD59]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]"
}, {
  "name": "Nd",
  "alias": "Decimal_Number",
  "bmp": "0-9٠-٩۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯෦-෯๐-๙໐-໙༠-༩၀-၉႐-႙០-៩᠐-᠙᥆-᥏᧐-᧙᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙꘠-꘩꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９",
  "astral": "\uD801[\uDCA0-\uDCA9]|\uD803[\uDD30-\uDD39]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9\uDD50-\uDD59]|\uD807[\uDC50-\uDC59\uDD50-\uDD59\uDDA0-\uDDA9]|\uD81A[\uDE60-\uDE69\uDEC0-\uDEC9\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDD50-\uDD59]|\uD83E[\uDFF0-\uDFF9]"
}, {
  "name": "Nl",
  "alias": "Letter_Number",
  "bmp": "ᛮ-ᛰⅠ-ↂↅ-ↈ〇〡-〩〸-〺ꛦ-ꛯ",
  "astral": "\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]"
}, {
  "name": "No",
  "alias": "Other_Number",
  "bmp": "²³¹¼-¾৴-৹୲-୷௰-௲౸-౾൘-൞൰-൸༪-༳፩-፼៰-៹᧚⁰⁴-⁹₀-₉⅐-⅟↉①-⒛⓪-⓿❶-➓⳽㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꠰-꠵",
  "astral": "\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54\uDFC5-\uDFCB]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C\uDFC0-\uDFD4]|\uD81A[\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD83A[\uDCC7-\uDCCF]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C]"
}, {
  "name": "P",
  "alias": "Punctuation",
  "bmp": "!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}¡§«¶·»¿;·՚-՟։֊־׀׃׆׳״؉؊،؍؛؝-؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰৽੶૰౷಄෴๏๚๛༄-༒༔༺-༽྅࿐-࿔࿙࿚၊-၏჻፠-፨᐀᙮᚛᚜᛫-᛭᜵᜶។-៖៘-៚᠀-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᭽᭾᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‐-‧‰-⁃⁅-⁑⁓-⁞⁽⁾₍₎⌈-⌋〈〉❨-❵⟅⟆⟦-⟯⦃-⦘⧘-⧛⧼⧽⳹-⳼⳾⳿⵰⸀-⸮⸰-⹏⹒-⹝、-〃〈-】〔-〟〰〽゠・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫﴾﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪﹫！-＃％-＊，-／：；？＠［-］＿｛｝｟-･",
  "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|𐕯|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|𛲟|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
}, {
  "name": "Pc",
  "alias": "Connector_Punctuation",
  "bmp": "_‿⁀⁔︳︴﹍-﹏＿"
}, {
  "name": "Pd",
  "alias": "Dash_Punctuation",
  "bmp": "\\-֊־᐀᠆‐-―⸗⸚⸺⸻⹀⹝〜〰゠︱︲﹘﹣－",
  "astral": "𐺭"
}, {
  "name": "Pe",
  "alias": "Close_Punctuation",
  "bmp": "\\)\\]\\}༻༽᚜⁆⁾₎⌉⌋〉❩❫❭❯❱❳❵⟆⟧⟩⟫⟭⟯⦄⦆⦈⦊⦌⦎⦐⦒⦔⦖⦘⧙⧛⧽⸣⸥⸧⸩⹖⹘⹚⹜〉》」』】〕〗〙〛〞〟﴾︘︶︸︺︼︾﹀﹂﹄﹈﹚﹜﹞）］｝｠｣"
}, {
  "name": "Pf",
  "alias": "Final_Punctuation",
  "bmp": "»’”›⸃⸅⸊⸍⸝⸡"
}, {
  "name": "Pi",
  "alias": "Initial_Punctuation",
  "bmp": "«‘‛“‟‹⸂⸄⸉⸌⸜⸠"
}, {
  "name": "Po",
  "alias": "Other_Punctuation",
  "bmp": "!-#%-'\\*,\\.\\/:;\\?@\\¡§¶·¿;·՚-՟։׀׃׆׳״؉؊،؍؛؝-؟٪-٭۔܀-܍߷-߹࠰-࠾࡞।॥॰৽੶૰౷಄෴๏๚๛༄-༒༔྅࿐-࿔࿙࿚၊-၏჻፠-፨᙮᛫-᛭᜵᜶។-៖៘-៚᠀-᠅᠇-᠊᥄᥅᨞᨟᪠-᪦᪨-᪭᭚-᭠᭽᭾᯼-᯿᰻-᰿᱾᱿᳀-᳇᳓‖‗†-‧‰-‸※-‾⁁-⁃⁇-⁑⁓⁕-⁞⳹-⳼⳾⳿⵰⸀⸁⸆-⸈⸋⸎-⸖⸘⸙⸛⸞⸟⸪-⸮⸰-⸹⸼-⸿⹁⹃-⹏⹒-⹔、-〃〽・꓾꓿꘍-꘏꙳꙾꛲-꛷꡴-꡷꣎꣏꣸-꣺꣼꤮꤯꥟꧁-꧍꧞꧟꩜-꩟꫞꫟꫰꫱꯫︐-︖︙︰﹅﹆﹉-﹌﹐-﹒﹔-﹗﹟-﹡﹨﹪﹫！-＃％-＇＊，．／：；？＠＼｡､･",
  "astral": "\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|𐕯|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|𛲟|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]"
}, {
  "name": "Ps",
  "alias": "Open_Punctuation",
  "bmp": "\\(\\[\\{༺༼᚛‚„⁅⁽₍⌈⌊〈❨❪❬❮❰❲❴⟅⟦⟨⟪⟬⟮⦃⦅⦇⦉⦋⦍⦏⦑⦓⦕⦗⧘⧚⧼⸢⸤⸦⸨⹂⹕⹗⹙⹛〈《「『【〔〖〘〚〝﴿︗︵︷︹︻︽︿﹁﹃﹇﹙﹛﹝（［｛｟｢"
}, {
  "name": "S",
  "alias": "Symbol",
  "bmp": "\\$\\+<->\\^`\\|~¢-¦¨©¬®-±´¸×÷˂-˅˒-˟˥-˫˭˯-˿͵΄΅϶҂֍-֏؆-؈؋؎؏۞۩۽۾߶߾߿࢈৲৳৺৻૱୰௳-௺౿൏൹฿༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᙭៛᥀᧞-᧿᭡-᭪᭴-᭼᾽᾿-῁῍-῏῝-῟῭-`´῾⁄⁒⁺-⁼₊-₌₠-⃀℀℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊↋←-⌇⌌-⌨⌫-␦⑀-⑊⒜-ⓩ─-❧➔-⟄⟇-⟥⟰-⦂⦙-⧗⧜-⧻⧾-⭳⭶-⮕⮗-⯿⳥-⳪⹐⹑⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿゛゜㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䷀-䷿꒐-꓆꜀-꜖꜠꜡꞉꞊꠨-꠫꠶-꠹꩷-꩹꭛꭪꭫﬩﮲-﯂﵀-﵏﷏﷼-﷿﹢﹤-﹦﹩＄＋＜-＞＾｀｜～￠-￦￨-￮￼�",
  "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|𑜿|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|𛲜|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA]"
}, {
  "name": "Sc",
  "alias": "Currency_Symbol",
  "bmp": "\\$¢-¥֏؋߾߿৲৳৻૱௹฿៛₠-⃀꠸﷼﹩＄￠￡￥￦",
  "astral": "\uD807[\uDFDD-\uDFE0]|𞋿|𞲰"
}, {
  "name": "Sk",
  "alias": "Modifier_Symbol",
  "bmp": "\\^`¨¯´¸˂-˅˒-˟˥-˫˭˯-˿͵΄΅࢈᾽᾿-῁῍-῏῝-῟῭-`´῾゛゜꜀-꜖꜠꜡꞉꞊꭛꭪꭫﮲-﯂＾｀￣",
  "astral": "\uD83C[\uDFFB-\uDFFF]"
}, {
  "name": "Sm",
  "alias": "Math_Symbol",
  "bmp": "\\+<->\\|~¬±×÷϶؆-؈⁄⁒⁺-⁼₊-₌℘⅀-⅄⅋←-↔↚↛↠↣↦↮⇎⇏⇒⇔⇴-⋿⌠⌡⍼⎛-⎳⏜-⏡▷◁◸-◿♯⟀-⟄⟇-⟥⟰-⟿⤀-⦂⦙-⧗⧜-⧻⧾-⫿⬰-⭄⭇-⭌﬩﹢﹤-﹦＋＜-＞｜～￢￩-￬",
  "astral": "\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]"
}, {
  "name": "So",
  "alias": "Other_Symbol",
  "bmp": "¦©®°҂֍֎؎؏۞۩۽۾߶৺୰௳-௸௺౿൏൹༁-༃༓༕-༗༚-༟༴༶༸྾-࿅࿇-࿌࿎࿏࿕-࿘႞႟᎐-᎙᙭᥀᧞-᧿᭡-᭪᭴-᭼℀℁℃-℆℈℉℔№℗℞-℣℥℧℩℮℺℻⅊⅌⅍⅏↊↋↕-↙↜-↟↡↢↤↥↧-↭↯-⇍⇐⇑⇓⇕-⇳⌀-⌇⌌-⌟⌢-⌨⌫-⍻⍽-⎚⎴-⏛⏢-␦⑀-⑊⒜-ⓩ─-▶▸-◀◂-◷☀-♮♰-❧➔-➿⠀-⣿⬀-⬯⭅⭆⭍-⭳⭶-⮕⮗-⯿⳥-⳪⹐⹑⺀-⺙⺛-⻳⼀-⿕⿰-⿻〄〒〓〠〶〷〾〿㆐㆑㆖-㆟㇀-㇣㈀-㈞㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䷀-䷿꒐-꓆꠨-꠫꠶꠷꠹꩷-꩹﵀-﵏﷏﷽-﷿￤￨￭￮￼�",
  "astral": "\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|𑜿|\uD807[\uDFD5-\uDFDC\uDFE1-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|𛲜|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|𞅏|\uD83B[\uDCAC\uDD2E]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA]"
}, {
  "name": "Z",
  "alias": "Separator",
  "bmp": "    - \u2028\u2029  　"
}, {
  "name": "Zl",
  "alias": "Line_Separator",
  "bmp": "\u2028"
}, {
  "name": "Zp",
  "alias": "Paragraph_Separator",
  "bmp": "\u2029"
}, {
  "name": "Zs",
  "alias": "Space_Separator",
  "bmp": "    -   　"
}];
/*!
 * XRegExp Unicode Categories 5.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2010-present MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */
const unicodeCategories = function(XRegExp2) {
  if (!XRegExp2.addUnicodeData) {
    throw new ReferenceError("Unicode Base must be loaded before Unicode Categories");
  }
  XRegExp2.addUnicodeData(categories);
};
var properties = [{
  "name": "ASCII",
  "bmp": "\0-"
}, {
  "name": "Alphabetic",
  "bmp": "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͅͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈְ-ׇֽֿׁׂׅׄא-תׯ-ײؐ-ؚؠ-ٗٙ-ٟٮ-ۓە-ۜۡ-ۭۨ-ۯۺ-ۼۿܐ-ܿݍ-ޱߊ-ߪߴߵߺࠀ-ࠗࠚ-ࠬࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉࣔ-ࣣࣟ-ࣰࣩ-ऻऽ-ौॎ-ॐॕ-ॣॱ-ঃঅ-ঌএঐও-নপ-রলশ-হঽ-ৄেৈোৌৎৗড়ঢ়য়-ৣৰৱৼਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਾ-ੂੇੈੋੌੑਖ਼-ੜਫ਼ੰ-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽ-ૅે-ૉોૌૐૠ-ૣૹ-ૼଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽ-ୄେୈୋୌୖୗଡ଼ଢ଼ୟ-ୣୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-ௌௐௗఀ-ఃఅ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-ౌౕౖౘ-ౚౝౠ-ౣಀ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ-ೄೆ-ೈೊ-ೌೕೖೝೞೠ-ೣೱೲഀ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൌൎൔ-ൗൟ-ൣൺ-ൿඁ-ඃඅ-ඖක-නඳ-රලව-ෆා-ුූෘ-ෟෲෳก-ฺเ-ๆํກຂຄຆ-ຊຌ-ຣລວ-ູົ-ຽເ-ໄໆໍໜ-ໟༀཀ-ཇཉ-ཬཱ-ཱྀྈ-ྗྙ-ྼက-ံးျ-ဿၐ-ႏႚ-ႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜓᜟ-ᜳᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-ឳា-ៈៗៜᠠ-ᡸᢀ-ᢪᢰ-ᣵᤀ-ᤞᤠ-ᤫᤰ-ᤸᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨛᨠ-ᩞᩡ-ᩴᪧᪿᫀᫌ-ᫎᬀ-ᬳᬵ-ᭃᭅ-ᭌᮀ-ᮩᮬ-ᮯᮺ-ᯥᯧ-ᯱᰀ-ᰶᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿᷧ-ᷴḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⒶ-ⓩⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙴ-ꙻꙿ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠅꠇ-ꠧꡀ-ꡳꢀ-ꣃꣅꣲ-ꣷꣻꣽ-ꣿꤊ-ꤪꤰ-ꥒꥠ-ꥼꦀ-ꦲꦴ-ꦿꧏꧠ-ꧯꧺ-ꧾꨀ-ꨶꩀ-ꩍꩠ-ꩶꩺ-ꪾꫀꫂꫛ-ꫝꫠ-ꫯꫲ-ꫵꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯪ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
  "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDE80-\uDEA9\uDEAB\uDEAC\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC45\uDC71-\uDC75\uDC82-\uDCB8\uDCC2\uDCD0-\uDCE8\uDD00-\uDD32\uDD44-\uDD47\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDCE\uDDCF\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDEB8\uDF00-\uDF1A\uDF1D-\uDF2A\uDF40-\uDF46]|\uD806[\uDC00-\uDC38\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B\uDD3C\uDD3F-\uDD42\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDDF\uDDE1\uDDE3\uDDE4\uDE00-\uDE32\uDE35-\uDE3E\uDE50-\uDE97\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD41\uDD43\uDD46\uDD47\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD96\uDD98\uDEE0-\uDEF6\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3\uDFF0\uDFF1]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD47\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
}, {
  "name": "Any",
  "isBmpLast": true,
  "bmp": "\0-￿",
  "astral": "[\uD800-\uDBFF][\uDC00-\uDFFF]"
}, {
  "name": "Default_Ignorable_Code_Point",
  "bmp": "­͏؜ᅟᅠ឴឵᠋-᠏​-‏‪-‮⁠-⁯ㅤ︀-️\uFEFFﾠ￰-￸",
  "astral": "\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|[\uDB40-\uDB43][\uDC00-\uDFFF]"
}, {
  "name": "Lowercase",
  "bmp": "a-zªµºß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķĸĺļľŀłńņňŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌƍƒƕƙ-ƛƞơƣƥƨƪƫƭưƴƶƹƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜǝǟǡǣǥǧǩǫǭǯǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿɀɂɇɉɋɍɏ-ʓʕ-ʸˀˁˠ-ˤͅͱͳͷͺ-ͽΐά-ώϐϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯՠ-ֈა-ჺჽ-ჿᏸ-ᏽᲀ-ᲈᴀ-ᶿḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷιῂ-ῄῆῇῐ-ΐῖῗῠ-ῧῲ-ῴῶῷⁱⁿₐ-ₜℊℎℏℓℯℴℹℼℽⅆ-ⅉⅎⅰ-ⅿↄⓐ-ⓩⰰ-ⱟⱡⱥⱦⱨⱪⱬⱱⱳⱴⱶ-ⱽⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛ-ꚝꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞯꞵꞷꞹꞻꞽꞿꟁꟃꟈꟊꟑꟓꟕꟗꟙꟶꟸ-ꟺꬰ-ꭚꭜ-ꭨꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ",
  "astral": "\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDF80\uDF83-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD837[\uDF00-\uDF09\uDF0B-\uDF1E]|\uD83A[\uDD22-\uDD43]"
}, {
  "name": "Noncharacter_Code_Point",
  "bmp": "﷐-﷯￾￿",
  "astral": "[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]"
}, {
  "name": "Uppercase",
  "bmp": "A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸŹŻŽƁƂƄƆƇƉ-ƋƎ-ƑƓƔƖ-ƘƜƝƟƠƢƤƦƧƩƬƮƯƱ-ƳƵƷƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺȻȽȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵᲐ-ᲺᲽ-ᲿḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾℿⅅⅠ-ⅯↃⒶ-ⓏⰀ-ⰯⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞮꞰ-ꞴꞶꞸꞺꞼꞾꟀꟂꟄ-ꟇꟉꟐꟖꟘꟵＡ-Ｚ",
  "astral": "\uD801[\uDC00-\uDC27\uDCB0-\uDCD3\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]"
}, {
  "name": "White_Space",
  "bmp": "	-\r    - \u2028\u2029  　"
}];
/*!
 * XRegExp Unicode Properties 5.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2012-present MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */
const unicodeProperties = function(XRegExp2) {
  if (!XRegExp2.addUnicodeData) {
    throw new ReferenceError("Unicode Base must be loaded before Unicode Properties");
  }
  var unicodeData = properties;
  unicodeData.push({
    name: "Assigned",
    // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
    // Categories addon is required to use this property
    inverseOf: "Cn"
  });
  XRegExp2.addUnicodeData(unicodeData);
};
var scripts = [{
  "name": "Adlam",
  "astral": "\uD83A[\uDD00-\uDD4B\uDD50-\uDD59\uDD5E\uDD5F]"
}, {
  "name": "Ahom",
  "astral": "\uD805[\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF46]"
}, {
  "name": "Anatolian_Hieroglyphs",
  "astral": "\uD811[\uDC00-\uDE46]"
}, {
  "name": "Arabic",
  "bmp": "؀-؄؆-؋؍-ؚ؜-؞ؠ-ؿف-يٖ-ٯٱ-ۜ۞-ۿݐ-ݿࡰ-ࢎ࢐࢑࢘-ࣣ࣡-ࣿﭐ-﯂ﯓ-ﴽ﵀-ﶏﶒ-ﷇ﷏ﷰ-﷿ﹰ-ﹴﹶ-ﻼ",
  "astral": "\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]"
}, {
  "name": "Armenian",
  "bmp": "Ա-Ֆՙ-֊֍-֏ﬓ-ﬗ"
}, {
  "name": "Avestan",
  "astral": "\uD802[\uDF00-\uDF35\uDF39-\uDF3F]"
}, {
  "name": "Balinese",
  "bmp": "ᬀ-ᭌ᭐-᭾"
}, {
  "name": "Bamum",
  "bmp": "ꚠ-꛷",
  "astral": "\uD81A[\uDC00-\uDE38]"
}, {
  "name": "Bassa_Vah",
  "astral": "\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]"
}, {
  "name": "Batak",
  "bmp": "ᯀ-᯳᯼-᯿"
}, {
  "name": "Bengali",
  "bmp": "ঀ-ঃঅ-ঌএঐও-নপ-রলশ-হ়-ৄেৈো-ৎৗড়ঢ়য়-ৣ০-৾"
}, {
  "name": "Bhaiksuki",
  "astral": "\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]"
}, {
  "name": "Bopomofo",
  "bmp": "˪˫ㄅ-ㄯㆠ-ㆿ"
}, {
  "name": "Brahmi",
  "astral": "\uD804[\uDC00-\uDC4D\uDC52-\uDC75\uDC7F]"
}, {
  "name": "Braille",
  "bmp": "⠀-⣿"
}, {
  "name": "Buginese",
  "bmp": "ᨀ-ᨛ᨞᨟"
}, {
  "name": "Buhid",
  "bmp": "ᝀ-ᝓ"
}, {
  "name": "Canadian_Aboriginal",
  "bmp": "᐀-ᙿᢰ-ᣵ",
  "astral": "\uD806[\uDEB0-\uDEBF]"
}, {
  "name": "Carian",
  "astral": "\uD800[\uDEA0-\uDED0]"
}, {
  "name": "Caucasian_Albanian",
  "astral": "\uD801[\uDD30-\uDD63\uDD6F]"
}, {
  "name": "Chakma",
  "astral": "\uD804[\uDD00-\uDD34\uDD36-\uDD47]"
}, {
  "name": "Cham",
  "bmp": "ꨀ-ꨶꩀ-ꩍ꩐-꩙꩜-꩟"
}, {
  "name": "Cherokee",
  "bmp": "Ꭰ-Ᏽᏸ-ᏽꭰ-ꮿ"
}, {
  "name": "Chorasmian",
  "astral": "\uD803[\uDFB0-\uDFCB]"
}, {
  "name": "Common",
  "bmp": "\0-@\\[-`\\{-©«-¹»-¿×÷ʹ-˟˥-˩ˬ-˿ʹ;΅·؅،؛؟ـ۝࣢।॥฿࿕-࿘჻᛫-᛭᜵᜶᠂᠃᠅᳓᳡ᳩ-ᳬᳮ-ᳳᳵ-᳷ᳺ -​‎-⁤⁦-⁰⁴-⁾₀-₎₠-⃀℀-℥℧-℩ℬ-ℱℳ-⅍⅏-⅟↉-↋←-␦⑀-⑊①-⟿⤀-⭳⭶-⮕⮗-⯿⸀-⹝⿰-⿻　-〄〆〈-〠〰-〷〼-〿゛゜゠・ー㆐-㆟㇀-㇣㈠-㉟㉿-㋏㋿㍘-㏿䷀-䷿꜀-꜡ꞈ-꞊꠰-꠹꤮ꧏ꭛꭪꭫﴾﴿︐-︙︰-﹒﹔-﹦﹨-﹫\uFEFF！-＠［-｀｛-･ｰﾞﾟ￠-￦￨-￮￹-�",
  "astral": "\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9C\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD82F[\uDCA0-\uDCA3]|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDEE0-\uDEF3\uDF00-\uDF56\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83B[\uDC71-\uDCB4\uDD01-\uDD3D]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDDAD\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDD-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6\uDF00-\uDF92\uDF94-\uDFCA\uDFF0-\uDFF9]|\uDB40[\uDC01\uDC20-\uDC7F]"
}, {
  "name": "Coptic",
  "bmp": "Ϣ-ϯⲀ-ⳳ⳹-⳿"
}, {
  "name": "Cuneiform",
  "astral": "\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]"
}, {
  "name": "Cypriot",
  "astral": "\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]"
}, {
  "name": "Cypro_Minoan",
  "astral": "\uD80B[\uDF90-\uDFF2]"
}, {
  "name": "Cyrillic",
  "bmp": "Ѐ-҄҇-ԯᲀ-ᲈᴫᵸⷠ-ⷿꙀ-ꚟ︮︯"
}, {
  "name": "Deseret",
  "astral": "\uD801[\uDC00-\uDC4F]"
}, {
  "name": "Devanagari",
  "bmp": "ऀ-ॐॕ-ॣ०-ॿ꣠-ꣿ"
}, {
  "name": "Dives_Akuru",
  "astral": "\uD806[\uDD00-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD35\uDD37\uDD38\uDD3B-\uDD46\uDD50-\uDD59]"
}, {
  "name": "Dogra",
  "astral": "\uD806[\uDC00-\uDC3B]"
}, {
  "name": "Duployan",
  "astral": "\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]"
}, {
  "name": "Egyptian_Hieroglyphs",
  "astral": "\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E\uDC30-\uDC38]"
}, {
  "name": "Elbasan",
  "astral": "\uD801[\uDD00-\uDD27]"
}, {
  "name": "Elymaic",
  "astral": "\uD803[\uDFE0-\uDFF6]"
}, {
  "name": "Ethiopic",
  "bmp": "ሀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፝-፼ᎀ-᎙ⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮ",
  "astral": "\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]"
}, {
  "name": "Georgian",
  "bmp": "Ⴀ-ჅჇჍა-ჺჼ-ჿᲐ-ᲺᲽ-Ჿⴀ-ⴥⴧⴭ"
}, {
  "name": "Glagolitic",
  "bmp": "Ⰰ-ⱟ",
  "astral": "\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]"
}, {
  "name": "Gothic",
  "astral": "\uD800[\uDF30-\uDF4A]"
}, {
  "name": "Grantha",
  "astral": "\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]"
}, {
  "name": "Greek",
  "bmp": "Ͱ-ͳ͵-ͷͺ-ͽͿ΄ΆΈ-ΊΌΎ-ΡΣ-ϡϰ-Ͽᴦ-ᴪᵝ-ᵡᵦ-ᵪᶿἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ῄῆ-ΐῖ-Ί῝-`ῲ-ῴῶ-῾Ωꭥ",
  "astral": "\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]"
}, {
  "name": "Gujarati",
  "bmp": "ઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હ઼-ૅે-ૉો-્ૐૠ-ૣ૦-૱ૹ-૿"
}, {
  "name": "Gunjala_Gondi",
  "astral": "\uD807[\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9]"
}, {
  "name": "Gurmukhi",
  "bmp": "ਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹ਼ਾ-ੂੇੈੋ-੍ੑਖ਼-ੜਫ਼੦-੶"
}, {
  "name": "Han",
  "bmp": "⺀-⺙⺛-⻳⼀-⿕々〇〡-〩〸-〻㐀-䶿一-鿿豈-舘並-龎",
  "astral": "\uD81B[\uDFE2\uDFE3\uDFF0\uDFF1]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A]"
}, {
  "name": "Hangul",
  "bmp": "ᄀ-ᇿ〮〯ㄱ-ㆎ㈀-㈞㉠-㉾ꥠ-ꥼ가-힣ힰ-ퟆퟋ-ퟻﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ"
}, {
  "name": "Hanifi_Rohingya",
  "astral": "\uD803[\uDD00-\uDD27\uDD30-\uDD39]"
}, {
  "name": "Hanunoo",
  "bmp": "ᜠ-᜴"
}, {
  "name": "Hatran",
  "astral": "\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]"
}, {
  "name": "Hebrew",
  "bmp": "֑-ׇא-תׯ-״יִ-זּטּ-לּמּנּסּףּפּצּ-ﭏ"
}, {
  "name": "Hiragana",
  "bmp": "ぁ-ゖゝ-ゟ",
  "astral": "\uD82C[\uDC01-\uDD1F\uDD50-\uDD52]|🈀"
}, {
  "name": "Imperial_Aramaic",
  "astral": "\uD802[\uDC40-\uDC55\uDC57-\uDC5F]"
}, {
  "name": "Inherited",
  "bmp": "̀-ًͯ҅҆-ٰٕ॑-॔᪰-ᫎ᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸᳹᷀-᷿‌‍⃐-〪⃰-゙゚〭︀-️︠-︭",
  "astral": "\uD800[\uDDFD\uDEE0]|𑌻|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]"
}, {
  "name": "Inscriptional_Pahlavi",
  "astral": "\uD802[\uDF60-\uDF72\uDF78-\uDF7F]"
}, {
  "name": "Inscriptional_Parthian",
  "astral": "\uD802[\uDF40-\uDF55\uDF58-\uDF5F]"
}, {
  "name": "Javanese",
  "bmp": "ꦀ-꧍꧐-꧙꧞꧟"
}, {
  "name": "Kaithi",
  "astral": "\uD804[\uDC80-\uDCC2\uDCCD]"
}, {
  "name": "Kannada",
  "bmp": "ಀ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹ಼-ೄೆ-ೈೊ-್ೕೖೝೞೠ-ೣ೦-೯ೱೲ"
}, {
  "name": "Katakana",
  "bmp": "ァ-ヺヽ-ヿㇰ-ㇿ㋐-㋾㌀-㍗ｦ-ｯｱ-ﾝ",
  "astral": "\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00\uDD20-\uDD22\uDD64-\uDD67]"
}, {
  "name": "Kayah_Li",
  "bmp": "꤀-꤭꤯"
}, {
  "name": "Kharoshthi",
  "astral": "\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE50-\uDE58]"
}, {
  "name": "Khitan_Small_Script",
  "astral": "𖿤|\uD822[\uDF00-\uDFFF]|\uD823[\uDC00-\uDCD5]"
}, {
  "name": "Khmer",
  "bmp": "ក-៝០-៩៰-៹᧠-᧿"
}, {
  "name": "Khojki",
  "astral": "\uD804[\uDE00-\uDE11\uDE13-\uDE3E]"
}, {
  "name": "Khudawadi",
  "astral": "\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]"
}, {
  "name": "Lao",
  "bmp": "ກຂຄຆ-ຊຌ-ຣລວ-ຽເ-ໄໆ່-ໍ໐-໙ໜ-ໟ"
}, {
  "name": "Latin",
  "bmp": "A-Za-zªºÀ-ÖØ-öø-ʸˠ-ˤᴀ-ᴥᴬ-ᵜᵢ-ᵥᵫ-ᵷᵹ-ᶾḀ-ỿⁱⁿₐ-ₜKÅℲⅎⅠ-ↈⱠ-ⱿꜢ-ꞇꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꟿꬰ-ꭚꭜ-ꭤꭦ-ꭩﬀ-ﬆＡ-Ｚａ-ｚ",
  "astral": "\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD837[\uDF00-\uDF1E]"
}, {
  "name": "Lepcha",
  "bmp": "ᰀ-᰷᰻-᱉ᱍ-ᱏ"
}, {
  "name": "Limbu",
  "bmp": "ᤀ-ᤞᤠ-ᤫᤰ-᤻᥀᥄-᥏"
}, {
  "name": "Linear_A",
  "astral": "\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]"
}, {
  "name": "Linear_B",
  "astral": "\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]"
}, {
  "name": "Lisu",
  "bmp": "ꓐ-꓿",
  "astral": "𑾰"
}, {
  "name": "Lycian",
  "astral": "\uD800[\uDE80-\uDE9C]"
}, {
  "name": "Lydian",
  "astral": "\uD802[\uDD20-\uDD39\uDD3F]"
}, {
  "name": "Mahajani",
  "astral": "\uD804[\uDD50-\uDD76]"
}, {
  "name": "Makasar",
  "astral": "\uD807[\uDEE0-\uDEF8]"
}, {
  "name": "Malayalam",
  "bmp": "ഀ-ഌഎ-ഐഒ-ൄെ-ൈൊ-൏ൔ-ൣ൦-ൿ"
}, {
  "name": "Mandaic",
  "bmp": "ࡀ-࡛࡞"
}, {
  "name": "Manichaean",
  "astral": "\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]"
}, {
  "name": "Marchen",
  "astral": "\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]"
}, {
  "name": "Masaram_Gondi",
  "astral": "\uD807[\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]"
}, {
  "name": "Medefaidrin",
  "astral": "\uD81B[\uDE40-\uDE9A]"
}, {
  "name": "Meetei_Mayek",
  "bmp": "ꫠ-꫶ꯀ-꯭꯰-꯹"
}, {
  "name": "Mende_Kikakui",
  "astral": "\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]"
}, {
  "name": "Meroitic_Cursive",
  "astral": "\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]"
}, {
  "name": "Meroitic_Hieroglyphs",
  "astral": "\uD802[\uDD80-\uDD9F]"
}, {
  "name": "Miao",
  "astral": "\uD81B[\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F]"
}, {
  "name": "Modi",
  "astral": "\uD805[\uDE00-\uDE44\uDE50-\uDE59]"
}, {
  "name": "Mongolian",
  "bmp": "᠀᠁᠄᠆-᠙ᠠ-ᡸᢀ-ᢪ",
  "astral": "\uD805[\uDE60-\uDE6C]"
}, {
  "name": "Mro",
  "astral": "\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]"
}, {
  "name": "Multani",
  "astral": "\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]"
}, {
  "name": "Myanmar",
  "bmp": "က-႟ꧠ-ꧾꩠ-ꩿ"
}, {
  "name": "Nabataean",
  "astral": "\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]"
}, {
  "name": "Nandinagari",
  "astral": "\uD806[\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE4]"
}, {
  "name": "New_Tai_Lue",
  "bmp": "ᦀ-ᦫᦰ-ᧉ᧐-᧚᧞᧟"
}, {
  "name": "Newa",
  "astral": "\uD805[\uDC00-\uDC5B\uDC5D-\uDC61]"
}, {
  "name": "Nko",
  "bmp": "߀-ߺ߽-߿"
}, {
  "name": "Nushu",
  "astral": "𖿡|\uD82C[\uDD70-\uDEFB]"
}, {
  "name": "Nyiakeng_Puachue_Hmong",
  "astral": "\uD838[\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDD4F]"
}, {
  "name": "Ogham",
  "bmp": " -᚜"
}, {
  "name": "Ol_Chiki",
  "bmp": "᱐-᱿"
}, {
  "name": "Old_Hungarian",
  "astral": "\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]"
}, {
  "name": "Old_Italic",
  "astral": "\uD800[\uDF00-\uDF23\uDF2D-\uDF2F]"
}, {
  "name": "Old_North_Arabian",
  "astral": "\uD802[\uDE80-\uDE9F]"
}, {
  "name": "Old_Permic",
  "astral": "\uD800[\uDF50-\uDF7A]"
}, {
  "name": "Old_Persian",
  "astral": "\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]"
}, {
  "name": "Old_Sogdian",
  "astral": "\uD803[\uDF00-\uDF27]"
}, {
  "name": "Old_South_Arabian",
  "astral": "\uD802[\uDE60-\uDE7F]"
}, {
  "name": "Old_Turkic",
  "astral": "\uD803[\uDC00-\uDC48]"
}, {
  "name": "Old_Uyghur",
  "astral": "\uD803[\uDF70-\uDF89]"
}, {
  "name": "Oriya",
  "bmp": "ଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହ଼-ୄେୈୋ-୍୕-ୗଡ଼ଢ଼ୟ-ୣ୦-୷"
}, {
  "name": "Osage",
  "astral": "\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]"
}, {
  "name": "Osmanya",
  "astral": "\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]"
}, {
  "name": "Pahawh_Hmong",
  "astral": "\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]"
}, {
  "name": "Palmyrene",
  "astral": "\uD802[\uDC60-\uDC7F]"
}, {
  "name": "Pau_Cin_Hau",
  "astral": "\uD806[\uDEC0-\uDEF8]"
}, {
  "name": "Phags_Pa",
  "bmp": "ꡀ-꡷"
}, {
  "name": "Phoenician",
  "astral": "\uD802[\uDD00-\uDD1B\uDD1F]"
}, {
  "name": "Psalter_Pahlavi",
  "astral": "\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]"
}, {
  "name": "Rejang",
  "bmp": "ꤰ-꥓꥟"
}, {
  "name": "Runic",
  "bmp": "ᚠ-ᛪᛮ-ᛸ"
}, {
  "name": "Samaritan",
  "bmp": "ࠀ-࠭࠰-࠾"
}, {
  "name": "Saurashtra",
  "bmp": "ꢀ-ꣅ꣎-꣙"
}, {
  "name": "Sharada",
  "astral": "\uD804[\uDD80-\uDDDF]"
}, {
  "name": "Shavian",
  "astral": "\uD801[\uDC50-\uDC7F]"
}, {
  "name": "Siddham",
  "astral": "\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]"
}, {
  "name": "SignWriting",
  "astral": "\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]"
}, {
  "name": "Sinhala",
  "bmp": "ඁ-ඃඅ-ඖක-නඳ-රලව-ෆ්ා-ුූෘ-ෟ෦-෯ෲ-෴",
  "astral": "\uD804[\uDDE1-\uDDF4]"
}, {
  "name": "Sogdian",
  "astral": "\uD803[\uDF30-\uDF59]"
}, {
  "name": "Sora_Sompeng",
  "astral": "\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]"
}, {
  "name": "Soyombo",
  "astral": "\uD806[\uDE50-\uDEA2]"
}, {
  "name": "Sundanese",
  "bmp": "ᮀ-ᮿ᳀-᳇"
}, {
  "name": "Syloti_Nagri",
  "bmp": "ꠀ-꠬"
}, {
  "name": "Syriac",
  "bmp": "܀-܍܏-݊ݍ-ݏࡠ-ࡪ"
}, {
  "name": "Tagalog",
  "bmp": "ᜀ-᜕ᜟ"
}, {
  "name": "Tagbanwa",
  "bmp": "ᝠ-ᝬᝮ-ᝰᝲᝳ"
}, {
  "name": "Tai_Le",
  "bmp": "ᥐ-ᥭᥰ-ᥴ"
}, {
  "name": "Tai_Tham",
  "bmp": "ᨠ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪠-᪭"
}, {
  "name": "Tai_Viet",
  "bmp": "ꪀ-ꫂꫛ-꫟"
}, {
  "name": "Takri",
  "astral": "\uD805[\uDE80-\uDEB9\uDEC0-\uDEC9]"
}, {
  "name": "Tamil",
  "bmp": "ஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-்ௐௗ௦-௺",
  "astral": "\uD807[\uDFC0-\uDFF1\uDFFF]"
}, {
  "name": "Tangsa",
  "astral": "\uD81A[\uDE70-\uDEBE\uDEC0-\uDEC9]"
}, {
  "name": "Tangut",
  "astral": "𖿠|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEFF]|\uD823[\uDD00-\uDD08]"
}, {
  "name": "Telugu",
  "bmp": "ఀ-ఌఎ-ఐఒ-నప-హ఼-ౄె-ైొ-్ౕౖౘ-ౚౝౠ-ౣ౦-౯౷-౿"
}, {
  "name": "Thaana",
  "bmp": "ހ-ޱ"
}, {
  "name": "Thai",
  "bmp": "ก-ฺเ-๛"
}, {
  "name": "Tibetan",
  "bmp": "ༀ-ཇཉ-ཬཱ-ྗྙ-ྼ྾-࿌࿎-࿔࿙࿚"
}, {
  "name": "Tifinagh",
  "bmp": "ⴰ-ⵧⵯ⵰⵿"
}, {
  "name": "Tirhuta",
  "astral": "\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]"
}, {
  "name": "Toto",
  "astral": "\uD838[\uDE90-\uDEAE]"
}, {
  "name": "Ugaritic",
  "astral": "\uD800[\uDF80-\uDF9D\uDF9F]"
}, {
  "name": "Vai",
  "bmp": "ꔀ-ꘫ"
}, {
  "name": "Vithkuqi",
  "astral": "\uD801[\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC]"
}, {
  "name": "Wancho",
  "astral": "\uD838[\uDEC0-\uDEF9\uDEFF]"
}, {
  "name": "Warang_Citi",
  "astral": "\uD806[\uDCA0-\uDCF2\uDCFF]"
}, {
  "name": "Yezidi",
  "astral": "\uD803[\uDE80-\uDEA9\uDEAB-\uDEAD\uDEB0\uDEB1]"
}, {
  "name": "Yi",
  "bmp": "ꀀ-ꒌ꒐-꓆"
}, {
  "name": "Zanabazar_Square",
  "astral": "\uD806[\uDE00-\uDE47]"
}];
/*!
 * XRegExp Unicode Scripts 5.1.1
 * <xregexp.com>
 * Steven Levithan (c) 2010-present MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */
const unicodeScripts = function(XRegExp2) {
  if (!XRegExp2.addUnicodeData) {
    throw new ReferenceError("Unicode Base must be loaded before Unicode Scripts");
  }
  XRegExp2.addUnicodeData(scripts, "Script");
};
build(XRegExp);
matchRecursive(XRegExp);
unicodeBase(XRegExp);
unicodeCategories(XRegExp);
unicodeProperties(XRegExp);
unicodeScripts(XRegExp);
var _excluded = ["chapter", "verse"];
function cleanQuoteString(quote) {
  return quote.replace(/”/gi, '"').replace(/“ /gi, '"').replace(/“/gi, '"').replace(/,"/gi, ', "').replace(/, " /gi, ', "').replace(/\s+([?])/gi, "$1").replace(/ {2}/gi, " ").replace(/ , /gi, ", ").replace(/ ."/gi, '."').replace(/ ’./gi, "’.").trim().replace(/ *\... */g, " ".concat(QUOTE_ELLIPSIS, " ")).replace(/ *… */gi, " ".concat(QUOTE_ELLIPSIS, " ")).replaceAll(/\\n|\\r/g, "");
}
function tokenizer(quote) {
  var isOrigLang = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (isOrigLang) {
    return lib$1.tokenizeOrigLang({
      text: quote,
      includePunctuation: false,
      normalize: true
    });
  } else {
    return lib$1.tokenize({
      text: quote,
      includePunctuation: false,
      normalize: true
    });
  }
}
function tokenizeQuote(quote) {
  var isOrigLang = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var cleanQuote = cleanQuoteString(quote);
  var quotesArray = cleanQuote.split(/\s?&\s?/).flatMap(function(partialQuote) {
    return tokenizer(partialQuote, isOrigLang).concat("&");
  }).slice(0, -1);
  return quotesArray;
}
function normalize() {
  var str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var isOrigLang = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var tokens2 = tokenizeQuote(str, isOrigLang).join(" ").trim();
  return tokens2;
}
function getTargetQuotesFromOrigWords(_ref) {
  var verseObjects = _ref.verseObjects, wordObjects = _ref.wordObjects, isMatch = _ref.isMatch;
  var text = "";
  if (!verseObjects || !wordObjects) {
    return text;
  }
  var separator = DEFAULT_SEPARATOR;
  var needsEllipsis = false;
  var _loop = function _loop2() {
    var verseObject = verseObjects[i];
    var lastMatch = false;
    if (verseObject.type === "milestone" || verseObject.type === "word" || verseObject.type === "quote") {
      if (isMatch || wordObjects.find(function(item) {
        return normalize(verseObject.content) === normalize(item.text) && verseObject.occurrence === item.occurrence;
      })) {
        lastMatch = true;
        if (needsEllipsis) {
          separator += QUOTE_ELLIPSIS + DEFAULT_SEPARATOR;
          needsEllipsis = false;
        }
        if (text) {
          text += separator;
        }
        separator = DEFAULT_SEPARATOR;
        if (verseObject.text) {
          text += verseObject.text;
        }
        if (verseObject.children) {
          text += getTargetQuotesFromOrigWords({
            wordObjects,
            verseObjects: verseObject.children,
            isMatch: true
          });
        }
      } else if (verseObject.children) {
        var childText = getTargetQuotesFromOrigWords({
          wordObjects,
          verseObjects: verseObject.children,
          isMatch
        });
        if (childText) {
          lastMatch = true;
          if (needsEllipsis) {
            separator += QUOTE_ELLIPSIS + DEFAULT_SEPARATOR;
            needsEllipsis = false;
          }
          text += (text ? separator : "") + childText;
          separator = DEFAULT_SEPARATOR;
        } else if (text) {
          needsEllipsis = true;
        }
      }
    }
    if (lastMatch && verseObjects[i + 1] && verseObjects[i + 1].type === "text" && text) {
      if (separator === DEFAULT_SEPARATOR) {
        separator = "";
      }
      separator += verseObjects[i + 1].text;
    }
  };
  for (var i = 0, l = verseObjects.length; i < l; i++) {
    _loop();
  }
  return text;
}
function getQuoteMatchesInBookRef(_ref2) {
  var quote = _ref2.quote, ref = _ref2.ref, bookObject = _ref2.bookObject, isOrigLang = _ref2.isOrigLang, _ref2$occurrence = _ref2.occurrence, occurrence = _ref2$occurrence === void 0 ? -1 : _ref2$occurrence;
  if (occurrence === 0)
    return /* @__PURE__ */ new Map();
  var DATA_SEPARATOR = "|";
  var OPEN_CHAR = "{";
  var CLOSE_CHAR = "}";
  var REF_PATTERN = "\\d+:\\d+";
  var OCCURRENCE_PATTERN = "\\d+";
  var enclose = function enclose2(word) {
    return OPEN_CHAR + word + CLOSE_CHAR;
  };
  var joinWordData = function joinWordData2(word, refObject, occurrence2) {
    var chapter = refObject.chapter, verse = refObject.verse;
    var ref2 = "".concat(chapter, ":").concat(verse);
    var data2 = enclose("".concat(ref2).concat(DATA_SEPARATOR).concat(occurrence2));
    return "".concat(word).concat(data2);
  };
  var splitWordData = function splitWordData2(word) {
    var _word$split = word.split(OPEN_CHAR), _word$split2 = _slicedToArray$1(_word$split, 2), _word = _word$split2[0], data2 = _word$split2[1];
    var _data$slice$split = data2.slice(0, -1).split(DATA_SEPARATOR), _data$slice$split2 = _slicedToArray$1(_data$slice$split, 2), ref2 = _data$slice$split2[0], occurrence2 = _data$slice$split2[1];
    var _ref$split = ref2.split(":"), _ref$split2 = _slicedToArray$1(_ref$split, 2), chapter = _ref$split2[0], verse = _ref$split2[1];
    return {
      text: _word,
      chapter: parseInt(chapter),
      verse: parseInt(verse),
      occurrence: parseInt(occurrence2)
    };
  };
  var quoteTokens = tokenizeQuote(quote, isOrigLang);
  var book = setBook(bookObject, ref);
  var sourceArray = [];
  book.forEachVerse(function(verseObjects, verseRef) {
    var tokensMap = quoteTokens.reduce(function(tokensMap2, word) {
      tokensMap2.set(normalize(word), {
        count: 0
      });
      return tokensMap2;
    }, /* @__PURE__ */ new Map());
    sourceArray.push(verseObjectsToString(verseObjects, function(word) {
      var _word = normalize(word);
      var quote2 = tokensMap.get(_word);
      if (!quote2)
        return !_word ? " " : _word;
      quote2.count++;
      return joinWordData(_word, verseRef, quote2.count);
    }));
  });
  var sourceString = sourceArray.join("\n");
  var searchPatterns = quoteTokens.reduce(function(patterns, token, index) {
    if (token === QUOTE_ELLIPSIS)
      return patterns;
    var push = patterns.length === 0 | quoteTokens[index - 1] === QUOTE_ELLIPSIS;
    var AFTER = quoteTokens[index + 1] && quoteTokens[index + 1] === QUOTE_ELLIPSIS ? "" : "\\s?";
    var escaped = XRegExp.escape(normalize(token));
    var regexp = XRegExp("(".concat(escaped).concat(enclose("".concat(REF_PATTERN).concat(XRegExp.escape("|")).concat(OCCURRENCE_PATTERN)), ")").concat(AFTER));
    if (push) {
      patterns.push(regexp);
      return patterns;
    }
    var current = patterns.length - 1;
    patterns[current] = XRegExp.union([patterns[current], regexp], "g", {
      conjunction: "none"
    });
    return patterns;
  }, []);
  var searchQuotes = function searchQuotes2(source, patterns) {
    var keepSearching = true;
    var matches2 = [];
    var limit = 100;
    var iteration = 0;
    var index = 0;
    while (keepSearching) {
      var currentMatches = patterns.reduce(
        // eslint-disable-next-line no-loop-func
        function(currentMatches2, regexp, i, matches3) {
          var match = XRegExp.exec(source, regexp, index);
          if (match) {
            index = match.index + match[0].length;
            return currentMatches2.concat(match.slice(1));
          }
          keepSearching = false;
          matches3.length = 0;
          return [];
        },
        []
      );
      if (currentMatches.length)
        matches2.push(currentMatches);
      if (iteration === limit) {
        keepSearching = false;
        console.log("limit reached");
      }
      iteration++;
    }
    return matches2;
  };
  var matches = searchQuotes(sourceString, searchPatterns);
  var foundOccurrences = matches.reduce(function(occurrences2, words, key) {
    var currentOccurence = key + 1;
    if (occurrence !== -1 && currentOccurence !== occurrence)
      return occurrences2;
    words.forEach(function(_word) {
      var _splitWordData = splitWordData(_word), chapter = _splitWordData.chapter, verse = _splitWordData.verse, wordObject = _objectWithoutProperties(_splitWordData, _excluded);
      var refString = refToString({
        chapter,
        verse
      });
      var currentWordsInRef = occurrences2.get(refString);
      if (currentWordsInRef)
        currentWordsInRef.push(wordObject);
      else
        occurrences2.set(refString, [wordObject]);
    });
    return occurrences2;
  }, /* @__PURE__ */ new Map());
  return foundOccurrences;
}
function getTargetQuoteFromWords(_ref3) {
  var targetBook = _ref3.targetBook, wordsMap = _ref3.wordsMap;
  if (!(wordsMap instanceof Map))
    throw new Error("wordsMap should be an instance of Map");
  var quotes = [];
  var _iterator = _createForOfIteratorHelper$2(wordsMap), _step;
  try {
    var _loop2 = function _loop22() {
      var _targetBook$chapter, _targetVerse;
      var _step$value = _slicedToArray$1(_step.value, 2), ref = _step$value[0], wordObjects = _step$value[1];
      var _ref$split3 = ref.split(":"), _ref$split4 = _slicedToArray$1(_ref$split3, 2), chapter = _ref$split4[0], verse = _ref$split4[1];
      var targetChapter = (_targetBook$chapter = targetBook[chapter]) !== null && _targetBook$chapter !== void 0 ? _targetBook$chapter : {};
      var targetVerse = targetChapter === null || targetChapter === void 0 ? void 0 : targetChapter[verse];
      if (!targetVerse) {
        var verses = Object.keys(targetChapter).find(function(verse2) {
          var currentRef = "".concat(chapter, ":").concat(verse2);
          return dist.doesReferenceContain(currentRef, ref);
        });
        targetVerse = targetChapter === null || targetChapter === void 0 ? void 0 : targetChapter[verses];
      }
      var verseObjects = (_targetVerse = targetVerse) === null || _targetVerse === void 0 ? void 0 : _targetVerse.verseObjects;
      if (!verseObjects)
        throw new Error("targetBook does not contain verseObjects for reference: ".concat(ref));
      var refQuotes = getTargetQuotesFromOrigWords({
        wordObjects,
        verseObjects,
        isMatch: false
      });
      quotes.push(refQuotes);
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop2();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return quotes.join(" " + QUOTE_ELLIPSIS + " ");
}
function getTargetQuoteFromSourceQuote(_ref4) {
  var quote = _ref4.quote, ref = _ref4.ref, sourceBook = _ref4.sourceBook, targetBook = _ref4.targetBook, options = _ref4.options;
  var _options$occurrence = options.occurrence, o = _options$occurrence === void 0 ? -1 : _options$occurrence, _options$fromOrigLang = options.fromOrigLang, fromOrigLang = _options$fromOrigLang === void 0 ? true : _options$fromOrigLang;
  var occurrence = parseInt(o, 10);
  var quoteMatches = getQuoteMatchesInBookRef({
    quote,
    ref,
    bookObject: sourceBook,
    isOrigLang: fromOrigLang,
    occurrence
  });
  var targetQuotes = getTargetQuoteFromWords({
    targetBook,
    wordsMap: quoteMatches
  });
  return targetQuotes;
}
export {
  cleanQuoteString,
  getParsedUSFM,
  getQuoteMatchesInBookRef,
  getTargetQuoteFromSourceQuote,
  getTargetQuoteFromWords,
  getTargetQuotesFromOrigWords,
  normalize,
  refToString,
  setBook,
  tokenizeQuote,
  tokenizer,
  verseObjectsToString
};
