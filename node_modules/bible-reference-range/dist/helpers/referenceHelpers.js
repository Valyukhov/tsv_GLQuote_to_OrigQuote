"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.characterizeReference = characterizeReference;
exports.cleanupReference = cleanupReference;
exports.convertReferenceChunksToString = convertReferenceChunksToString;
exports.getVerseList = getVerseList;
exports.getVerseSpanRange = getVerseSpanRange;
exports.getVerses = getVerses;
exports.isVerseInRange = isVerseInRange;
exports.isVerseList = isVerseList;
exports.isVerseSet = isVerseSet;
exports.isVerseSpan = isVerseSpan;
exports.parseReferenceToList = parseReferenceToList;
exports.toInt = toInt;
exports.toIntIfValid = toIntIfValid;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// list of possible hyphen and dash characters used for range separator
var RANGE_SEPARATORS = ['-', // HYPHEN-MINUS
"\xAD", // SOFT HYPHEN
"\u2010", // HYPHEN
"\u2011", // NON-BREAKING HYPHEN
"\u2012", // FIGURE DASH
"\u2013", // EN DASH
"\u2014" // EM DASH
];
var ZERO_WIDTH_SPACE = "\u200B";
var NO_BREAK_SPACE = "\xA0";
var ZERO_WIDTH_NO_BREAK_SPACE = "\uFEFF";
/**
 * takes a reference and splits into individual verses or verse spans.
 * @param {string} ref - reference in format such as:
 *   “2:4-5”, “2:3a”, “2-3b-4a”, “2:7,12”, “7:11-8:2”, "6:15-16;7:2"
 * @return {verseChunk[]}  The Verse Chunk returned
 */

function parseReferenceToList(ref) {
  try {
    var verseChunks = [];
    var refChunks = ref.split(';');
    var lastChapter = 1;

    var _iterator = _createForOfIteratorHelper(refChunks),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var refChunk = _step.value;

        // 1:1-23,32 ; 1-3
        if (!refChunk) {
          continue;
        } // If no semicolon (no verses), reference is either a chapter, chapter range, or invalid


        if (!refChunk.includes(':')) {
          verseChunks = addChapterReference(verseChunks, refChunk);
          continue;
        }

        var verseParts = refChunk.split(','); // get the object from the first chunk before the comma

        var _getChapterVerse = getChapterVerse(verseParts[0]),
            chapter = _getChapterVerse.chapter,
            verse = _getChapterVerse.verse,
            foundChapterVerse = _getChapterVerse.foundChapterVerse;

        if (!foundChapterVerse) {
          chapter = verse;
          verse = null;
        }

        lastChapter = chapter;
        var range = getRange(verse);
        verseChunks.push(_objectSpread(_objectSpread({}, range), {}, {
          chapter: chapter
        }));

        if (range.endChapter) {
          lastChapter = range.endChapter;
        } // get the object from the rest of the chunks after the comma


        for (var i = 1; i < verseParts.length; i++) {
          var versePart = verseParts[i];

          if (!versePart) {
            continue;
          }

          var _getChapterVerse2 = getChapterVerse(versePart),
              chapter_ = _getChapterVerse2.chapter,
              verse_ = _getChapterVerse2.verse,
              _foundChapterVerse = _getChapterVerse2.foundChapterVerse;

          if (_foundChapterVerse) {
            chapter = chapter_;
            verse = verse_;
            lastChapter = chapter;
          } else {
            chapter = lastChapter;
            verse = verse_;
          }

          var _range = getRange(verse);

          if (_range.endVerse) {
            verseChunks.push(_objectSpread(_objectSpread({}, _range), {}, {
              chapter: chapter
            }));

            if (_range.endChapter) {
              lastChapter = _range.endChapter;
            }
          } else {
            // not range
            verseChunks.push({
              verse: _range.verse,
              chapter: chapter
            });
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return verseChunks;
  } catch (e) {
    console.warn("parseReferenceToList() - invalid ref: \"".concat(ref, "\""), e);
  }

  return null;
}
/**
 * @private 
 * If valid chapter reference, add chapter object to verse chunks list
 * 
 * @param {verseChunk[]} verseChunks - Array of verse chunks
 * @param {string} chapterRef - Chapter reference to add to verse chunks
 * @returns {verseChunks[]} - Array copy with new chapter reference if valid, or input array if not
 */


function addChapterReference(verseChunks, chapterRef) {
  var isRange = getRangeSeparator(chapterRef) >= 0;

  if (isRange) {
    var pos = getRangeSeparator(chapterRef);
    var foundRange = pos >= 0;

    if (foundRange) {
      var start = toIntIfValid(chapterRef.substring(0, pos));
      var end = toIntIfValid(chapterRef.substring(pos + 1));
      return [].concat(_toConsumableArray(verseChunks), [{
        chapter: start,
        endChapter: end
      }]);
    }
  } else {
    return [].concat(_toConsumableArray(verseChunks), [{
      chapter: toIntIfValid(chapterRef)
    }]);
  }

  return verseChunks;
}
/**
 * convert array of Reference chunks to reference string
 * @param {array} chunks
 * @return {string}
 */


function convertReferenceChunksToString(chunks) {
  var result = '';

  try {
    var lastChapter = null;
    var lastChunk = null;

    if (Array.isArray(chunks)) {
      var _iterator2 = _createForOfIteratorHelper(chunks),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var chunk = _step2.value;

          if (chunk.endChapter) {
            if (result) {
              result += ';';
            } // Check for chapter range without verses


            if (!chunk.verse) {
              result += "".concat(chunk.chapter, "-").concat(chunk.endChapter);
            } else {
              result += "".concat(chunk.chapter, ":").concat(chunk.verse, "-").concat(chunk.endChapter, ":").concat(chunk.endVerse);
            }

            lastChapter = chunk.endChapter;
          } else {
            if (lastChapter !== chunk.chapter || lastChunk && lastChunk.endChapter) {
              if (result) {
                result += ';';
              }

              result += "".concat(chunk.chapter) + (chunk.verse ? ':' : '');
              lastChapter = chunk.chapter;
            } else {
              // same chapter
              if (result) {
                result += ',';
              }
            } // check for solo chapter


            if (chunk.verse) {
              result += "".concat(chunk.verse);
            }

            if (chunk.endVerse) {
              if (chunk.endVerse === 'ff') {
                result += chunk.endVerse;
              } else {
                result += "-".concat(chunk.endVerse);
              }
            }
          }

          lastChunk = chunk;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (e) {
    console.warn("convertReferenceChunksToString() - invalid chunks: \"".concat(JSON.stringify(chunks), "\""));
  }

  return result;
}
/**
 * check to see if single reference
 * @param {array} chunks
 * @param {string} refStr
 * @return {{chapter, verse, verseStr}}
 */


function characterizeReference(chunks, refStr) {
  var results = {};

  if (chunks && chunks.length && refStr) {
    var multiverse = false;
    var verseStr = null;
    results.chapter = chunks[0].chapter;
    results.verse = chunks[0].verse;
    var pos = refStr.indexOf(':');

    if (pos >= 0) {
      verseStr = refStr.substring(pos + 1);
    }

    if (chunks.length > 1) {
      multiverse = true;
    } else if (chunks[0].endVerse) {
      multiverse = true;
    }

    if (multiverse) {
      results.verseStr = verseStr;
      results.verse = verseStr;
    }
  }

  return results;
}
/**
 * takes a reference and splits into individual verses or verse spans for cleanup.  Then recombines the cleaned up references to a string.
 * @param {string} ref - reference in format such as:
 *   “2:4-5”, “2:3a”, “2-3b-4a”, “2:7,12”, “7:11-8:2”, "6:15-16;7:2"
 * @return {array|string}
 */


function cleanupReference(ref) {
  var chunks = parseReferenceToList(ref);
  var cleanedRef = convertReferenceChunksToString(chunks);
  var results = characterizeReference(chunks, cleanedRef);
  results.cleanedRef = cleanedRef;
  return results;
}
/**
* splits verse list into individual verses
* @param {string} verseStr
* @return {array} - Array of individual verse Integers
*/


function getVerseList(verseStr) {
  var verses = verseStr.toString().split(',');
  return verses;
}
/**
 * test if verse is valid verse span string
 * @param {string|number} verse
 * @return {boolean}
 */


function isVerseSpan(verse) {
  var isSpan = typeof verse === 'string' && verse.includes('-');
  return isSpan;
}
/**
 * test if verse is valid verse list (verse numbers separated by commas)
 * @param {string|number} verse
 * @return {boolean}
 */


function isVerseList(verse) {
  var isList = typeof verse === 'string' && verse.includes(',');
  return isList;
}
/**
 * test if verse is valid verse span or verse list
 * @param {string|number} verse
 * @return {boolean}
 */


function isVerseSet(verse) {
  var isSet = isVerseSpan(verse) || isVerseList(verse);
  return isSet;
}
/**
 * get verse range from span
 * @param {string} verseSpan
 * @return {{high: number, low: number}}
 */


function getVerseSpanRange(verseSpan) {
  var _verseSpan$split = verseSpan.split('-'),
      _verseSpan$split2 = _slicedToArray(_verseSpan$split, 2),
      low = _verseSpan$split2[0],
      high = _verseSpan$split2[1];

  if (low && high) {
    low = parseInt(low, 10);
    high = parseInt(high, 10);

    if (low > 0 && high >= low) {
      return {
        low: low,
        high: high
      };
    }
  }

  return {};
}
/**
 * make sure that chapter and verse are lower than or equal to end chapter and verse
 * @param {int} chapter
 * @param {int} verse
 * @param {int} endChapter
 * @param {int} endVerse
 * @returns {boolean}
 */


function isVerseInRange(chapter, verse, endChapter, endVerse) {
  if (chapter < endChapter) {
    return true;
  }

  if (chapter === endChapter) {
    if (verse <= endVerse) {
      return true;
    }
  }

  return false;
}
/**
 * check if verse range
 * @param ref
 * @returns {{verse}}
 */


function getRange(ref) {
  var refType = _typeof(ref);

  var isNumber = refType === 'number';

  if (!isNumber) {
    var pos = getRangeSeparator(ref);
    var foundRange = pos >= 0;

    if (foundRange) {
      var start = toIntIfValid(ref.substring(0, pos));
      var endStr = ref.substring(pos + 1);

      var _getChapterVerse3 = getChapterVerse(endStr),
          chapter = _getChapterVerse3.chapter,
          verse = _getChapterVerse3.verse,
          foundChapterVerse = _getChapterVerse3.foundChapterVerse;

      if (foundChapterVerse) {
        return {
          verse: start,
          endChapter: chapter,
          endVerse: verse
        };
      } else {
        return {
          verse: start,
          endVerse: toIntIfValid(endStr)
        };
      }
    } else if (ref.toLowerCase().includes('ff')) {
      var followingPos = ref.indexOf('ff');

      var _start = toIntIfValid(ref.substring(0, followingPos));

      return {
        verse: _start,
        endVerse: 'ff'
      };
    }
  }

  return {
    verse: ref
  };
}
/**
 * @private 
 * parse ref to see if chapter:verse
 * @param ref
 * @returns {{chapter: string, foundChapterVerse: boolean, verse: string}}
 */


function getChapterVerse(ref) {
  if (typeof ref !== 'string') {
    return {
      verse: ref
    };
  }

  var pos = (ref || '').indexOf(':');
  var foundChapterVerse = pos >= 0;
  var chapter, verse;

  if (foundChapterVerse) {
    chapter = toIntIfValid(ref.substring(0, pos));
    verse = toIntIfValid(ref.substring(pos + 1));
  } else {
    verse = toIntIfValid(ref);
  }

  return {
    chapter: chapter,
    verse: verse,
    foundChapterVerse: foundChapterVerse
  };
}
/**
 * convert value to int if string, otherwise just return value
 * @param {string|int} value
 * @returns {int}
 */


function toInt(value) {
  return typeof value === 'string' ? parseInt(value, 10) : value;
}
/**
 * return integer of value (string or int) if valid, otherwise just return value
 * @param {string|int} value
 * @returns {int|int}
 */


function toIntIfValid(value) {
  if (typeof value === 'string') {
    var pos = getRangeSeparator(value);

    if (pos >= 0) {
      return value;
    }

    if (value.includes('ff')) {
      return value;
    }

    var intValue = toInt(value);

    if (!isNaN(intValue)) {
      return intValue;
    }
  }

  return value;
}
/**
 * @private 
 * look for possible dash and hyphen character to see if versePart is a verse range
 * @param {string} versePart
 * @return {number} position of dash or hyphen found, or -1 if not found
 */


function getRangeSeparator(versePart) {
  var _iterator3 = _createForOfIteratorHelper(RANGE_SEPARATORS),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var separator = _step3.value;
      var pos = versePart.indexOf(separator);

      if (pos >= 0) {
        return pos;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return -1;
}
/**
 * @private 
   * check if verse is within a verse range (e.g. 2-4)
 * @param {object} chapterData - indexed by verse ref
 * @param {number} verse - verse to match
 * @param {number} chapter - current chapter
 * @returns {{verseData, verse: number, foundVerseKey, nextVerse}}
 */


function findVerseInVerseRange(chapterData, verse, chapter) {
  var verseKeys = Object.keys(chapterData);
  var foundVerseKey, verseData, verseKey, nextVerse;

  for (var _i2 = 0, _verseKeys = verseKeys; _i2 < _verseKeys.length; _i2++) {
    verseKey = _verseKeys[_i2];

    if (isVerseSpan(verseKey)) {
      var _getVerseSpanRange = getVerseSpanRange(verseKey),
          low = _getVerseSpanRange.low,
          high = _getVerseSpanRange.high;

      if (verse >= low && verse <= high) {
        verseData = chapterData[verseKey];
        foundVerseKey = verse;
        nextVerse = high + 1; // move to verse after range

        break;
      }
    }
  }

  return {
    foundVerseKey: foundVerseKey,
    verse: verseKey,
    verseData: verseData,
    nextVerse: nextVerse
  };
}
/**
 * finds all verses from bookData contained in ref, then returns array of references and verse data
 * @param {object} bookData - indexed by chapter and then verse ref
 * @param {string} ref - formats such as “2:4-5”, “2:3a”, “2-3b-4a”, “2:7,12”, “7:11-8:2”, "6:15-16;7:2"
 * @returns {Object[]} - Array of objects with chapter, verse, verseData values
 */


function getVerses(bookData, ref) {
  var verses = [];
  var chunks = parseReferenceToList(ref);
  var chapterData, verseData;

  var _iterator4 = _createForOfIteratorHelper(chunks),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var chunk = _step4.value;

      if (!chunk.endVerse) {
        var chapter = chunk.chapter;
        chapterData = bookData[chapter];
        var verseKey = chunk.verse;
        verseData = chapterData && chapterData[verseKey];

        if (!verseData && chapterData) {
          // if verse doesn't exist, check for verse spans in chapter data
          var __ret = findVerseInVerseRange(chapterData, verseKey, chapter);

          if (__ret.foundVerseKey) {
            verseKey = __ret.verse;
            verseData = __ret.verseData;
          }
        }

        verses.push({
          chapter: chapter,
          verse: verseKey,
          verseData: verseData
        });
      } else {
        // handle range
        var _chapter = chunk.chapter;
        var verse = chunk.verse;
        var endVerse = chunk.endVerse;
        var endChapter = chunk.endChapter || _chapter;

        while (isVerseInRange(_chapter, verse, endChapter, endVerse)) {
          chapterData = bookData[_chapter];
          verseData = chapterData && chapterData[verse];
          var _verseKey = verse;

          if (!verseData && chapterData) {
            // if verse doesn't exist, check for verse spans in chapter data
            var _ret = findVerseInVerseRange(chapterData, _verseKey, _chapter);

            if (_ret.foundVerseKey) {
              _verseKey = _ret.verse;
              verseData = _ret.verseData;
              verse = _ret.nextVerse - 1; // correct for autoincrement
            }
          }

          if (!verseData) {
            // if past end of chapter, skip to next
            _chapter += 1;
            verse = 1;
            continue;
          }

          verses.push({
            chapter: _chapter,
            verse: _verseKey,
            verseData: verseData
          });
          verse += 1;
        }
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return verses;
}
/**
 * @typedef {Object} verseChunk Object representing a chapter reference or reference range
 * @property {number} verseChunk.chapter
 * @property {number} verseChunk.verse
 * @property {number} verseChunk.endChapter
 * @property {number} verseChunk.endVerse
 */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJSQU5HRV9TRVBBUkFUT1JTIiwiWkVST19XSURUSF9TUEFDRSIsIk5PX0JSRUFLX1NQQUNFIiwiWkVST19XSURUSF9OT19CUkVBS19TUEFDRSIsInBhcnNlUmVmZXJlbmNlVG9MaXN0IiwicmVmIiwidmVyc2VDaHVua3MiLCJyZWZDaHVua3MiLCJzcGxpdCIsImxhc3RDaGFwdGVyIiwicmVmQ2h1bmsiLCJpbmNsdWRlcyIsImFkZENoYXB0ZXJSZWZlcmVuY2UiLCJ2ZXJzZVBhcnRzIiwiZ2V0Q2hhcHRlclZlcnNlIiwiY2hhcHRlciIsInZlcnNlIiwiZm91bmRDaGFwdGVyVmVyc2UiLCJyYW5nZSIsImdldFJhbmdlIiwicHVzaCIsImVuZENoYXB0ZXIiLCJpIiwibGVuZ3RoIiwidmVyc2VQYXJ0IiwiY2hhcHRlcl8iLCJ2ZXJzZV8iLCJlbmRWZXJzZSIsImUiLCJjb25zb2xlIiwid2FybiIsImNoYXB0ZXJSZWYiLCJpc1JhbmdlIiwiZ2V0UmFuZ2VTZXBhcmF0b3IiLCJwb3MiLCJmb3VuZFJhbmdlIiwic3RhcnQiLCJ0b0ludElmVmFsaWQiLCJzdWJzdHJpbmciLCJlbmQiLCJjb252ZXJ0UmVmZXJlbmNlQ2h1bmtzVG9TdHJpbmciLCJjaHVua3MiLCJyZXN1bHQiLCJsYXN0Q2h1bmsiLCJBcnJheSIsImlzQXJyYXkiLCJjaHVuayIsIkpTT04iLCJzdHJpbmdpZnkiLCJjaGFyYWN0ZXJpemVSZWZlcmVuY2UiLCJyZWZTdHIiLCJyZXN1bHRzIiwibXVsdGl2ZXJzZSIsInZlcnNlU3RyIiwiaW5kZXhPZiIsImNsZWFudXBSZWZlcmVuY2UiLCJjbGVhbmVkUmVmIiwiZ2V0VmVyc2VMaXN0IiwidmVyc2VzIiwidG9TdHJpbmciLCJpc1ZlcnNlU3BhbiIsImlzU3BhbiIsImlzVmVyc2VMaXN0IiwiaXNMaXN0IiwiaXNWZXJzZVNldCIsImlzU2V0IiwiZ2V0VmVyc2VTcGFuUmFuZ2UiLCJ2ZXJzZVNwYW4iLCJsb3ciLCJoaWdoIiwicGFyc2VJbnQiLCJpc1ZlcnNlSW5SYW5nZSIsInJlZlR5cGUiLCJpc051bWJlciIsImVuZFN0ciIsInRvTG93ZXJDYXNlIiwiZm9sbG93aW5nUG9zIiwidG9JbnQiLCJ2YWx1ZSIsImludFZhbHVlIiwiaXNOYU4iLCJzZXBhcmF0b3IiLCJmaW5kVmVyc2VJblZlcnNlUmFuZ2UiLCJjaGFwdGVyRGF0YSIsInZlcnNlS2V5cyIsIk9iamVjdCIsImtleXMiLCJmb3VuZFZlcnNlS2V5IiwidmVyc2VEYXRhIiwidmVyc2VLZXkiLCJuZXh0VmVyc2UiLCJnZXRWZXJzZXMiLCJib29rRGF0YSIsIl9fcmV0Il0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL2hlbHBlcnMvcmVmZXJlbmNlSGVscGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBsaXN0IG9mIHBvc3NpYmxlIGh5cGhlbiBhbmQgZGFzaCBjaGFyYWN0ZXJzIHVzZWQgZm9yIHJhbmdlIHNlcGFyYXRvclxuY29uc3QgUkFOR0VfU0VQQVJBVE9SUyA9IFtcbiAgICAnLScsIC8vIEhZUEhFTi1NSU5VU1xuICAgICdcXHUwMEFEJywgLy8gU09GVCBIWVBIRU5cbiAgICAnXFx1MjAxMCcsIC8vIEhZUEhFTlxuICAgICdcXHUyMDExJywgLy8gTk9OLUJSRUFLSU5HIEhZUEhFTlxuICAgICdcXHUyMDEyJywgLy8gRklHVVJFIERBU0hcbiAgICAnXFx1MjAxMycsIC8vIEVOIERBU0hcbiAgICAnXFx1MjAxNCcsIC8vIEVNIERBU0hcbiAgXTtcbiAgY29uc3QgWkVST19XSURUSF9TUEFDRSA9ICdcXHUyMDBCJztcbiAgY29uc3QgTk9fQlJFQUtfU1BBQ0UgPSAnXFx1MDBBMCc7XG4gIGNvbnN0IFpFUk9fV0lEVEhfTk9fQlJFQUtfU1BBQ0UgPSAnXFx1RkVGRic7XG5cbi8qKlxuICogdGFrZXMgYSByZWZlcmVuY2UgYW5kIHNwbGl0cyBpbnRvIGluZGl2aWR1YWwgdmVyc2VzIG9yIHZlcnNlIHNwYW5zLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiAtIHJlZmVyZW5jZSBpbiBmb3JtYXQgc3VjaCBhczpcbiAqICAg4oCcMjo0LTXigJ0sIOKAnDI6M2HigJ0sIOKAnDItM2ItNGHigJ0sIOKAnDI6NywxMuKAnSwg4oCcNzoxMS04OjLigJ0sIFwiNjoxNS0xNjs3OjJcIlxuICogQHJldHVybiB7dmVyc2VDaHVua1tdfSAgVGhlIFZlcnNlIENodW5rIHJldHVybmVkXG4gKi9cbiBleHBvcnQgZnVuY3Rpb24gcGFyc2VSZWZlcmVuY2VUb0xpc3QocmVmKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCB2ZXJzZUNodW5rcyA9IFtdO1xuICAgICAgY29uc3QgcmVmQ2h1bmtzID0gcmVmLnNwbGl0KCc7Jyk7XG4gICAgICBsZXQgbGFzdENoYXB0ZXIgPSAxO1xuICBcbiAgICAgIGZvciAoY29uc3QgcmVmQ2h1bmsgb2YgcmVmQ2h1bmtzKSB7XG4gICAgICAgIC8vIDE6MS0yMywzMiA7IDEtM1xuICAgICAgICBpZiAoIXJlZkNodW5rKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBubyBzZW1pY29sb24gKG5vIHZlcnNlcyksIHJlZmVyZW5jZSBpcyBlaXRoZXIgYSBjaGFwdGVyLCBjaGFwdGVyIHJhbmdlLCBvciBpbnZhbGlkXG4gICAgICAgIGlmICghcmVmQ2h1bmsuaW5jbHVkZXMoJzonKSkge1xuICAgICAgICAgIHZlcnNlQ2h1bmtzID0gYWRkQ2hhcHRlclJlZmVyZW5jZSh2ZXJzZUNodW5rcywgcmVmQ2h1bmspXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIFxuICBcbiAgICAgICAgY29uc3QgdmVyc2VQYXJ0cyA9IHJlZkNodW5rLnNwbGl0KCcsJyk7XG4gICAgICAgIC8vIGdldCB0aGUgb2JqZWN0IGZyb20gdGhlIGZpcnN0IGNodW5rIGJlZm9yZSB0aGUgY29tbWFcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjaGFwdGVyLFxuICAgICAgICAgIHZlcnNlLFxuICAgICAgICAgIGZvdW5kQ2hhcHRlclZlcnNlLFxuICAgICAgICB9ID0gZ2V0Q2hhcHRlclZlcnNlKHZlcnNlUGFydHNbMF0pO1xuICBcbiAgICAgICAgaWYgKCFmb3VuZENoYXB0ZXJWZXJzZSkge1xuICAgICAgICAgIGNoYXB0ZXIgPSB2ZXJzZTtcbiAgICAgICAgICB2ZXJzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgXG4gICAgICAgIGxhc3RDaGFwdGVyID0gY2hhcHRlcjtcbiAgXG4gICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0UmFuZ2UodmVyc2UpO1xuICBcbiAgICAgICAgdmVyc2VDaHVua3MucHVzaCh7XG4gICAgICAgICAgLi4ucmFuZ2UsXG4gICAgICAgICAgY2hhcHRlcixcbiAgICAgICAgfSk7XG4gIFxuICAgICAgICBpZiAocmFuZ2UuZW5kQ2hhcHRlcikge1xuICAgICAgICAgIGxhc3RDaGFwdGVyID0gcmFuZ2UuZW5kQ2hhcHRlcjtcbiAgICAgICAgfVxuICBcbiAgICAgICAgLy8gZ2V0IHRoZSBvYmplY3QgZnJvbSB0aGUgcmVzdCBvZiB0aGUgY2h1bmtzIGFmdGVyIHRoZSBjb21tYVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZlcnNlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB2ZXJzZVBhcnQgPSB2ZXJzZVBhcnRzW2ldO1xuICBcbiAgICAgICAgICBpZiAoIXZlcnNlUGFydCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY2hhcHRlcjogY2hhcHRlcl8sXG4gICAgICAgICAgICB2ZXJzZTogdmVyc2VfLFxuICAgICAgICAgICAgZm91bmRDaGFwdGVyVmVyc2UsXG4gICAgICAgICAgfSA9IGdldENoYXB0ZXJWZXJzZSh2ZXJzZVBhcnQpO1xuICBcbiAgICAgICAgICBpZiAoZm91bmRDaGFwdGVyVmVyc2UpIHtcbiAgICAgICAgICAgIGNoYXB0ZXIgPSBjaGFwdGVyXztcbiAgICAgICAgICAgIHZlcnNlID0gdmVyc2VfO1xuICAgICAgICAgICAgbGFzdENoYXB0ZXIgPSBjaGFwdGVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFwdGVyID0gbGFzdENoYXB0ZXI7XG4gICAgICAgICAgICB2ZXJzZSA9IHZlcnNlXztcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0UmFuZ2UodmVyc2UpO1xuICBcbiAgICAgICAgICBpZiAocmFuZ2UuZW5kVmVyc2UpIHtcbiAgICAgICAgICAgIHZlcnNlQ2h1bmtzLnB1c2goe1xuICAgICAgICAgICAgICAuLi5yYW5nZSxcbiAgICAgICAgICAgICAgY2hhcHRlcixcbiAgICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbmRDaGFwdGVyKSB7XG4gICAgICAgICAgICAgIGxhc3RDaGFwdGVyID0gcmFuZ2UuZW5kQ2hhcHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgeyAvLyBub3QgcmFuZ2VcbiAgICAgICAgICAgIHZlcnNlQ2h1bmtzLnB1c2goe1xuICAgICAgICAgICAgICB2ZXJzZTogcmFuZ2UudmVyc2UsXG4gICAgICAgICAgICAgIGNoYXB0ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2ZXJzZUNodW5rcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYHBhcnNlUmVmZXJlbmNlVG9MaXN0KCkgLSBpbnZhbGlkIHJlZjogXCIke3JlZn1cImAsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBcbiAgICogSWYgdmFsaWQgY2hhcHRlciByZWZlcmVuY2UsIGFkZCBjaGFwdGVyIG9iamVjdCB0byB2ZXJzZSBjaHVua3MgbGlzdFxuICAgKiBcbiAgICogQHBhcmFtIHt2ZXJzZUNodW5rW119IHZlcnNlQ2h1bmtzIC0gQXJyYXkgb2YgdmVyc2UgY2h1bmtzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFwdGVyUmVmIC0gQ2hhcHRlciByZWZlcmVuY2UgdG8gYWRkIHRvIHZlcnNlIGNodW5rc1xuICAgKiBAcmV0dXJucyB7dmVyc2VDaHVua3NbXX0gLSBBcnJheSBjb3B5IHdpdGggbmV3IGNoYXB0ZXIgcmVmZXJlbmNlIGlmIHZhbGlkLCBvciBpbnB1dCBhcnJheSBpZiBub3RcbiAgICovXG4gIGZ1bmN0aW9uIGFkZENoYXB0ZXJSZWZlcmVuY2UodmVyc2VDaHVua3MsIGNoYXB0ZXJSZWYpIHtcbiAgICBjb25zdCBpc1JhbmdlID0gZ2V0UmFuZ2VTZXBhcmF0b3IoY2hhcHRlclJlZikgPj0gMFxuICAgIFxuICAgIGlmIChpc1JhbmdlKSB7XG4gICAgICBjb25zdCBwb3MgPSBnZXRSYW5nZVNlcGFyYXRvcihjaGFwdGVyUmVmKTtcbiAgICAgIGNvbnN0IGZvdW5kUmFuZ2UgPSBwb3MgPj0gMDtcblxuICAgICAgaWYgKGZvdW5kUmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0b0ludElmVmFsaWQoY2hhcHRlclJlZi5zdWJzdHJpbmcoMCwgcG9zKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRvSW50SWZWYWxpZChjaGFwdGVyUmVmLnN1YnN0cmluZyhwb3MgKyAxKSk7XG5cbiAgICAgICAgcmV0dXJuIFsuLi52ZXJzZUNodW5rcywge2NoYXB0ZXI6IHN0YXJ0LCBlbmRDaGFwdGVyOiBlbmR9XVxuICAgICAgfSBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFsuLi52ZXJzZUNodW5rcywge2NoYXB0ZXI6IHRvSW50SWZWYWxpZChjaGFwdGVyUmVmKX1dXG4gICAgfVxuXG4gICAgcmV0dXJuIHZlcnNlQ2h1bmtzXG4gIH1cbiAgXG4gIC8qKlxuICAgKiBjb252ZXJ0IGFycmF5IG9mIFJlZmVyZW5jZSBjaHVua3MgdG8gcmVmZXJlbmNlIHN0cmluZ1xuICAgKiBAcGFyYW0ge2FycmF5fSBjaHVua3NcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSZWZlcmVuY2VDaHVua3NUb1N0cmluZyhjaHVua3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gIFxuICAgIHRyeSB7XG4gICAgICBsZXQgbGFzdENoYXB0ZXIgPSBudWxsO1xuICAgICAgbGV0IGxhc3RDaHVuayA9IG51bGw7XG4gIFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2h1bmtzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgIGlmIChjaHVuay5lbmRDaGFwdGVyKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY2hhcHRlciByYW5nZSB3aXRob3V0IHZlcnNlc1xuICAgICAgICAgICAgaWYgKCFjaHVuay52ZXJzZSkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gYCR7Y2h1bmsuY2hhcHRlcn0tJHtjaHVuay5lbmRDaGFwdGVyfWBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBgJHtjaHVuay5jaGFwdGVyfToke2NodW5rLnZlcnNlfS0ke2NodW5rLmVuZENoYXB0ZXJ9OiR7Y2h1bmsuZW5kVmVyc2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RDaGFwdGVyID0gY2h1bmsuZW5kQ2hhcHRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKChsYXN0Q2hhcHRlciAhPT0gY2h1bmsuY2hhcHRlcikgfHwgKGxhc3RDaHVuayAmJiBsYXN0Q2h1bmsuZW5kQ2hhcHRlcikpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGAke2NodW5rLmNoYXB0ZXJ9YCArIChjaHVuay52ZXJzZSA/ICc6JyA6ICcnKTtcbiAgICAgICAgICAgICAgbGFzdENoYXB0ZXIgPSBjaHVuay5jaGFwdGVyO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gc2FtZSBjaGFwdGVyXG4gICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igc29sbyBjaGFwdGVyXG4gICAgICAgICAgICBpZiAoY2h1bmsudmVyc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBgJHtjaHVuay52ZXJzZX1gO1xuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIGlmIChjaHVuay5lbmRWZXJzZSkge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsuZW5kVmVyc2UgPT09ICdmZicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2h1bmsuZW5kVmVyc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGAtJHtjaHVuay5lbmRWZXJzZX1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdENodW5rID0gY2h1bms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGNvbnZlcnRSZWZlcmVuY2VDaHVua3NUb1N0cmluZygpIC0gaW52YWxpZCBjaHVua3M6IFwiJHtKU09OLnN0cmluZ2lmeShjaHVua3MpfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBjaGVjayB0byBzZWUgaWYgc2luZ2xlIHJlZmVyZW5jZVxuICAgKiBAcGFyYW0ge2FycmF5fSBjaHVua3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZlN0clxuICAgKiBAcmV0dXJuIHt7Y2hhcHRlciwgdmVyc2UsIHZlcnNlU3RyfX1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBjaGFyYWN0ZXJpemVSZWZlcmVuY2UoY2h1bmtzLCByZWZTdHIpIHtcbiAgICBjb25zdCByZXN1bHRzID0ge307XG4gIFxuICAgIGlmIChjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCAmJiByZWZTdHIpIHtcbiAgICAgIGxldCBtdWx0aXZlcnNlID0gZmFsc2U7XG4gICAgICBsZXQgdmVyc2VTdHIgPSBudWxsO1xuICAgICAgcmVzdWx0cy5jaGFwdGVyID0gY2h1bmtzWzBdLmNoYXB0ZXI7XG4gICAgICByZXN1bHRzLnZlcnNlID0gY2h1bmtzWzBdLnZlcnNlO1xuICAgICAgY29uc3QgcG9zID0gcmVmU3RyLmluZGV4T2YoJzonKTtcbiAgXG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgdmVyc2VTdHIgPSByZWZTdHIuc3Vic3RyaW5nKHBvcyArIDEpO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChjaHVua3MubGVuZ3RoID4gMSkge1xuICAgICAgICBtdWx0aXZlcnNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmtzWzBdLmVuZFZlcnNlKSB7XG4gICAgICAgIG11bHRpdmVyc2UgPSB0cnVlO1xuICAgICAgfVxuICBcbiAgICAgIGlmIChtdWx0aXZlcnNlKSB7XG4gICAgICAgIHJlc3VsdHMudmVyc2VTdHIgPSB2ZXJzZVN0cjtcbiAgICAgICAgcmVzdWx0cy52ZXJzZSA9IHZlcnNlU3RyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBcbiAgLyoqXG4gICAqIHRha2VzIGEgcmVmZXJlbmNlIGFuZCBzcGxpdHMgaW50byBpbmRpdmlkdWFsIHZlcnNlcyBvciB2ZXJzZSBzcGFucyBmb3IgY2xlYW51cC4gIFRoZW4gcmVjb21iaW5lcyB0aGUgY2xlYW5lZCB1cCByZWZlcmVuY2VzIHRvIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIC0gcmVmZXJlbmNlIGluIGZvcm1hdCBzdWNoIGFzOlxuICAgKiAgIOKAnDI6NC014oCdLCDigJwyOjNh4oCdLCDigJwyLTNiLTRh4oCdLCDigJwyOjcsMTLigJ0sIOKAnDc6MTEtODoy4oCdLCBcIjY6MTUtMTY7NzoyXCJcbiAgICogQHJldHVybiB7YXJyYXl8c3RyaW5nfVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBSZWZlcmVuY2UocmVmKSB7XG4gICAgY29uc3QgY2h1bmtzID0gcGFyc2VSZWZlcmVuY2VUb0xpc3QocmVmKTtcbiAgICBjb25zdCBjbGVhbmVkUmVmID0gY29udmVydFJlZmVyZW5jZUNodW5rc1RvU3RyaW5nKGNodW5rcyk7XG4gIFxuICAgIGxldCByZXN1bHRzID0gY2hhcmFjdGVyaXplUmVmZXJlbmNlKGNodW5rcywgY2xlYW5lZFJlZik7XG4gICAgcmVzdWx0cy5jbGVhbmVkUmVmID0gY2xlYW5lZFJlZjtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICogc3BsaXRzIHZlcnNlIGxpc3QgaW50byBpbmRpdmlkdWFsIHZlcnNlc1xuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNlU3RyXG4gKiBAcmV0dXJuIHthcnJheX0gLSBBcnJheSBvZiBpbmRpdmlkdWFsIHZlcnNlIEludGVnZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzZUxpc3QodmVyc2VTdHIpIHtcbiAgICBjb25zdCB2ZXJzZXMgPSB2ZXJzZVN0ci50b1N0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgcmV0dXJuIHZlcnNlcztcbiAgfVxuICBcbiAgLyoqXG4gICAqIHRlc3QgaWYgdmVyc2UgaXMgdmFsaWQgdmVyc2Ugc3BhbiBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2ZXJzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2VTcGFuKHZlcnNlKSB7XG4gICAgY29uc3QgaXNTcGFuID0gKHR5cGVvZiB2ZXJzZSA9PT0gJ3N0cmluZycpICYmIHZlcnNlLmluY2x1ZGVzKCctJyk7XG4gICAgcmV0dXJuIGlzU3BhbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIHRlc3QgaWYgdmVyc2UgaXMgdmFsaWQgdmVyc2UgbGlzdCAodmVyc2UgbnVtYmVycyBzZXBhcmF0ZWQgYnkgY29tbWFzKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZlcnNlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gaXNWZXJzZUxpc3QodmVyc2UpIHtcbiAgICBjb25zdCBpc0xpc3QgPSAodHlwZW9mIHZlcnNlID09PSAnc3RyaW5nJykgJiYgdmVyc2UuaW5jbHVkZXMoJywnKTtcbiAgICByZXR1cm4gaXNMaXN0O1xuICB9XG4gIFxuICAvKipcbiAgICogdGVzdCBpZiB2ZXJzZSBpcyB2YWxpZCB2ZXJzZSBzcGFuIG9yIHZlcnNlIGxpc3RcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2ZXJzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2VTZXQodmVyc2UpIHtcbiAgICBjb25zdCBpc1NldCA9IGlzVmVyc2VTcGFuKHZlcnNlKSB8fCBpc1ZlcnNlTGlzdCh2ZXJzZSk7XG4gICAgcmV0dXJuIGlzU2V0O1xuICB9XG4gIFxuICAvKipcbiAgICogZ2V0IHZlcnNlIHJhbmdlIGZyb20gc3BhblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmVyc2VTcGFuXG4gICAqIEByZXR1cm4ge3toaWdoOiBudW1iZXIsIGxvdzogbnVtYmVyfX1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRWZXJzZVNwYW5SYW5nZSh2ZXJzZVNwYW4pIHtcbiAgICBsZXQgW2xvdywgaGlnaF0gPSB2ZXJzZVNwYW4uc3BsaXQoJy0nKTtcbiAgXG4gICAgaWYgKGxvdyAmJiBoaWdoKSB7XG4gICAgICBsb3cgPSBwYXJzZUludChsb3csIDEwKTtcbiAgICAgIGhpZ2ggPSBwYXJzZUludChoaWdoLCAxMCk7XG4gIFxuICAgICAgaWYgKChsb3cgPiAwKSAmJiAoaGlnaCA+PSBsb3cpKSB7XG4gICAgICAgIHJldHVybiB7IGxvdywgaGlnaCB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBtYWtlIHN1cmUgdGhhdCBjaGFwdGVyIGFuZCB2ZXJzZSBhcmUgbG93ZXIgdGhhbiBvciBlcXVhbCB0byBlbmQgY2hhcHRlciBhbmQgdmVyc2VcbiAgICogQHBhcmFtIHtpbnR9IGNoYXB0ZXJcbiAgICogQHBhcmFtIHtpbnR9IHZlcnNlXG4gICAqIEBwYXJhbSB7aW50fSBlbmRDaGFwdGVyXG4gICAqIEBwYXJhbSB7aW50fSBlbmRWZXJzZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBpc1ZlcnNlSW5SYW5nZShjaGFwdGVyLCB2ZXJzZSwgZW5kQ2hhcHRlciwgZW5kVmVyc2UpIHtcbiAgICBpZiAoY2hhcHRlciA8IGVuZENoYXB0ZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgXG4gICAgaWYgKGNoYXB0ZXIgPT09IGVuZENoYXB0ZXIpIHtcbiAgICAgIGlmICh2ZXJzZSA8PSBlbmRWZXJzZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuXG5cbi8qKlxuICogY2hlY2sgaWYgdmVyc2UgcmFuZ2VcbiAqIEBwYXJhbSByZWZcbiAqIEByZXR1cm5zIHt7dmVyc2V9fVxuICovXG5mdW5jdGlvbiBnZXRSYW5nZShyZWYpIHtcbiAgICBjb25zdCByZWZUeXBlID0gdHlwZW9mKHJlZik7XG4gICAgY29uc3QgaXNOdW1iZXIgPSByZWZUeXBlID09PSAnbnVtYmVyJztcbiAgXG4gICAgaWYgKCFpc051bWJlcikge1xuICAgICAgY29uc3QgcG9zID0gZ2V0UmFuZ2VTZXBhcmF0b3IocmVmKTtcbiAgICAgIGNvbnN0IGZvdW5kUmFuZ2UgPSBwb3MgPj0gMDtcbiAgXG4gICAgICBpZiAoZm91bmRSYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRvSW50SWZWYWxpZChyZWYuc3Vic3RyaW5nKDAsIHBvcykpO1xuICAgICAgICBjb25zdCBlbmRTdHIgPSByZWYuc3Vic3RyaW5nKHBvcyArIDEpO1xuICBcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjaGFwdGVyLFxuICAgICAgICAgIHZlcnNlLFxuICAgICAgICAgIGZvdW5kQ2hhcHRlclZlcnNlLFxuICAgICAgICB9ID0gZ2V0Q2hhcHRlclZlcnNlKGVuZFN0cik7XG4gIFxuICAgICAgICBpZiAoZm91bmRDaGFwdGVyVmVyc2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2U6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kQ2hhcHRlcjogY2hhcHRlcixcbiAgICAgICAgICAgIGVuZFZlcnNlOiB2ZXJzZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzZTogc3RhcnQsXG4gICAgICAgICAgICBlbmRWZXJzZTogdG9JbnRJZlZhbGlkKGVuZFN0ciksXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWYudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZmYnKSkge1xuICAgICAgICBjb25zdCBmb2xsb3dpbmdQb3MgPSByZWYuaW5kZXhPZignZmYnKVxuICAgICAgICBjb25zdCBzdGFydCA9IHRvSW50SWZWYWxpZChyZWYuc3Vic3RyaW5nKDAsIGZvbGxvd2luZ1BvcykpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmVyc2U6IHN0YXJ0LFxuICAgICAgICAgIGVuZFZlcnNlOiAnZmYnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIHJldHVybiB7IHZlcnNlOiByZWYgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEBwcml2YXRlIFxuICAgKiBwYXJzZSByZWYgdG8gc2VlIGlmIGNoYXB0ZXI6dmVyc2VcbiAgICogQHBhcmFtIHJlZlxuICAgKiBAcmV0dXJucyB7e2NoYXB0ZXI6IHN0cmluZywgZm91bmRDaGFwdGVyVmVyc2U6IGJvb2xlYW4sIHZlcnNlOiBzdHJpbmd9fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q2hhcHRlclZlcnNlKHJlZikge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHsgdmVyc2U6IHJlZiB9O1xuICAgIH1cbiAgXG4gICAgY29uc3QgcG9zID0gKHJlZiB8fCAnJykuaW5kZXhPZignOicpO1xuICAgIGNvbnN0IGZvdW5kQ2hhcHRlclZlcnNlID0gcG9zID49IDA7XG4gICAgbGV0IGNoYXB0ZXIsIHZlcnNlO1xuICBcbiAgICBpZiAoZm91bmRDaGFwdGVyVmVyc2UpIHtcbiAgICAgIGNoYXB0ZXIgPSB0b0ludElmVmFsaWQocmVmLnN1YnN0cmluZygwLCBwb3MpKTtcbiAgICAgIHZlcnNlID0gdG9JbnRJZlZhbGlkKHJlZi5zdWJzdHJpbmcocG9zICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJzZSA9IHRvSW50SWZWYWxpZChyZWYpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2hhcHRlcixcbiAgICAgIHZlcnNlLFxuICAgICAgZm91bmRDaGFwdGVyVmVyc2UsXG4gICAgfTtcbiAgfVxuXG4vKipcbiAqIGNvbnZlcnQgdmFsdWUgdG8gaW50IGlmIHN0cmluZywgb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnR9IHZhbHVlXG4gKiBAcmV0dXJucyB7aW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9JbnQodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpID8gcGFyc2VJbnQodmFsdWUsIDEwKSA6IHZhbHVlO1xuICB9XG4gIFxuICAvKipcbiAgICogcmV0dXJuIGludGVnZXIgb2YgdmFsdWUgKHN0cmluZyBvciBpbnQpIGlmIHZhbGlkLCBvdGhlcndpc2UganVzdCByZXR1cm4gdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd8aW50fSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7aW50fGludH1cbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiB0b0ludElmVmFsaWQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgcG9zID0gZ2V0UmFuZ2VTZXBhcmF0b3IodmFsdWUpO1xuICBcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnZmYnKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gIFxuICAgICAgY29uc3QgaW50VmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gIFxuICAgICAgaWYgKCFpc05hTihpbnRWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGludFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIFxuICAvKipcbiAgICogQHByaXZhdGUgXG4gICAqIGxvb2sgZm9yIHBvc3NpYmxlIGRhc2ggYW5kIGh5cGhlbiBjaGFyYWN0ZXIgdG8gc2VlIGlmIHZlcnNlUGFydCBpcyBhIHZlcnNlIHJhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2ZXJzZVBhcnRcbiAgICogQHJldHVybiB7bnVtYmVyfSBwb3NpdGlvbiBvZiBkYXNoIG9yIGh5cGhlbiBmb3VuZCwgb3IgLTEgaWYgbm90IGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSYW5nZVNlcGFyYXRvcih2ZXJzZVBhcnQpIHtcbiAgICBmb3IgKGNvbnN0IHNlcGFyYXRvciBvZiBSQU5HRV9TRVBBUkFUT1JTKSB7XG4gICAgICBjb25zdCBwb3MgPSB2ZXJzZVBhcnQuaW5kZXhPZihzZXBhcmF0b3IpO1xuICBcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuLyoqXG4gKiBAcHJpdmF0ZSBcbiAgICogY2hlY2sgaWYgdmVyc2UgaXMgd2l0aGluIGEgdmVyc2UgcmFuZ2UgKGUuZy4gMi00KVxuICogQHBhcmFtIHtvYmplY3R9IGNoYXB0ZXJEYXRhIC0gaW5kZXhlZCBieSB2ZXJzZSByZWZcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzZSAtIHZlcnNlIHRvIG1hdGNoXG4gKiBAcGFyYW0ge251bWJlcn0gY2hhcHRlciAtIGN1cnJlbnQgY2hhcHRlclxuICogQHJldHVybnMge3t2ZXJzZURhdGEsIHZlcnNlOiBudW1iZXIsIGZvdW5kVmVyc2VLZXksIG5leHRWZXJzZX19XG4gKi9cbmZ1bmN0aW9uIGZpbmRWZXJzZUluVmVyc2VSYW5nZShjaGFwdGVyRGF0YSwgdmVyc2UsIGNoYXB0ZXIpIHtcbiAgY29uc3QgdmVyc2VLZXlzID0gT2JqZWN0LmtleXMoY2hhcHRlckRhdGEpO1xuICBsZXQgZm91bmRWZXJzZUtleSwgdmVyc2VEYXRhLCB2ZXJzZUtleSwgbmV4dFZlcnNlO1xuXG4gIGZvciAodmVyc2VLZXkgb2YgdmVyc2VLZXlzKSB7XG4gICAgaWYgKGlzVmVyc2VTcGFuKHZlcnNlS2V5KSkge1xuICAgICAgY29uc3Qge2xvdywgaGlnaH0gPSBnZXRWZXJzZVNwYW5SYW5nZSh2ZXJzZUtleSk7XG5cbiAgICAgIGlmICgodmVyc2UgPj0gbG93KSAmJiAodmVyc2UgPD0gaGlnaCkpIHtcbiAgICAgICAgdmVyc2VEYXRhID0gY2hhcHRlckRhdGFbdmVyc2VLZXldO1xuICAgICAgICBmb3VuZFZlcnNlS2V5ID0gdmVyc2U7XG4gICAgICAgIG5leHRWZXJzZSA9IGhpZ2ggKyAxOyAvLyBtb3ZlIHRvIHZlcnNlIGFmdGVyIHJhbmdlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZvdW5kVmVyc2VLZXksXG4gICAgdmVyc2U6IHZlcnNlS2V5LFxuICAgIHZlcnNlRGF0YSxcbiAgICBuZXh0VmVyc2UsXG4gIH07XG59XG5cbi8qKlxuICogZmluZHMgYWxsIHZlcnNlcyBmcm9tIGJvb2tEYXRhIGNvbnRhaW5lZCBpbiByZWYsIHRoZW4gcmV0dXJucyBhcnJheSBvZiByZWZlcmVuY2VzIGFuZCB2ZXJzZSBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gYm9va0RhdGEgLSBpbmRleGVkIGJ5IGNoYXB0ZXIgYW5kIHRoZW4gdmVyc2UgcmVmXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmIC0gZm9ybWF0cyBzdWNoIGFzIOKAnDI6NC014oCdLCDigJwyOjNh4oCdLCDigJwyLTNiLTRh4oCdLCDigJwyOjcsMTLigJ0sIOKAnDc6MTEtODoy4oCdLCBcIjY6MTUtMTY7NzoyXCJcbiAqIEByZXR1cm5zIHtPYmplY3RbXX0gLSBBcnJheSBvZiBvYmplY3RzIHdpdGggY2hhcHRlciwgdmVyc2UsIHZlcnNlRGF0YSB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnNlcyhib29rRGF0YSwgcmVmKSB7XG4gIGNvbnN0IHZlcnNlcyA9IFtdO1xuICBjb25zdCBjaHVua3MgPSBwYXJzZVJlZmVyZW5jZVRvTGlzdChyZWYpO1xuICBsZXQgY2hhcHRlckRhdGEsIHZlcnNlRGF0YTtcblxuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGlmICghY2h1bmsuZW5kVmVyc2UpIHtcbiAgICAgIGNvbnN0IGNoYXB0ZXIgPSBjaHVuay5jaGFwdGVyO1xuICAgICAgY2hhcHRlckRhdGEgPSBib29rRGF0YVtjaGFwdGVyXTtcbiAgICAgIGxldCB2ZXJzZUtleSA9IGNodW5rLnZlcnNlO1xuICAgICAgdmVyc2VEYXRhID0gY2hhcHRlckRhdGEgJiYgY2hhcHRlckRhdGFbdmVyc2VLZXldO1xuXG4gICAgICBpZiAoIXZlcnNlRGF0YSAmJiBjaGFwdGVyRGF0YSkgeyAvLyBpZiB2ZXJzZSBkb2Vzbid0IGV4aXN0LCBjaGVjayBmb3IgdmVyc2Ugc3BhbnMgaW4gY2hhcHRlciBkYXRhXG4gICAgICAgIGNvbnN0IF9fcmV0ID0gZmluZFZlcnNlSW5WZXJzZVJhbmdlKGNoYXB0ZXJEYXRhLCB2ZXJzZUtleSwgY2hhcHRlcik7XG5cbiAgICAgICAgaWYgKF9fcmV0LmZvdW5kVmVyc2VLZXkpIHtcbiAgICAgICAgICB2ZXJzZUtleSA9IF9fcmV0LnZlcnNlO1xuICAgICAgICAgIHZlcnNlRGF0YSA9IF9fcmV0LnZlcnNlRGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2ZXJzZXMucHVzaCh7XG4gICAgICAgIGNoYXB0ZXIsXG4gICAgICAgIHZlcnNlOiB2ZXJzZUtleSxcbiAgICAgICAgdmVyc2VEYXRhLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHsgLy8gaGFuZGxlIHJhbmdlXG4gICAgICBsZXQgY2hhcHRlciA9IGNodW5rLmNoYXB0ZXI7XG4gICAgICBsZXQgdmVyc2UgPSBjaHVuay52ZXJzZTtcbiAgICAgIGNvbnN0IGVuZFZlcnNlID0gY2h1bmsuZW5kVmVyc2U7XG4gICAgICBjb25zdCBlbmRDaGFwdGVyID0gY2h1bmsuZW5kQ2hhcHRlciB8fCBjaGFwdGVyO1xuXG4gICAgICB3aGlsZSAoaXNWZXJzZUluUmFuZ2UoY2hhcHRlciwgdmVyc2UsIGVuZENoYXB0ZXIsIGVuZFZlcnNlKSkge1xuICAgICAgICBjaGFwdGVyRGF0YSA9IGJvb2tEYXRhW2NoYXB0ZXJdO1xuICAgICAgICB2ZXJzZURhdGEgPSBjaGFwdGVyRGF0YSAmJiBjaGFwdGVyRGF0YVt2ZXJzZV07XG4gICAgICAgIGxldCB2ZXJzZUtleSA9IHZlcnNlO1xuXG4gICAgICAgIGlmICghdmVyc2VEYXRhICYmIGNoYXB0ZXJEYXRhKSB7IC8vIGlmIHZlcnNlIGRvZXNuJ3QgZXhpc3QsIGNoZWNrIGZvciB2ZXJzZSBzcGFucyBpbiBjaGFwdGVyIGRhdGFcbiAgICAgICAgICBjb25zdCBfX3JldCA9IGZpbmRWZXJzZUluVmVyc2VSYW5nZShjaGFwdGVyRGF0YSwgdmVyc2VLZXksIGNoYXB0ZXIpO1xuXG4gICAgICAgICAgaWYgKF9fcmV0LmZvdW5kVmVyc2VLZXkpIHtcbiAgICAgICAgICAgIHZlcnNlS2V5ID0gX19yZXQudmVyc2U7XG4gICAgICAgICAgICB2ZXJzZURhdGEgPSBfX3JldC52ZXJzZURhdGE7XG4gICAgICAgICAgICB2ZXJzZSA9IF9fcmV0Lm5leHRWZXJzZSAtIDE7IC8vIGNvcnJlY3QgZm9yIGF1dG9pbmNyZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZlcnNlRGF0YSkgeyAvLyBpZiBwYXN0IGVuZCBvZiBjaGFwdGVyLCBza2lwIHRvIG5leHRcbiAgICAgICAgICBjaGFwdGVyICs9IDE7XG4gICAgICAgICAgdmVyc2UgPSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmVyc2VzLnB1c2goe1xuICAgICAgICAgIGNoYXB0ZXIsXG4gICAgICAgICAgdmVyc2U6IHZlcnNlS2V5LFxuICAgICAgICAgIHZlcnNlRGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHZlcnNlICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZlcnNlcztcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB2ZXJzZUNodW5rIE9iamVjdCByZXByZXNlbnRpbmcgYSBjaGFwdGVyIHJlZmVyZW5jZSBvciByZWZlcmVuY2UgcmFuZ2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2ZXJzZUNodW5rLmNoYXB0ZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2ZXJzZUNodW5rLnZlcnNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2VDaHVuay5lbmRDaGFwdGVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2VD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